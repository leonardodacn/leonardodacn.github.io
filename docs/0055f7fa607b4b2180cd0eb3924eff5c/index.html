<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>07 服务器端msfs源码分析 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="07 服务器端msfs源码分析 这篇文章是对TeamTalk服务程序msfs的源码和架构设计分析。msfs作用是用来接受teamtalk聊天中产生的聊天图片的上传和下载。还是老规矩，把该服务在整个架构中的位置图贴一下吧。
可以看到，msfs仅被客户端连接，客户端以http的方式来上传和下载聊天图片。
可能很多同学对http协议不是很熟悉，或者说一知半解。这里大致介绍一下http协议，http协议其实也是一种应用层协议，建立在tcp/ip层之上，其由包头和包体两部分组成（不一定要有包体），看个例子：
比如当我们用浏览器请求一个网址http://www.hootina.org/index.php，实际是浏览器给特定的服务器发送如下数据包，包头部分如下：
GET /index.php HTTP/1.1\r\n Host: www.hootina.org\r\n Connection: keep-alive\r\n Cache-Control: max-age=0\r\n Accept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,/;q=0.8\r\n User-Agent: Mozilla/5.0\r\n \r\n 这个包没有包体。
从上面我们可以看出一个http协议大致格式可以描述如下：
GET或Post请求方法 请求的资源路径 http协议版本号\r\n 字段名1：值1\r\n 字段名2：值2\r\n 字段名3：值3\r\n 字段名4：值4\r\n 字段名5：值5\r\n 字段名6：值6\r\n \r\n 也就是是http协议的头部是一行一行的，每一行以\r\n表示该行结束，最后多出一个空行以\r\n结束表示头部的结束。接下来就是包体的大小了（如果有的话，上文的例子没有包体）。一般get方法会将参数放在请求的资源路径后面，像这样
http://wwww.hootina.org/index.php?变量1=值1&amp;变量2=值2&amp;变量3=值3&amp;变量4=值4
网址后面的问号表示参数开始，每一个参数与参数之间用&amp;隔开
还有一种post的请求方法，这种数据就是将数据放在包体里面了，例如：
POST /otn/login/loginAysnSuggest HTTP/1.1\r\n Host: kyfw.12306.cn\r\n Connection: keep-alive\r\n Content-Length: 96\r\n Accept: */*\r\n Origin: https://kyfw.12306.cn\r\n X-Requested-With: XMLHttpRequest\r\n User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75\r\n Content-Type: application/x-www-form-urlencoded; charset=UTF-8\r\n Referer: https://kyfw.12306.cn/otn/login/init\r\n Accept-Encoding: gzip, deflate, br\r\n Accept-Language: zh-CN,zh;q=0.8\r\n \r\n loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=xxxxgjqf&amp;randCode=184%2C55%2C37%2C117 上述报文中loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=2032_scsgjqf&amp;randCode=184%2C55%2C37%2C117 其实包体内容，这个包是我的一个12306买票软件发给12306服务器的报文。这里拿来做个例子。
因为对方收到http报文的时候，如果包体有内容，那么必须告诉对方包体有多大。这个最常用的就是通过包头的Content-Length字段来指定大小。上面的例子中Content-Length等于96，正好就是字符串 loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=xxxxgjqf&amp;randCode=184%2C55%2C37%2C117 的长度，也就是包体的大小。
还有一种叫做http chunk的编码技术，通过对http包内容进行分块传输。这里就不介绍了（如果你感兴趣，可以私聊我）。
常见的对http协议有如下几个误解：
html文档的头就是http的头 这种认识是错误的，html文档的头部也是http数据包的包体的一部分。正确的http头是长的像上文介绍的那种。
关于http头Connection:keep-alive字段 一端指定了这个字段后，发http包给另外一端。这个选项只是一种建议性的选项，对端不一定必须采纳，对方也可能在实际实现时，将http连接设置为短连接，即不采纳这个字段的建议。
每个字段都是必须的吗？ 不是，大多数字段都不是必须的。但是特定的情况下，某些字段是必须的。比如，通过post发送的数据，就必须设置Content-Length。不然，收包的一端如何知道包体多大。又比如如果你的数据采取了gzip压缩格式，你就必须指定Accept-Encoding: gzip，然对方如何解包你的数据。
好了，http协议就暂且介绍这么多，下面回到正题上来说msfs的源码。
msfs在main函数里面做了如下初始化工作，伪码如下：
//1. 建立一个两个任务队列，分别处理http get请求和post请求 //2. 创建名称为000～255的文件夹，每个文件夹里面会有000～255个子目录，这些目录用于存放聊天图片 //3. 在8700端口上监听客户端连接 //4. 启动程序消息泵 第1点，建立任务队列我们前面系列的文章已经介绍过了。">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/0055f7fa607b4b2180cd0eb3924eff5c/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="07 服务器端msfs源码分析" />
<meta property="og:description" content="07 服务器端msfs源码分析 这篇文章是对TeamTalk服务程序msfs的源码和架构设计分析。msfs作用是用来接受teamtalk聊天中产生的聊天图片的上传和下载。还是老规矩，把该服务在整个架构中的位置图贴一下吧。
可以看到，msfs仅被客户端连接，客户端以http的方式来上传和下载聊天图片。
可能很多同学对http协议不是很熟悉，或者说一知半解。这里大致介绍一下http协议，http协议其实也是一种应用层协议，建立在tcp/ip层之上，其由包头和包体两部分组成（不一定要有包体），看个例子：
比如当我们用浏览器请求一个网址http://www.hootina.org/index.php，实际是浏览器给特定的服务器发送如下数据包，包头部分如下：
GET /index.php HTTP/1.1\r\n Host: www.hootina.org\r\n Connection: keep-alive\r\n Cache-Control: max-age=0\r\n Accept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,/;q=0.8\r\n User-Agent: Mozilla/5.0\r\n \r\n 这个包没有包体。
从上面我们可以看出一个http协议大致格式可以描述如下：
GET或Post请求方法 请求的资源路径 http协议版本号\r\n 字段名1：值1\r\n 字段名2：值2\r\n 字段名3：值3\r\n 字段名4：值4\r\n 字段名5：值5\r\n 字段名6：值6\r\n \r\n 也就是是http协议的头部是一行一行的，每一行以\r\n表示该行结束，最后多出一个空行以\r\n结束表示头部的结束。接下来就是包体的大小了（如果有的话，上文的例子没有包体）。一般get方法会将参数放在请求的资源路径后面，像这样
http://wwww.hootina.org/index.php?变量1=值1&amp;变量2=值2&amp;变量3=值3&amp;变量4=值4
网址后面的问号表示参数开始，每一个参数与参数之间用&amp;隔开
还有一种post的请求方法，这种数据就是将数据放在包体里面了，例如：
POST /otn/login/loginAysnSuggest HTTP/1.1\r\n Host: kyfw.12306.cn\r\n Connection: keep-alive\r\n Content-Length: 96\r\n Accept: */*\r\n Origin: https://kyfw.12306.cn\r\n X-Requested-With: XMLHttpRequest\r\n User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75\r\n Content-Type: application/x-www-form-urlencoded; charset=UTF-8\r\n Referer: https://kyfw.12306.cn/otn/login/init\r\n Accept-Encoding: gzip, deflate, br\r\n Accept-Language: zh-CN,zh;q=0.8\r\n \r\n loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=xxxxgjqf&amp;randCode=184%2C55%2C37%2C117 上述报文中loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=2032_scsgjqf&amp;randCode=184%2C55%2C37%2C117 其实包体内容，这个包是我的一个12306买票软件发给12306服务器的报文。这里拿来做个例子。
因为对方收到http报文的时候，如果包体有内容，那么必须告诉对方包体有多大。这个最常用的就是通过包头的Content-Length字段来指定大小。上面的例子中Content-Length等于96，正好就是字符串 loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=xxxxgjqf&amp;randCode=184%2C55%2C37%2C117 的长度，也就是包体的大小。
还有一种叫做http chunk的编码技术，通过对http包内容进行分块传输。这里就不介绍了（如果你感兴趣，可以私聊我）。
常见的对http协议有如下几个误解：
html文档的头就是http的头 这种认识是错误的，html文档的头部也是http数据包的包体的一部分。正确的http头是长的像上文介绍的那种。
关于http头Connection:keep-alive字段 一端指定了这个字段后，发http包给另外一端。这个选项只是一种建议性的选项，对端不一定必须采纳，对方也可能在实际实现时，将http连接设置为短连接，即不采纳这个字段的建议。
每个字段都是必须的吗？ 不是，大多数字段都不是必须的。但是特定的情况下，某些字段是必须的。比如，通过post发送的数据，就必须设置Content-Length。不然，收包的一端如何知道包体多大。又比如如果你的数据采取了gzip压缩格式，你就必须指定Accept-Encoding: gzip，然对方如何解包你的数据。
好了，http协议就暂且介绍这么多，下面回到正题上来说msfs的源码。
msfs在main函数里面做了如下初始化工作，伪码如下：
//1. 建立一个两个任务队列，分别处理http get请求和post请求 //2. 创建名称为000～255的文件夹，每个文件夹里面会有000～255个子目录，这些目录用于存放聊天图片 //3. 在8700端口上监听客户端连接 //4. 启动程序消息泵 第1点，建立任务队列我们前面系列的文章已经介绍过了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/0055f7fa607b4b2180cd0eb3924eff5c/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="07 服务器端msfs源码分析"/>
<meta name="twitter:description" content="07 服务器端msfs源码分析 这篇文章是对TeamTalk服务程序msfs的源码和架构设计分析。msfs作用是用来接受teamtalk聊天中产生的聊天图片的上传和下载。还是老规矩，把该服务在整个架构中的位置图贴一下吧。
可以看到，msfs仅被客户端连接，客户端以http的方式来上传和下载聊天图片。
可能很多同学对http协议不是很熟悉，或者说一知半解。这里大致介绍一下http协议，http协议其实也是一种应用层协议，建立在tcp/ip层之上，其由包头和包体两部分组成（不一定要有包体），看个例子：
比如当我们用浏览器请求一个网址http://www.hootina.org/index.php，实际是浏览器给特定的服务器发送如下数据包，包头部分如下：
GET /index.php HTTP/1.1\r\n Host: www.hootina.org\r\n Connection: keep-alive\r\n Cache-Control: max-age=0\r\n Accept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,/;q=0.8\r\n User-Agent: Mozilla/5.0\r\n \r\n 这个包没有包体。
从上面我们可以看出一个http协议大致格式可以描述如下：
GET或Post请求方法 请求的资源路径 http协议版本号\r\n 字段名1：值1\r\n 字段名2：值2\r\n 字段名3：值3\r\n 字段名4：值4\r\n 字段名5：值5\r\n 字段名6：值6\r\n \r\n 也就是是http协议的头部是一行一行的，每一行以\r\n表示该行结束，最后多出一个空行以\r\n结束表示头部的结束。接下来就是包体的大小了（如果有的话，上文的例子没有包体）。一般get方法会将参数放在请求的资源路径后面，像这样
http://wwww.hootina.org/index.php?变量1=值1&amp;变量2=值2&amp;变量3=值3&amp;变量4=值4
网址后面的问号表示参数开始，每一个参数与参数之间用&amp;隔开
还有一种post的请求方法，这种数据就是将数据放在包体里面了，例如：
POST /otn/login/loginAysnSuggest HTTP/1.1\r\n Host: kyfw.12306.cn\r\n Connection: keep-alive\r\n Content-Length: 96\r\n Accept: */*\r\n Origin: https://kyfw.12306.cn\r\n X-Requested-With: XMLHttpRequest\r\n User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75\r\n Content-Type: application/x-www-form-urlencoded; charset=UTF-8\r\n Referer: https://kyfw.12306.cn/otn/login/init\r\n Accept-Encoding: gzip, deflate, br\r\n Accept-Language: zh-CN,zh;q=0.8\r\n \r\n loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=xxxxgjqf&amp;randCode=184%2C55%2C37%2C117 上述报文中loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=2032_scsgjqf&amp;randCode=184%2C55%2C37%2C117 其实包体内容，这个包是我的一个12306买票软件发给12306服务器的报文。这里拿来做个例子。
因为对方收到http报文的时候，如果包体有内容，那么必须告诉对方包体有多大。这个最常用的就是通过包头的Content-Length字段来指定大小。上面的例子中Content-Length等于96，正好就是字符串 loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=xxxxgjqf&amp;randCode=184%2C55%2C37%2C117 的长度，也就是包体的大小。
还有一种叫做http chunk的编码技术，通过对http包内容进行分块传输。这里就不介绍了（如果你感兴趣，可以私聊我）。
常见的对http协议有如下几个误解：
html文档的头就是http的头 这种认识是错误的，html文档的头部也是http数据包的包体的一部分。正确的http头是长的像上文介绍的那种。
关于http头Connection:keep-alive字段 一端指定了这个字段后，发http包给另外一端。这个选项只是一种建议性的选项，对端不一定必须采纳，对方也可能在实际实现时，将http连接设置为短连接，即不采纳这个字段的建议。
每个字段都是必须的吗？ 不是，大多数字段都不是必须的。但是特定的情况下，某些字段是必须的。比如，通过post发送的数据，就必须设置Content-Length。不然，收包的一端如何知道包体多大。又比如如果你的数据采取了gzip压缩格式，你就必须指定Accept-Encoding: gzip，然对方如何解包你的数据。
好了，http协议就暂且介绍这么多，下面回到正题上来说msfs的源码。
msfs在main函数里面做了如下初始化工作，伪码如下：
//1. 建立一个两个任务队列，分别处理http get请求和post请求 //2. 创建名称为000～255的文件夹，每个文件夹里面会有000～255个子目录，这些目录用于存放聊天图片 //3. 在8700端口上监听客户端连接 //4. 启动程序消息泵 第1点，建立任务队列我们前面系列的文章已经介绍过了。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "07 服务器端msfs源码分析",
      "item": "https://haokiu.com/0055f7fa607b4b2180cd0eb3924eff5c/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "07 服务器端msfs源码分析",
  "name": "07 服务器端msfs源码分析",
  "description": "07 服务器端msfs源码分析 这篇文章是对TeamTalk服务程序msfs的源码和架构设计分析。msfs作用是用来接受teamtalk聊天中产生的聊天图片的上传和下载。还是老规矩，把该服务在整个架构中的位置图贴一下吧。\n可以看到，msfs仅被客户端连接，客户端以http的方式来上传和下载聊天图片。\n可能很多同学对http协议不是很熟悉，或者说一知半解。这里大致介绍一下http协议，http协议其实也是一种应用层协议，建立在tcp/ip层之上，其由包头和包体两部分组成（不一定要有包体），看个例子：\n比如当我们用浏览器请求一个网址http://www.hootina.org/index.php，实际是浏览器给特定的服务器发送如下数据包，包头部分如下：\nGET /index.php HTTP/1.1\\r\\n Host: www.hootina.org\\r\\n Connection: keep-alive\\r\\n Cache-Control: max-age=0\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8\\r\\n User-Agent: Mozilla/5.0\\r\\n \\r\\n 这个包没有包体。\n从上面我们可以看出一个http协议大致格式可以描述如下：\nGET或Post请求方法 请求的资源路径 http协议版本号\\r\\n 字段名1：值1\\r\\n 字段名2：值2\\r\\n 字段名3：值3\\r\\n 字段名4：值4\\r\\n 字段名5：值5\\r\\n 字段名6：值6\\r\\n \\r\\n 也就是是http协议的头部是一行一行的，每一行以\\r\\n表示该行结束，最后多出一个空行以\\r\\n结束表示头部的结束。接下来就是包体的大小了（如果有的话，上文的例子没有包体）。一般get方法会将参数放在请求的资源路径后面，像这样\nhttp://wwww.hootina.org/index.php?变量1=值1\u0026amp;变量2=值2\u0026amp;变量3=值3\u0026amp;变量4=值4\n网址后面的问号表示参数开始，每一个参数与参数之间用\u0026amp;隔开\n还有一种post的请求方法，这种数据就是将数据放在包体里面了，例如：\nPOST /otn/login/loginAysnSuggest HTTP/1.1\\r\\n Host: kyfw.12306.cn\\r\\n Connection: keep-alive\\r\\n Content-Length: 96\\r\\n Accept: */*\\r\\n Origin: https://kyfw.12306.cn\\r\\n X-Requested-With: XMLHttpRequest\\r\\n User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75\\r\\n Content-Type: application/x-www-form-urlencoded; charset=UTF-8\\r\\n Referer: https://kyfw.12306.cn/otn/login/init\\r\\n Accept-Encoding: gzip, deflate, br\\r\\n Accept-Language: zh-CN,zh;q=0.8\\r\\n \\r\\n loginUserDTO.user_name=balloonwj%40qq.com\u0026amp;userDTO.password=xxxxgjqf\u0026amp;randCode=184%2C55%2C37%2C117 上述报文中loginUserDTO.user_name=balloonwj%40qq.com\u0026amp;userDTO.password=2032_scsgjqf\u0026amp;randCode=184%2C55%2C37%2C117 其实包体内容，这个包是我的一个12306买票软件发给12306服务器的报文。这里拿来做个例子。\n因为对方收到http报文的时候，如果包体有内容，那么必须告诉对方包体有多大。这个最常用的就是通过包头的Content-Length字段来指定大小。上面的例子中Content-Length等于96，正好就是字符串 loginUserDTO.user_name=balloonwj%40qq.com\u0026amp;userDTO.password=xxxxgjqf\u0026amp;randCode=184%2C55%2C37%2C117 的长度，也就是包体的大小。\n还有一种叫做http chunk的编码技术，通过对http包内容进行分块传输。这里就不介绍了（如果你感兴趣，可以私聊我）。\n常见的对http协议有如下几个误解：\nhtml文档的头就是http的头 这种认识是错误的，html文档的头部也是http数据包的包体的一部分。正确的http头是长的像上文介绍的那种。\n关于http头Connection:keep-alive字段 一端指定了这个字段后，发http包给另外一端。这个选项只是一种建议性的选项，对端不一定必须采纳，对方也可能在实际实现时，将http连接设置为短连接，即不采纳这个字段的建议。\n每个字段都是必须的吗？ 不是，大多数字段都不是必须的。但是特定的情况下，某些字段是必须的。比如，通过post发送的数据，就必须设置Content-Length。不然，收包的一端如何知道包体多大。又比如如果你的数据采取了gzip压缩格式，你就必须指定Accept-Encoding: gzip，然对方如何解包你的数据。\n好了，http协议就暂且介绍这么多，下面回到正题上来说msfs的源码。\nmsfs在main函数里面做了如下初始化工作，伪码如下：\n//1. 建立一个两个任务队列，分别处理http get请求和post请求 //2. 创建名称为000～255的文件夹，每个文件夹里面会有000～255个子目录，这些目录用于存放聊天图片 //3. 在8700端口上监听客户端连接 //4. 启动程序消息泵 第1点，建立任务队列我们前面系列的文章已经介绍过了。",
  "keywords": [
    
  ],
  "articleBody": "07 服务器端msfs源码分析 这篇文章是对TeamTalk服务程序msfs的源码和架构设计分析。msfs作用是用来接受teamtalk聊天中产生的聊天图片的上传和下载。还是老规矩，把该服务在整个架构中的位置图贴一下吧。\n可以看到，msfs仅被客户端连接，客户端以http的方式来上传和下载聊天图片。\n可能很多同学对http协议不是很熟悉，或者说一知半解。这里大致介绍一下http协议，http协议其实也是一种应用层协议，建立在tcp/ip层之上，其由包头和包体两部分组成（不一定要有包体），看个例子：\n比如当我们用浏览器请求一个网址http://www.hootina.org/index.php，实际是浏览器给特定的服务器发送如下数据包，包头部分如下：\nGET /index.php HTTP/1.1\\r\\n Host: www.hootina.org\\r\\n Connection: keep-alive\\r\\n Cache-Control: max-age=0\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8\\r\\n User-Agent: Mozilla/5.0\\r\\n \\r\\n 这个包没有包体。\n从上面我们可以看出一个http协议大致格式可以描述如下：\nGET或Post请求方法 请求的资源路径 http协议版本号\\r\\n 字段名1：值1\\r\\n 字段名2：值2\\r\\n 字段名3：值3\\r\\n 字段名4：值4\\r\\n 字段名5：值5\\r\\n 字段名6：值6\\r\\n \\r\\n 也就是是http协议的头部是一行一行的，每一行以\\r\\n表示该行结束，最后多出一个空行以\\r\\n结束表示头部的结束。接下来就是包体的大小了（如果有的话，上文的例子没有包体）。一般get方法会将参数放在请求的资源路径后面，像这样\nhttp://wwww.hootina.org/index.php?变量1=值1\u0026变量2=值2\u0026变量3=值3\u0026变量4=值4\n网址后面的问号表示参数开始，每一个参数与参数之间用\u0026隔开\n还有一种post的请求方法，这种数据就是将数据放在包体里面了，例如：\nPOST /otn/login/loginAysnSuggest HTTP/1.1\\r\\n Host: kyfw.12306.cn\\r\\n Connection: keep-alive\\r\\n Content-Length: 96\\r\\n Accept: */*\\r\\n Origin: https://kyfw.12306.cn\\r\\n X-Requested-With: XMLHttpRequest\\r\\n User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75\\r\\n Content-Type: application/x-www-form-urlencoded; charset=UTF-8\\r\\n Referer: https://kyfw.12306.cn/otn/login/init\\r\\n Accept-Encoding: gzip, deflate, br\\r\\n Accept-Language: zh-CN,zh;q=0.8\\r\\n \\r\\n loginUserDTO.user_name=balloonwj%40qq.com\u0026userDTO.password=xxxxgjqf\u0026randCode=184%2C55%2C37%2C117 上述报文中loginUserDTO.user_name=balloonwj%40qq.com\u0026userDTO.password=2032_scsgjqf\u0026randCode=184%2C55%2C37%2C117 其实包体内容，这个包是我的一个12306买票软件发给12306服务器的报文。这里拿来做个例子。\n因为对方收到http报文的时候，如果包体有内容，那么必须告诉对方包体有多大。这个最常用的就是通过包头的Content-Length字段来指定大小。上面的例子中Content-Length等于96，正好就是字符串 loginUserDTO.user_name=balloonwj%40qq.com\u0026userDTO.password=xxxxgjqf\u0026randCode=184%2C55%2C37%2C117 的长度，也就是包体的大小。\n还有一种叫做http chunk的编码技术，通过对http包内容进行分块传输。这里就不介绍了（如果你感兴趣，可以私聊我）。\n常见的对http协议有如下几个误解：\nhtml文档的头就是http的头 这种认识是错误的，html文档的头部也是http数据包的包体的一部分。正确的http头是长的像上文介绍的那种。\n关于http头Connection:keep-alive字段 一端指定了这个字段后，发http包给另外一端。这个选项只是一种建议性的选项，对端不一定必须采纳，对方也可能在实际实现时，将http连接设置为短连接，即不采纳这个字段的建议。\n每个字段都是必须的吗？ 不是，大多数字段都不是必须的。但是特定的情况下，某些字段是必须的。比如，通过post发送的数据，就必须设置Content-Length。不然，收包的一端如何知道包体多大。又比如如果你的数据采取了gzip压缩格式，你就必须指定Accept-Encoding: gzip，然对方如何解包你的数据。\n好了，http协议就暂且介绍这么多，下面回到正题上来说msfs的源码。\nmsfs在main函数里面做了如下初始化工作，伪码如下：\n//1. 建立一个两个任务队列，分别处理http get请求和post请求 //2. 创建名称为000～255的文件夹，每个文件夹里面会有000～255个子目录，这些目录用于存放聊天图片 //3. 在8700端口上监听客户端连接 //4. 启动程序消息泵 第1点，建立任务队列我们前面系列的文章已经介绍过了。\n第2点，代码如下：\ng_fileManager = FileManager::getInstance(listen_ip, base_dir, fileCnt, filesPerDir); int ret = g_fileManager-\u003einitDir(); int FileManager::initDir() { bool isExist = File::isExist(m_disk); if (!isExist) { u64 ret = File::mkdirNoRecursion(m_disk); if (ret) { log(\"The dir[%s] set error for code[%d], \\ its parent dir may no exists\", m_disk, ret); return -1; } } //255 X 255 char first[10] = {0}; char second[10] = {0}; for (int i = 0; i \u003c= FIRST_DIR_MAX; i++) { snprintf(first, 5, \"%03d\", i); string tmp = string(m_disk) + \"/\" + string(first); int code = File::mkdirNoRecursion(tmp.c_str()); if (code \u0026\u0026 (errno != EEXIST)) { log(\"Create dir[%s] error[%d]\", tmp.c_str(), errno); return -1; } for (int j = 0; j \u003c= SECOND_DIR_MAX; j++) { snprintf(second, 5, \"%03d\", j); string tmp2 = tmp + \"/\" + string(second); code = File::mkdirNoRecursion(tmp2.c_str()); if (code \u0026\u0026 (errno != EEXIST)) { log(\"Create dir[%s] error[%d]\", tmp2.c_str(), errno); return -1; } memset(second, 0x0, 10); } memset(first, 0x0, 10); } return 0; } 下面，我们直接来看如何处理客户端的http请求，当连接对象CHttpConn收到客户端数据后，调用OnRead方法：\nvoid CHttpConn::OnRead() { for (;;) { uint32_t free_buf_len = m_in_buf.GetAllocSize() - m_in_buf.GetWriteOffset(); if (free_buf_len \u003c READ_BUF_SIZE + 1) m_in_buf.Extend(READ_BUF_SIZE + 1); int ret = netlib_recv(m_sock_handle, m_in_buf.GetBuffer() + m_in_buf.GetWriteOffset(), READ_BUF_SIZE); if (ret \u003c= 0) break; m_in_buf.IncWriteOffset(ret); m_last_recv_tick = get_tick_count(); } // 每次请求对应一个HTTP连接，所以读完数据后，不用在同一个连接里面准备读取下个请求 char* in_buf = (char*) m_in_buf.GetBuffer(); uint32_t buf_len = m_in_buf.GetWriteOffset(); in_buf[buf_len] = '\\0'; //log(\"OnRead, buf_len=%u, conn_handle=%u\", buf_len, m_conn_handle); // for debug m_HttpParser.ParseHttpContent(in_buf, buf_len); if (m_HttpParser.IsReadAll()) { string strUrl = m_HttpParser.GetUrl(); log(\"IP:%s access:%s\", m_peer_ip.c_str(), strUrl.c_str()); if (strUrl.find(\"..\") != strUrl.npos) { Close(); return; } m_access_host = m_HttpParser.GetHost(); if (m_HttpParser.GetContentLen() \u003e HTTP_UPLOAD_MAX) { // file is too big log(\"content is too big\"); char url[128]; snprintf(url, sizeof(url), \"{\\\"error_code\\\":1,\\\"error_msg\\\": \\\"上传文件过大\\\",\\\"url\\\":\\\"\\\"}\"); log(\"%s\",url); uint32_t content_length = strlen(url); char pContent[1024]; snprintf(pContent, sizeof(pContent), HTTP_RESPONSE_HTML, content_length,url); Send(pContent, strlen(pContent)); return; } int nContentLen = m_HttpParser.GetContentLen(); char* pContent = NULL; if(nContentLen != 0) { try { pContent =new char[nContentLen]; memcpy(pContent, m_HttpParser.GetBodyContent(), nContentLen); } catch(...) { log(\"not enough memory\"); char szResponse[HTTP_RESPONSE_500_LEN + 1]; snprintf(szResponse, HTTP_RESPONSE_500_LEN, \"%s\", HTTP_RESPONSE_500); Send(szResponse, HTTP_RESPONSE_500_LEN); return; } } Request_t request; request.conn_handle = m_conn_handle; request.method = m_HttpParser.GetMethod();; request.nContentLen = nContentLen; request.pContent = pContent; request.strAccessHost = m_HttpParser.GetHost(); request.strContentType = m_HttpParser.GetContentType(); request.strUrl = m_HttpParser.GetUrl() + 1; CHttpTask* pTask = new CHttpTask(request); if(HTTP_GET == m_HttpParser.GetMethod()) { g_GetThreadPool.AddTask(pTask); } else { g_PostThreadPool.AddTask(pTask); } } } 该方法先收取数据，接着解包，然后根据客户端发送的http请求到底是get还是post方法，分别往对应的get和post任务队列中丢一个任务CHttpTask。任务队列开始处理这个任务。我们以get请求的任务为例（Post请求与此类似）：\nvoid CHttpTask::run() { if(HTTP_GET == m_nMethod) { OnDownload(); } else if(HTTP_POST == m_nMethod) { OnUpload(); } else { char* pContent = new char[strlen(HTTP_RESPONSE_403)]; snprintf(pContent, strlen(HTTP_RESPONSE_403), HTTP_RESPONSE_403); CHttpConn::AddResponsePdu(m_ConnHandle, pContent, strlen(pContent)); } if(m_pContent != NULL) { delete [] m_pContent; m_pContent = NULL; } } 处理任务时，根据请求类型判断到底是客户端下载图片还是上传图片，如果是下载图片则从本机缓存的图片信息中找到该图片，并读取该图片数据，因为是聊天图片，所以一般不会很大，所以这里都是一次性读取图片字节内容，然后发出去。\nvoid CHttpTask::OnDownload() { uint32_t nFileSize = 0; int32_t nTmpSize = 0; string strPath; if(g_fileManager-\u003egetAbsPathByUrl(m_strUrl, strPath ) == 0) { nTmpSize = File::getFileSize((char*)strPath.c_str()); if(nTmpSize != -1) { char szResponseHeader[1024]; size_t nPos = strPath.find_last_of(\".\"); string strType = strPath.substr(nPos + 1, strPath.length() - nPos); if(strType == \"jpg\" || strType == \"JPG\" || strType == \"jpeg\" || strType == \"JPEG\" || strType == \"png\" || strType == \"PNG\" || strType == \"gif\" || strType == \"GIF\") { snprintf(szResponseHeader, sizeof(szResponseHeader), HTTP_RESPONSE_IMAGE, nTmpSize, strType.c_str()); } else { snprintf(szResponseHeader,sizeof(szResponseHeader), HTTP_RESPONSE_EXTEND, nTmpSize); } int nLen = strlen(szResponseHeader); char* pContent = new char[nLen + nTmpSize]; memcpy(pContent, szResponseHeader, nLen); g_fileManager-\u003edownloadFileByUrl((char*)m_strUrl.c_str(), pContent + nLen, \u0026nFileSize); int nTotalLen = nLen + nFileSize; CHttpConn::AddResponsePdu(m_ConnHandle, pContent, nTotalLen); } else { int nTotalLen = strlen(HTTP_RESPONSE_404); char* pContent = new char[nTotalLen]; snprintf(pContent, nTotalLen, HTTP_RESPONSE_404); CHttpConn::AddResponsePdu(m_ConnHandle, pContent, nTotalLen); log(\"File size is invalied\\n\"); } } else { int nTotalLen = strlen(HTTP_RESPONSE_500); char* pContent = new char[nTotalLen]; snprintf(pContent, nTotalLen, HTTP_RESPONSE_500); CHttpConn::AddResponsePdu(m_ConnHandle, pContent, nTotalLen); } } 这里需要说明一下的就是FileManager::getAbsPathByUrl在获取本地文件时，用了一个锁，该锁是为了防止同一个进程同时读取同一个文件，这个锁是“建议性”的，必须自己主动检测有没有上锁：\nint FileManager::getAbsPathByUrl(const string \u0026url, string \u0026path) { string relate; if (getRelatePathByUrl(url, relate)) { log(\"Get path from url[%s] error\", url.c_str()); return -1; } path = string(m_disk) + relate; return 0; } u64 File::open(bool directIo) { assert(!m_opened); int flags = O_RDWR; #ifdef __linux__\tm_file = open64(m_path, flags); #elif defined(__FREEBSD__) || defined(__APPLE__) m_file = ::open(m_path, flags); #endif\tif(-1 == m_file) { return errno; } #ifdef __LINUX__ if (directIo) if (-1 == fcntl(m_file, F_SETFL, O_DIRECT)) return errno; #endif\tstruct flock lock; lock.l_type = F_WRLCK; lock.l_start = 0; lock.l_whence = SEEK_SET; lock.l_len = 0; if(fcntl(m_file, F_SETLK, \u0026lock) \u003c 0) { ::close(m_file); return errno; } m_opened = true; u64 size = 0; u64 code = getSize(\u0026size); if (code) { close(); return code; } m_size = size; m_directIo = directIo; return 0; } 注意上面的fcntl函数设置的flock锁。这个是linux特有的，应该学习掌握。\n图片上传的逻辑和下载逻辑大致类似，这里就不再分析了。\n当然，发送图片数据的包和前面的发送逻辑也是一样的，在OnWrite里面发送。发送完毕后会调用CHttpConn::OnSendComplete，在这个函数里面关闭http连接。这也就是说msfs与客户端的http连接也是短连接。\nvoid CHttpConn::OnSendComplete() { Close(); } 关于msfs也就这么多内容了。不知道你有没有发现，在搞清楚db_proxy_server和msg_server之后，每个程序框架其实都是一样的，只不过业务逻辑稍微有一点差别。后面介绍的file_server和route_server都是一样的。我们也着重分析其业务代码。\n好了，msfs服务就这么多啦。\n",
  "wordCount" : "791",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/0055f7fa607b4b2180cd0eb3924eff5c/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      07 服务器端msfs源码分析
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#07-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%afmsfs%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" aria-label="07 服务器端msfs源码分析">07 服务器端msfs源码分析</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="07-服务器端msfs源码分析">07 服务器端msfs源码分析</h1>
<p>这篇文章是对TeamTalk服务程序msfs的源码和架构设计分析。msfs作用是用来接受teamtalk聊天中产生的聊天图片的上传和下载。还是老规矩，把该服务在整个架构中的位置图贴一下吧。</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/b5176e5e61fbb5a73c357b73fa8cdece.jpg" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>可以看到，msfs仅被客户端连接，客户端以http的方式来上传和下载聊天图片。</p>
<p>可能很多同学对http协议不是很熟悉，或者说一知半解。这里大致介绍一下http协议，http协议其实也是一种应用层协议，建立在tcp/ip层之上，其由包头和包体两部分组成（不一定要有包体），看个例子：</p>
<p>比如当我们用浏览器请求一个网址http://www.hootina.org/index.php，实际是浏览器给特定的服务器发送如下数据包，包头部分如下：</p>
<pre tabindex="0"><code>GET /index.php HTTP/1.1\r\n
Host: www.hootina.org\r\n
Connection: keep-alive\r\n
Cache-Control: max-age=0\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8\r\n
User-Agent: Mozilla/5.0\r\n
\r\n
</code></pre><p>这个包没有包体。</p>
<p>从上面我们可以看出一个http协议大致格式可以描述如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>GET或Post请求方法  请求的资源路径 http协议版本号\r\n
</span></span><span style="display:flex;"><span>字段名1：值1\r\n
</span></span><span style="display:flex;"><span>字段名2：值2\r\n
</span></span><span style="display:flex;"><span>字段名3：值3\r\n
</span></span><span style="display:flex;"><span>字段名4：值4\r\n
</span></span><span style="display:flex;"><span>字段名5：值5\r\n
</span></span><span style="display:flex;"><span>字段名6：值6\r\n
</span></span><span style="display:flex;"><span>\r\n
</span></span></code></pre></div><p>也就是是http协议的头部是一行一行的，每一行以\r\n表示该行结束，最后多出一个空行以\r\n结束表示头部的结束。接下来就是包体的大小了（如果有的话，上文的例子没有包体）。一般get方法会将参数放在请求的资源路径后面，像这样</p>
<p><a href="http://wwww.hootina.org/index.php">http://wwww.hootina.org/index.php</a>?变量1=值1&amp;变量2=值2&amp;变量3=值3&amp;变量4=值4</p>
<p>网址后面的问号表示参数开始，每一个参数与参数之间用&amp;隔开</p>
<p>还有一种post的请求方法，这种数据就是将数据放在包体里面了，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>POST /otn/login/loginAysnSuggest HTTP/1.1\r\n
</span></span><span style="display:flex;"><span>Host: kyfw.12306.cn\r\n
</span></span><span style="display:flex;"><span>Connection: keep-alive\r\n
</span></span><span style="display:flex;"><span>Content-Length: 96\r\n
</span></span><span style="display:flex;"><span>Accept: */*\r\n
</span></span><span style="display:flex;"><span>Origin: https://kyfw.12306.cn\r\n
</span></span><span style="display:flex;"><span>X-Requested-With: XMLHttpRequest\r\n
</span></span><span style="display:flex;"><span>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75\r\n 
</span></span><span style="display:flex;"><span>Content-Type: application/x-www-form-urlencoded; charset=UTF-8\r\n
</span></span><span style="display:flex;"><span>Referer: https://kyfw.12306.cn/otn/login/init\r\n
</span></span><span style="display:flex;"><span>Accept-Encoding: gzip, deflate, br\r\n
</span></span><span style="display:flex;"><span>Accept-Language: zh-CN,zh;q=0.8\r\n
</span></span><span style="display:flex;"><span>\r\n
</span></span><span style="display:flex;"><span>loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=xxxxgjqf&amp;randCode=184%2C55%2C37%2C117
</span></span></code></pre></div><p>上述报文中<code>loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=2032_scsgjqf&amp;randCode=184%2C55%2C37%2C117</code> 其实包体内容，这个包是我的一个12306买票软件发给12306服务器的报文。这里拿来做个例子。</p>
<p>因为对方收到http报文的时候，如果包体有内容，那么必须告诉对方包体有多大。这个最常用的就是通过包头的Content-Length字段来指定大小。上面的例子中Content-Length等于96，正好就是字符串 <code>loginUserDTO.user_name=balloonwj%40qq.com&amp;userDTO.password=xxxxgjqf&amp;randCode=184%2C55%2C37%2C117</code> 的长度，也就是包体的大小。</p>
<p>还有一种叫做http chunk的编码技术，通过对http包内容进行分块传输。这里就不介绍了（如果你感兴趣，可以私聊我）。</p>
<p>常见的对http协议有如下几个误解：</p>
<ol>
<li>html文档的头就是http的头</li>
</ol>
<p>这种认识是错误的，html文档的头部也是http数据包的包体的一部分。正确的http头是长的像上文介绍的那种。</p>
<ol start="2">
<li>关于http头Connection:keep-alive字段</li>
</ol>
<p>一端指定了这个字段后，发http包给另外一端。这个选项只是一种建议性的选项，对端不一定必须采纳，对方也可能在实际实现时，将http连接设置为短连接，即不采纳这个字段的建议。</p>
<ol start="3">
<li>每个字段都是必须的吗？</li>
</ol>
<p>不是，大多数字段都不是必须的。但是特定的情况下，某些字段是必须的。比如，通过post发送的数据，就必须设置Content-Length。不然，收包的一端如何知道包体多大。又比如如果你的数据采取了gzip压缩格式，你就必须指定Accept-Encoding: gzip，然对方如何解包你的数据。</p>
<p>好了，http协议就暂且介绍这么多，下面回到正题上来说msfs的源码。</p>
<p>msfs在main函数里面做了如下初始化工作，伪码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//1. 建立一个两个任务队列，分别处理http get请求和post请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//2. 创建名称为000～255的文件夹，每个文件夹里面会有000～255个子目录，这些目录用于存放聊天图片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//3. 在8700端口上监听客户端连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//4. 启动程序消息泵
</span></span></span></code></pre></div><p>第1点，建立任务队列我们前面系列的文章已经介绍过了。</p>
<p>第2点，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>g_fileManager <span style="color:#f92672">=</span> FileManager<span style="color:#f92672">::</span>getInstance(listen_ip, base_dir, fileCnt, filesPerDir);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> g_fileManager<span style="color:#f92672">-&gt;</span>initDir();
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> FileManager<span style="color:#f92672">::</span>initDir() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">bool</span> isExist <span style="color:#f92672">=</span> File<span style="color:#f92672">::</span>isExist(m_disk);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isExist) {
</span></span><span style="display:flex;"><span>			u64 ret <span style="color:#f92672">=</span> File<span style="color:#f92672">::</span>mkdirNoRecursion(m_disk);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (ret) {
</span></span><span style="display:flex;"><span>				log(<span style="color:#e6db74">&#34;The dir[%s] set error for code[%d], \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">				    its parent dir may no exists&#34;</span>, m_disk, ret);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//255 X 255 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">char</span> first[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span> second[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> FIRST_DIR_MAX; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			snprintf(first, <span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;%03d&#34;</span>, i);
</span></span><span style="display:flex;"><span>			string tmp <span style="color:#f92672">=</span> string(m_disk) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#f92672">+</span> string(first);
</span></span><span style="display:flex;"><span>		    <span style="color:#66d9ef">int</span> code <span style="color:#f92672">=</span> File<span style="color:#f92672">::</span>mkdirNoRecursion(tmp.c_str());
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (code <span style="color:#f92672">&amp;&amp;</span> (errno <span style="color:#f92672">!=</span> EEXIST)) {
</span></span><span style="display:flex;"><span>				log(<span style="color:#e6db74">&#34;Create dir[%s] error[%d]&#34;</span>, tmp.c_str(), errno);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> SECOND_DIR_MAX; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>				snprintf(second, <span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;%03d&#34;</span>, j);
</span></span><span style="display:flex;"><span>				string tmp2 <span style="color:#f92672">=</span> tmp <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#f92672">+</span> string(second);
</span></span><span style="display:flex;"><span>		    	code <span style="color:#f92672">=</span> File<span style="color:#f92672">::</span>mkdirNoRecursion(tmp2.c_str());
</span></span><span style="display:flex;"><span>		    	<span style="color:#66d9ef">if</span> (code <span style="color:#f92672">&amp;&amp;</span> (errno <span style="color:#f92672">!=</span> EEXIST)) {
</span></span><span style="display:flex;"><span>					log(<span style="color:#e6db74">&#34;Create dir[%s] error[%d]&#34;</span>, tmp2.c_str(), errno);
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		    	}
</span></span><span style="display:flex;"><span>				memset(second, <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			memset(first, <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>下面，我们直接来看如何处理客户端的http请求，当连接对象CHttpConn收到客户端数据后，调用OnRead方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CHttpConn<span style="color:#f92672">::</span>OnRead()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (;;)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint32_t</span> free_buf_len <span style="color:#f92672">=</span> m_in_buf.GetAllocSize()
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">-</span> m_in_buf.GetWriteOffset();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (free_buf_len <span style="color:#f92672">&lt;</span> READ_BUF_SIZE <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            m_in_buf.Extend(READ_BUF_SIZE <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> netlib_recv(m_sock_handle,
</span></span><span style="display:flex;"><span>                m_in_buf.GetBuffer() <span style="color:#f92672">+</span> m_in_buf.GetWriteOffset(),
</span></span><span style="display:flex;"><span>                READ_BUF_SIZE);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        m_in_buf.IncWriteOffset(ret);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        m_last_recv_tick <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 每次请求对应一个HTTP连接，所以读完数据后，不用在同一个连接里面准备读取下个请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> in_buf <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>) m_in_buf.GetBuffer();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> buf_len <span style="color:#f92672">=</span> m_in_buf.GetWriteOffset();
</span></span><span style="display:flex;"><span>    in_buf[buf_len] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//log(&#34;OnRead, buf_len=%u, conn_handle=%u&#34;, buf_len, m_conn_handle); // for debug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m_HttpParser.ParseHttpContent(in_buf, buf_len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (m_HttpParser.IsReadAll())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        string strUrl <span style="color:#f92672">=</span> m_HttpParser.GetUrl();
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;IP:%s access:%s&#34;</span>, m_peer_ip.c_str(), strUrl.c_str());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (strUrl.find(<span style="color:#e6db74">&#34;..&#34;</span>) <span style="color:#f92672">!=</span> strUrl.npos) {
</span></span><span style="display:flex;"><span>            Close();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        m_access_host <span style="color:#f92672">=</span> m_HttpParser.GetHost();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (m_HttpParser.GetContentLen() <span style="color:#f92672">&gt;</span> HTTP_UPLOAD_MAX)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// file is too big
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            log(<span style="color:#e6db74">&#34;content  is too big&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> url[<span style="color:#ae81ff">128</span>];
</span></span><span style="display:flex;"><span>            snprintf(url, <span style="color:#66d9ef">sizeof</span>(url), <span style="color:#e6db74">&#34;{</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">error_code</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">:1,</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">error_msg</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">: </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">上传文件过大</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">,</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">url</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">:</span><span style="color:#ae81ff">\&#34;\&#34;</span><span style="color:#e6db74">}&#34;</span>);
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;%s&#34;</span>,url);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">uint32_t</span> content_length <span style="color:#f92672">=</span> strlen(url);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> pContent[<span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span>            snprintf(pContent, <span style="color:#66d9ef">sizeof</span>(pContent), HTTP_RESPONSE_HTML, content_length,url);
</span></span><span style="display:flex;"><span>            Send(pContent, strlen(pContent));
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nContentLen <span style="color:#f92672">=</span> m_HttpParser.GetContentLen();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pContent <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(nContentLen <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                pContent <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[nContentLen];
</span></span><span style="display:flex;"><span>                memcpy(pContent, m_HttpParser.GetBodyContent(), nContentLen);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">catch</span>(...)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                log(<span style="color:#e6db74">&#34;not enough memory&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span> szResponse[HTTP_RESPONSE_500_LEN <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                snprintf(szResponse, HTTP_RESPONSE_500_LEN, <span style="color:#e6db74">&#34;%s&#34;</span>, HTTP_RESPONSE_500);
</span></span><span style="display:flex;"><span>                Send(szResponse, HTTP_RESPONSE_500_LEN);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Request_t request;
</span></span><span style="display:flex;"><span>        request.conn_handle <span style="color:#f92672">=</span> m_conn_handle;
</span></span><span style="display:flex;"><span>        request.method <span style="color:#f92672">=</span> m_HttpParser.GetMethod();;
</span></span><span style="display:flex;"><span>        request.nContentLen <span style="color:#f92672">=</span> nContentLen;
</span></span><span style="display:flex;"><span>        request.pContent <span style="color:#f92672">=</span> pContent;
</span></span><span style="display:flex;"><span>        request.strAccessHost <span style="color:#f92672">=</span> m_HttpParser.GetHost();
</span></span><span style="display:flex;"><span>        request.strContentType <span style="color:#f92672">=</span> m_HttpParser.GetContentType();
</span></span><span style="display:flex;"><span>        request.strUrl <span style="color:#f92672">=</span> m_HttpParser.GetUrl() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        CHttpTask<span style="color:#f92672">*</span> pTask <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CHttpTask(request);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(HTTP_GET <span style="color:#f92672">==</span> m_HttpParser.GetMethod())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        	g_GetThreadPool.AddTask(pTask);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        	g_PostThreadPool.AddTask(pTask);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该方法先收取数据，接着解包，然后根据客户端发送的http请求到底是get还是post方法，分别往对应的get和post任务队列中丢一个任务CHttpTask。任务队列开始处理这个任务。我们以get请求的任务为例（Post请求与此类似）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CHttpTask<span style="color:#f92672">::</span>run()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(HTTP_GET <span style="color:#f92672">==</span> m_nMethod)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        OnDownload();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(HTTP_POST <span style="color:#f92672">==</span> m_nMethod)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>       OnUpload();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pContent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(HTTP_RESPONSE_403)];
</span></span><span style="display:flex;"><span>        snprintf(pContent, strlen(HTTP_RESPONSE_403), HTTP_RESPONSE_403);
</span></span><span style="display:flex;"><span>        CHttpConn<span style="color:#f92672">::</span>AddResponsePdu(m_ConnHandle, pContent, strlen(pContent));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(m_pContent <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> [] m_pContent;
</span></span><span style="display:flex;"><span>        m_pContent <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>处理任务时，根据请求类型判断到底是客户端下载图片还是上传图片，如果是下载图片则从本机缓存的图片信息中找到该图片，并读取该图片数据，因为是聊天图片，所以一般不会很大，所以这里都是一次性读取图片字节内容，然后发出去。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span>  CHttpTask<span style="color:#f92672">::</span>OnDownload()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint32_t</span>  nFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int32_t</span> nTmpSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        string strPath;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(g_fileManager<span style="color:#f92672">-&gt;</span>getAbsPathByUrl(m_strUrl, strPath ) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            nTmpSize <span style="color:#f92672">=</span> File<span style="color:#f92672">::</span>getFileSize((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)strPath.c_str());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(nTmpSize <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span> szResponseHeader[<span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span>                size_t nPos <span style="color:#f92672">=</span> strPath.find_last_of(<span style="color:#e6db74">&#34;.&#34;</span>);
</span></span><span style="display:flex;"><span>                string strType <span style="color:#f92672">=</span> strPath.substr(nPos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, strPath.length() <span style="color:#f92672">-</span> nPos);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(strType <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;jpg&#34;</span> <span style="color:#f92672">||</span> strType <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;JPG&#34;</span> <span style="color:#f92672">||</span> strType <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;jpeg&#34;</span> <span style="color:#f92672">||</span> strType <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;JPEG&#34;</span> <span style="color:#f92672">||</span> strType <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;png&#34;</span> <span style="color:#f92672">||</span> strType <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;PNG&#34;</span> <span style="color:#f92672">||</span> strType <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;gif&#34;</span> <span style="color:#f92672">||</span> strType <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;GIF&#34;</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(szResponseHeader, <span style="color:#66d9ef">sizeof</span>(szResponseHeader), HTTP_RESPONSE_IMAGE, nTmpSize, strType.c_str());
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(szResponseHeader,<span style="color:#66d9ef">sizeof</span>(szResponseHeader), HTTP_RESPONSE_EXTEND, nTmpSize);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> nLen <span style="color:#f92672">=</span> strlen(szResponseHeader);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pContent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[nLen <span style="color:#f92672">+</span> nTmpSize];
</span></span><span style="display:flex;"><span>                memcpy(pContent, szResponseHeader, nLen);
</span></span><span style="display:flex;"><span>                g_fileManager<span style="color:#f92672">-&gt;</span>downloadFileByUrl((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)m_strUrl.c_str(), pContent <span style="color:#f92672">+</span> nLen, <span style="color:#f92672">&amp;</span>nFileSize);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> nTotalLen <span style="color:#f92672">=</span> nLen <span style="color:#f92672">+</span> nFileSize;
</span></span><span style="display:flex;"><span>                CHttpConn<span style="color:#f92672">::</span>AddResponsePdu(m_ConnHandle, pContent, nTotalLen);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> nTotalLen <span style="color:#f92672">=</span> strlen(HTTP_RESPONSE_404);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pContent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[nTotalLen];
</span></span><span style="display:flex;"><span>                snprintf(pContent, nTotalLen, HTTP_RESPONSE_404);
</span></span><span style="display:flex;"><span>                CHttpConn<span style="color:#f92672">::</span>AddResponsePdu(m_ConnHandle, pContent, nTotalLen);
</span></span><span style="display:flex;"><span>                log(<span style="color:#e6db74">&#34;File size is invalied</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        	<span style="color:#66d9ef">int</span> nTotalLen <span style="color:#f92672">=</span> strlen(HTTP_RESPONSE_500);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pContent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[nTotalLen];
</span></span><span style="display:flex;"><span>			snprintf(pContent, nTotalLen, HTTP_RESPONSE_500);
</span></span><span style="display:flex;"><span>			CHttpConn<span style="color:#f92672">::</span>AddResponsePdu(m_ConnHandle, pContent, nTotalLen);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里需要说明一下的就是FileManager::getAbsPathByUrl在获取本地文件时，用了一个锁，该锁是为了防止同一个进程同时读取同一个文件，这个锁是“建议性”的，必须自己主动检测有没有上锁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> FileManager<span style="color:#f92672">::</span>getAbsPathByUrl(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>url, string <span style="color:#f92672">&amp;</span>path) {
</span></span><span style="display:flex;"><span>	string relate;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (getRelatePathByUrl(url, relate)) {
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;Get path from url[%s] error&#34;</span>, url.c_str());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	path <span style="color:#f92672">=</span> string(m_disk) <span style="color:#f92672">+</span> relate;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>u64 File<span style="color:#f92672">::</span>open(<span style="color:#66d9ef">bool</span> directIo) {
</span></span><span style="display:flex;"><span>	assert(<span style="color:#f92672">!</span>m_opened);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> flags <span style="color:#f92672">=</span> O_RDWR;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __linux__	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	m_file <span style="color:#f92672">=</span> open64(m_path, flags);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(__FREEBSD__) || defined(__APPLE__)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	m_file <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>open(m_path, flags);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> m_file) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> errno;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __LINUX__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (directIo)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> fcntl(m_file, F_SETFL, O_DIRECT))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> errno; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">flock</span> lock;
</span></span><span style="display:flex;"><span>	lock.l_type <span style="color:#f92672">=</span> F_WRLCK;
</span></span><span style="display:flex;"><span>	lock.l_start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	lock.l_whence <span style="color:#f92672">=</span> SEEK_SET;
</span></span><span style="display:flex;"><span>	lock.l_len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(fcntl(m_file, F_SETLK, <span style="color:#f92672">&amp;</span>lock) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">::</span>close(m_file);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> errno;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_opened <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	u64 size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	u64 code <span style="color:#f92672">=</span> getSize(<span style="color:#f92672">&amp;</span>size);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (code) {
</span></span><span style="display:flex;"><span>		close();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> code;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	m_size <span style="color:#f92672">=</span> size;
</span></span><span style="display:flex;"><span>	m_directIo <span style="color:#f92672">=</span> directIo;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意上面的fcntl函数设置的flock锁。这个是linux特有的，应该学习掌握。</p>
<p>图片上传的逻辑和下载逻辑大致类似，这里就不再分析了。</p>
<p>当然，发送图片数据的包和前面的发送逻辑也是一样的，在OnWrite里面发送。发送完毕后会调用CHttpConn::OnSendComplete，在这个函数里面关闭http连接。这也就是说msfs与客户端的http连接也是短连接。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CHttpConn<span style="color:#f92672">::</span>OnSendComplete()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Close();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>关于msfs也就这么多内容了。不知道你有没有发现，在搞清楚db_proxy_server和msg_server之后，每个程序框架其实都是一样的，只不过业务逻辑稍微有一点差别。后面介绍的file_server和route_server都是一样的。我们也着重分析其业务代码。</p>
<p>好了，msfs服务就这么多啦。</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/1866caff3acc4baeb8666ea706d7ba7d/">
    <span class="title">« Prev</span>
    <br>
    <span>06 服务器端login_server源码分析</span>
  </a>
  <a class="next" href="https://haokiu.com/c5f5c9828a6f472d9768cffc2f548784/">
    <span class="title">Next »</span>
    <br>
    <span>08 服务器端file_server源码分析</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
