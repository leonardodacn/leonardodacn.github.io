<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>1s | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="1s - haokiu">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://haokiu.com/1/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="1s" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://haokiu.com/1/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="1s"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span class="active">后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://haokiu.com/">Home</a></div>
  <h1>
    1s
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>golang 常用函数
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 获取当前时间 时间戳(秒)：time.Now().Unix 日期：time.Now().Format(&#34;2006-01-02 15:04:05&#34;) 注意：参数必须是 2006-01-02 15:04:05 而不能是自定义的年月日时间 2. 字符串与int转换 i,_ := strconv.Atoi(&#34;3&#34;) a := strconv.Itoa(32) 3.结构体json序列化 chatMsg := &amp;ChatMsg{} err := json.Unmarshal([]byte(msg), chatMsg) //json转结构体 buf, _ := json.Marshal(chatMsg) //结构体转json return string(buf) 4.删除切片元素 mySlice := make([]int, 5) //创建一个初始元素个数为5的数组切片，元素初始值为0 mySlice = append(mySlice[:i], mySlice[i&#43;1:]...) //删除下标为i的元素 mySlice = append(mySlice[:0], mySlice[1:]...) //删除第1个元素 5. url encode/decode encodeUrl:= url.QueryEscape(urltest) decodeUrl,err := url.QueryUnescape(encodeUrl) 6. base64编码 encodeString := base64.StdEncoding.EncodeToString(input) decodeBytes, err := base64.StdEncoding.DecodeString(encodeString) 7. 获取字符串长度 tips := &#34;忍者&#34; len := len(tips) //len=6 len := utf8.RuneCountInString(tips) //len=2 8. SubString func SubString(str string, start int32, end int32) string { result := []rune(str) length := int32(len(result)) if start &lt; 0 || start &gt; length { return str } if end &lt; 0 || end &gt; length { return str } return string(result[start:end]) } result = SubString(result, 0, int32(len([]rune(result)))-1)//注意end参数的取值 9....</p>
  </div>
  <footer class="entry-footer"><span title='2020-10-10 10:23:10 +0000 UTC'>October 10, 2020</span></footer>
  <a class="entry-link" aria-label="post link to golang 常用函数" href="https://haokiu.com/XtwuYL/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>mybatis 增加自定义拦截器
    </h2>
  </header>
  <div class="entry-content">
    <p>MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。
拦截器 import java.text.DateFormat; import java.util.Date; import java.util.List; import java.util.Locale; import java.util.Properties; import org.apache.ibatis.executor.Executor; import org.apache.ibatis.mapping.BoundSql; import org.apache.ibatis.mapping.MappedStatement; import org.apache.ibatis.mapping.ParameterMapping; import org.apache.ibatis.plugin.Interceptor; import org.apache.ibatis.plugin.Intercepts; import org.apache.ibatis.plugin.Invocation; import org.apache.ibatis.plugin.Plugin; import org.apache.ibatis.plugin.Signature; import org.apache.ibatis.reflection.MetaObject; import org.apache.ibatis.session.Configuration; import org.apache.ibatis.session.ResultHandler; import org.apache.ibatis.session.RowBounds; import org.apache.ibatis.type.TypeHandlerRegistry; import org.slf4j.Logger; import org.slf4j.LoggerFactory; @Intercepts({ @Signature(type = Executor.class, method = &#34;update&#34;, args = { MappedStatement.class, Object.class }), @Signature(type = Executor.class, method = &#34;query&#34;, args = { MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class }) }) public class MybatisInterceptor implements Interceptor { private static final Logger log = LoggerFactory.getLogger(MybatisInterceptor.class); @Override public Object intercept(Invocation invocation) throws Throwable { MappedStatement mappedStatement = (MappedStatement) invocation....</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-27 10:59:03 +0000 UTC'>September 27, 2020</span></footer>
  <a class="entry-link" aria-label="post link to mybatis 增加自定义拦截器" href="https://haokiu.com/bGqNiH/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>搜索引擎 及 elastic search 
    </h2>
  </header>
  <div class="entry-content">
    <p>搜索引擎是对数据的检索，所以我们先从生活中的数据说起。我们生活中的数据总体分为两种：
结构化数据 非结构化数据 **结构化数据：**也称作行数据，是由二维表结构来逻辑表达和实现的数据，严格地遵循数据格式与长度规范，主要通过关系型数据库进行存储和管理。指具有固定格式或有限长度的数据，如数据库，元数据等。
**非结构化数据：**又可称为全文数据，不定长或无固定格式，不适于由数据库二维表来表现，包括所有格式的办公文档、XML、HTML、Word 文档，邮件，各类报表、图片和咅频、视频信息等。
**说明：**如果要更细致的区分的话，XML、HTML 可划分为半结构化数据。因为它们也具有自己特定的标签格式，所以既可以根据需要按结构化数据来处理，也可抽取出纯文本按非结构化数据来处理。
根据两种数据分类，搜索也相应的分为两种：
结构化数据搜索 非结构化数据搜索 **对于结构化数据，**因为它们具有特定的结构，所以我们一般都是可以通过关系型数据库（MySQL，Oracle 等）的二维表（Table）的方式存储和搜索，也可以建立索引。
对于非结构化数据，也即对全文数据的搜索主要有两种方法：
顺序扫描 全文检索 **顺序扫描：**通过文字名称也可了解到它的大概搜索方式，即按照顺序扫描的方式查询特定的关键字。
例如给你一张报纸，让你找到该报纸中“平安”的文字在哪些地方出现过。你肯定需要从头到尾把报纸阅读扫描一遍然后标记出关键字在哪些版块出现过以及它的出现位置。
这种方式无疑是最耗时的最低效的，如果报纸排版字体小，而且版块较多甚至有多份报纸，等你扫描完你的眼睛也差不多了。
**全文搜索：**对非结构化数据顺序扫描很慢，我们是否可以进行优化？把我们的非结构化数据想办法弄得有一定结构不就行了吗？
将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。
这种方式就构成了全文检索的基本思路。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之为索引。
这种方式的主要工作量在前期索引的创建，但是对于后期搜索却是快速高效的。
先说说 Lucene
通过对生活中数据的类型作了一个简短了解之后，我们知道关系型数据库的 SQL 检索是处理不了这种非结构化数据的。
这种非结构化数据的处理需要依赖全文搜索，而目前市场上开放源代码的最好全文检索引擎工具包就属于 Apache 的 Lucene了。
但是 Lucene 只是一个工具包，它不是一个完整的全文检索引擎。Lucene 的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。
目前以 Lucene 为基础建立的开源可用全文搜索引擎主要是 Solr 和 Elasticsearch。
Solr 和 Elasticsearch 都是比较成熟的全文搜索引擎，能完成的功能和性能也基本一样。
但是 ES 本身就具有分布式的特性和易安装使用的特点，而 Solr 的分布式需要借助第三方来实现，例如通过使用 ZooKeeper 来达到分布式协调管理。
不管是 Solr 还是 Elasticsearch 底层都是依赖于 Lucene，而 Lucene 能实现全文搜索主要是因为它实现了倒排索引的查询结构。
如何理解倒排索引呢？假如现有三份数据文档，文档的内容如下分别是：
Java is the best programming language. PHP is the best programming language. Javascript is the best programming language. 为了创建倒排索引，我们通过分词器将每个文档的内容域拆分成单独的词（我们称它为词条或 Term），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。
结果如下所示：
Term Doc_1 Doc_2 Doc_3 ------------------------------------- Java | X | | is | X | X | X the | X | X | X best | X | X | X programming | x | X | X language | X | X | X PHP | | X | Javascript | | | X ------------------------------------- 这种结构由文档中所有不重复词的列表构成，对于其中每个词都有一个文档列表与之关联。...</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-23 14:29:39 +0000 UTC'>September 23, 2020</span></footer>
  <a class="entry-link" aria-label="post link to 搜索引擎 及 elastic search " href="https://haokiu.com/oaXyUa/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>https 原理简介
    </h2>
  </header>
  <div class="entry-content">
    <p>HTTPS 的整个通信过程可以分为两大阶段：证书验证和数据传输阶段，数据传输阶段又可以分为非对称加密和对称加密两个阶段。具体流程按图中的序号讲解。
客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。
采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书 (当然了是要钱的，安全级别越高价格越贵)。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。
客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。
客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。
服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。
双方使用对称加密愉快地传输所有数据。</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-23 13:48:39 +0000 UTC'>September 23, 2020</span></footer>
  <a class="entry-link" aria-label="post link to https 原理简介" href="https://haokiu.com/3TSsuC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>golang 计算文件和字符串的 md5 值
    </h2>
  </header>
  <div class="entry-content">
    <p>go MD5 所需要的包在”crypto/md5”包中，需要先实例化一个MD5对象，然后在此基础上调用sum方法即可
文件的MD5 md5 := md5.New() io.Copy(md5,file) MD5Str := hex.EncodeToString(md5.Sum(nil)) 上面的代码实现了计算了文件MD5，其中file是multipart.File类型的，也可以是其他的已打开的其他文件类型。 当然也可以不使用io.copy，而是直接使用sum函数来计算：
md5 := md5.New() MD5Str := hex.EncodeToString(md5.Sum(file)) 这样是直接调用了sum函数来计算文件的值可能要比io.copy稍微慢一些。
字符串的MD5 有时候需要将已知的一段字符串加密，其实和文件加密大概是类似的，只需要调用write方法将字符串写入hash中：
md5 := md5.New() md5.Write([]byte(&#34;hello,world!&#34;)) MD5Str := hex.EncodeToString(md5.Sum(nil)) </p>
  </div>
  <footer class="entry-footer"><span title='2020-09-19 11:10:59 +0000 UTC'>September 19, 2020</span></footer>
  <a class="entry-link" aria-label="post link to golang 计算文件和字符串的 md5 值" href="https://haokiu.com/dpoeTs/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>S3协议
    </h2>
  </header>
  <div class="entry-content">
    <p>S3是Simple Storage Service的缩写，即简单存储服务。亚马逊的名词缩写也都遵循这个习惯，例如Elastic Compute Cloud缩写为EC2等等。
S3说的玄乎一点可以叫云存储，通俗一点就是大网盘。其概念类似于分布式文家系统，同Google的GFS应该在一个层面。
目前的阿里的oss，腾讯的cos，七牛云存储都兼容aws的S3，所以要更换这些服务商之间提供的云存储非常容易，只需要简单的修改Access Key, Secrect Key等就行。
S3的定义如下 Amazon S3 is a web service that enables you to store data in the cloud. You can then download the data or use the data with other AWS services, such as Amazon Elastic Cloud Computer (EC2).
看来除了做网盘只用，S3存储的数据还可以被其他的亚马逊高层服务直接引用，这一点比国内的简单的网盘提供商高不少，亚马逊大网盘是其整体Solution中的有机组成部分。
基本概念 1. bucket – 类比于文件系统的目录 A bucket is a Container for objects stored in Amazon S3. Every object is contained in a bucket. For example, if the object named photos/puppy.jpg is stored in the johnsmith bucket, then it is addressable using the URL http://johnsmith.s3.amazonaws.com/photos/puppy.jpg
似乎目录不能嵌套，也就是不能有子目录，官方的说法是起到namespace的作用，是访问控制的基本单位，其实丫还是个目录。
2. Object – 类比文件系统的文件 对象中带有对象名名，对象属性，对象本身最大5G，其实也还是个文件。
目前object有Versioning的属性（即对象不同历史版本的cache概念），这个是文件系统不具备的，在早期看到的S3资料中没有这一概念，应该是演进的结果，其面对的应该是有版本控制的需求的用户。
3. Keys – 类比文件名 key的样式也是URL，记住亚马逊的服务都是使用Web Service或REST方式访问的。...</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-18 15:17:51 +0000 UTC'>September 18, 2020</span></footer>
  <a class="entry-link" aria-label="post link to S3协议" href="https://haokiu.com/d0DCeH/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>golang 判断目录或文件是否存在
    </h2>
  </header>
  <div class="entry-content">
    <p>golang 判断目录或文件是否存在：
func Exist(path string) bool { _, err := os.Stat(path) return err == nil || os.IsExist(err) } </p>
  </div>
  <footer class="entry-footer"><span title='2020-09-17 15:05:46 +0000 UTC'>September 17, 2020</span></footer>
  <a class="entry-link" aria-label="post link to golang 判断目录或文件是否存在" href="https://haokiu.com/Cd6WaZ/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>beego bee 工具使用简介
    </h2>
  </header>
  <div class="entry-content">
    <p>bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。
bee 工具的安装 您可以通过如下的方式安装 bee 工具：
go get github.com/beego/bee 安装完之后，bee 可执行文件默认存放在 $GOPATH/bin 里面，所以您需要把 $GOPATH/bin 添加到您的环境变量中，才可以进行下一步。
如何添加环境变量，请自行搜索 如果你本机设置了 GOBIN，那么上面的命令就会安装到 GOBIN 下，请添加 GOBIN 到你的环境变量中
bee 工具命令详解 我们在命令行输入 bee，可以看到如下的信息：
Bee is a Fast and Flexible tool for managing your Beego Web Application. Usage: bee command [arguments] The commands are: version show the bee &amp; beego version migrate run database migrations api create an api application base on beego framework bale packs non-Go files to Go source files new create an application base on beego framework run run the app which can hot compile pack compress an beego project fix Fixes your application by making it compatible with newer versions of Beego dlv Start a debugging session using Delve dockerize Generates a Dockerfile for your Beego application generate Source code generator hprose Creates an RPC application based on Hprose and Beego frameworks pack Compresses a Beego application into a single file rs Run customized scripts run Run the application by starting a local development server server serving static content over HTTP on port Use bee help [command] for more information about a command....</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-16 16:06:47 +0000 UTC'>September 16, 2020</span></footer>
  <a class="entry-link" aria-label="post link to beego bee 工具使用简介" href="https://haokiu.com/xVaucl/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>beego 日志配置
    </h2>
  </header>
  <div class="entry-content">
    <p>beego logs 的设计思路来自于 database/sql，目前支持的引擎有 file、console、net、smtp，可以通过如下方式进行安装：
go get github.com/astaxie/beego/logs 如何使用 通用方式 首先引入包：
import ( &#34;github.com/astaxie/beego/logs&#34; ) 然后添加输出引擎（log 支持同时输出到多个引擎），这里我们以 console 为例，第一个参数是引擎名（包括：console、file、conn、smtp、es、multifile）
logs.SetLogger(&#34;console&#34;) 添加输出引擎也支持第二个参数,用来表示配置信息，详细的配置请看下面介绍：
logs.SetLogger(logs.AdapterFile,`{&#34;filename&#34;:&#34;project.log&#34;,&#34;level&#34;:7,&#34;maxlines&#34;:0,&#34;maxsize&#34;:0,&#34;daily&#34;:true,&#34;maxdays&#34;:10,&#34;color&#34;:true}`) 然后我们就可以在我们的逻辑中开始任意的使用了：
package main import ( &#34;github.com/astaxie/beego/logs&#34; ) func main() { //an official log.Logger l := logs.GetLogger() l.Println(&#34;this is a message of http&#34;) //an official log.Logger with prefix ORM logs.GetLogger(&#34;ORM&#34;).Println(&#34;this is a message of orm&#34;) logs.Debug(&#34;my book is bought in the year of &#34;, 2016) logs.Info(&#34;this %s cat is %v years old&#34;, &#34;yellow&#34;, 3) logs.Warn(&#34;json is a type of kv like&#34;, map[string]int{&#34;key&#34;: 2016}) logs.Error(1024, &#34;is a very&#34;, &#34;good game&#34;) logs.Critical(&#34;oh,crash&#34;) } 多个实例 一般推荐使用通用方式进行日志，但依然支持单独声明来使用独立的日志
package main import ( &#34;github.com/astaxie/beego/logs&#34; ) func main() { log := logs....</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-16 16:03:29 +0000 UTC'>September 16, 2020</span></footer>
  <a class="entry-link" aria-label="post link to beego 日志配置" href="https://haokiu.com/gq7FUH/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>beego 日志处理
    </h2>
  </header>
  <div class="entry-content">
    <p>beego 的日志处理是基于 logs 模块搭建的，内置了一个变量 BeeLogger，默认已经是 logs.BeeLogger 类型，初始化了 console，也就是默认输出到 console。
使用入门 一般在程序中我们使用如下的方式进行输出：
beego.Emergency(&#34;this is emergency&#34;) beego.Alert(&#34;this is alert&#34;) beego.Critical(&#34;this is critical&#34;) beego.Error(&#34;this is error&#34;) beego.Warning(&#34;this is warning&#34;) beego.Notice(&#34;this is notice&#34;) beego.Informational(&#34;this is informational&#34;) beego.Debug(&#34;this is debug&#34;) 设置输出 我们的程序往往期望把信息输出到 log 中，现在设置输出到文件很方便，如下所示：
beego.SetLogger(&#34;file&#34;, `{&#34;filename&#34;:&#34;logs/test.log&#34;}`) 更多详细的日志配置请查看 beego 日志配置
这个默认情况就会同时输出到两个地方，一个 console，一个 file，如果只想输出到文件，就需要调用删除操作：
beego.BeeLogger.DelLogger(&#34;console&#34;) 设置级别 日志的级别如上所示的代码这样分为八个级别：
LevelEmergency LevelAlert LevelCritical LevelError LevelWarning LevelNotice LevelInformational LevelDebug 级别依次降低，默认全部打印，但是一般我们在部署环境，可以通过设置级别设置日志级别：
beego.SetLevel(beego.LevelInformational) 输出文件名和行号 日志默认不输出调用的文件名和文件行号,如果你期望输出调用的文件名和文件行号,可以如下设置
beego.SetLogFuncCall(true) 开启传入参数 true, 关闭传入参数 false, 默认是关闭的.
完整示例 func internalCalculationFunc(x, y int) (result int, err error) { beego.Debug(&#34;calculating z. x:&#34;, x, &#34; y:&#34;, y) z := y switch { case x == 3: beego.Debug(&#34;x == 3&#34;) panic(&#34;Failure.&#34;) case y == 1: beego....</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-16 10:17:20 +0000 UTC'>September 16, 2020</span></footer>
  <a class="entry-link" aria-label="post link to beego 日志处理" href="https://haokiu.com/YAotkP/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://haokiu.com/1/index/19/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://haokiu.com/1/index/21/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
