<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Reactor模式 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="Reactor模式 最近一直在看游双的《高性能Linux服务器编程》一书，下载链接： http://download.csdn.net/detail/analogous_love/9673008
书上是这么介绍Reactor模式的：
按照这个思路，我写个简单的练习：
/** *@desc: 用reactor模式练习服务器程序，main.cpp *@author: zhangyl *@date: 2016.11.23 */ #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; //for htonl() and htons() #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/epoll.h&gt; #include &lt;signal.h&gt; //for signal() #include &lt;pthread.h&gt; #include &lt;semaphore.h&gt; #include &lt;list&gt; #include &lt;errno.h&gt; #include &lt;time.h&gt; #include &lt;sstream&gt; #include &lt;iomanip&gt; //for std::setw()/setfill() #include &lt;stdlib.h&gt; #define WORKER_THREAD_NUM 5 #define min(a, b) ((a &lt;= b) ? (a) : (b)) int g_epollfd = 0; bool g_bStop = false; int g_listenfd = 0; pthread_t g_acceptthreadid = 0; pthread_t g_threadid[WORKER_THREAD_NUM] = { 0 }; pthread_cond_t g_acceptcond; pthread_mutex_t g_acceptmutex; pthread_cond_t g_cond /*= PTHREAD_COND_INITIALIZER*/; pthread_mutex_t g_mutex /*= PTHREAD_MUTEX_INITIALIZER*/; pthread_mutex_t g_clientmutex; std::list&lt;int&gt; g_listClients; void prog_exit(int signo) { ::signal(SIGINT, SIG_IGN); //::signal(SIGKILL, SIG_IGN);//该信号不能被阻塞、处理或者忽略 ::signal(SIGTERM, SIG_IGN); std::cout &lt;&lt; &#34;program recv signal &#34; &lt;&lt; signo &lt;&lt; &#34; to exit.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/23cb111095cb47f3b6115efccd11086d/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Reactor模式" />
<meta property="og:description" content="Reactor模式 最近一直在看游双的《高性能Linux服务器编程》一书，下载链接： http://download.csdn.net/detail/analogous_love/9673008
书上是这么介绍Reactor模式的：
按照这个思路，我写个简单的练习：
/** *@desc: 用reactor模式练习服务器程序，main.cpp *@author: zhangyl *@date: 2016.11.23 */ #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; //for htonl() and htons() #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/epoll.h&gt; #include &lt;signal.h&gt; //for signal() #include &lt;pthread.h&gt; #include &lt;semaphore.h&gt; #include &lt;list&gt; #include &lt;errno.h&gt; #include &lt;time.h&gt; #include &lt;sstream&gt; #include &lt;iomanip&gt; //for std::setw()/setfill() #include &lt;stdlib.h&gt; #define WORKER_THREAD_NUM 5 #define min(a, b) ((a &lt;= b) ? (a) : (b)) int g_epollfd = 0; bool g_bStop = false; int g_listenfd = 0; pthread_t g_acceptthreadid = 0; pthread_t g_threadid[WORKER_THREAD_NUM] = { 0 }; pthread_cond_t g_acceptcond; pthread_mutex_t g_acceptmutex; pthread_cond_t g_cond /*= PTHREAD_COND_INITIALIZER*/; pthread_mutex_t g_mutex /*= PTHREAD_MUTEX_INITIALIZER*/; pthread_mutex_t g_clientmutex; std::list&lt;int&gt; g_listClients; void prog_exit(int signo) { ::signal(SIGINT, SIG_IGN); //::signal(SIGKILL, SIG_IGN);//该信号不能被阻塞、处理或者忽略 ::signal(SIGTERM, SIG_IGN); std::cout &lt;&lt; &#34;program recv signal &#34; &lt;&lt; signo &lt;&lt; &#34; to exit." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/23cb111095cb47f3b6115efccd11086d/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:43+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:43+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Reactor模式"/>
<meta name="twitter:description" content="Reactor模式 最近一直在看游双的《高性能Linux服务器编程》一书，下载链接： http://download.csdn.net/detail/analogous_love/9673008
书上是这么介绍Reactor模式的：
按照这个思路，我写个简单的练习：
/** *@desc: 用reactor模式练习服务器程序，main.cpp *@author: zhangyl *@date: 2016.11.23 */ #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; //for htonl() and htons() #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/epoll.h&gt; #include &lt;signal.h&gt; //for signal() #include &lt;pthread.h&gt; #include &lt;semaphore.h&gt; #include &lt;list&gt; #include &lt;errno.h&gt; #include &lt;time.h&gt; #include &lt;sstream&gt; #include &lt;iomanip&gt; //for std::setw()/setfill() #include &lt;stdlib.h&gt; #define WORKER_THREAD_NUM 5 #define min(a, b) ((a &lt;= b) ? (a) : (b)) int g_epollfd = 0; bool g_bStop = false; int g_listenfd = 0; pthread_t g_acceptthreadid = 0; pthread_t g_threadid[WORKER_THREAD_NUM] = { 0 }; pthread_cond_t g_acceptcond; pthread_mutex_t g_acceptmutex; pthread_cond_t g_cond /*= PTHREAD_COND_INITIALIZER*/; pthread_mutex_t g_mutex /*= PTHREAD_MUTEX_INITIALIZER*/; pthread_mutex_t g_clientmutex; std::list&lt;int&gt; g_listClients; void prog_exit(int signo) { ::signal(SIGINT, SIG_IGN); //::signal(SIGKILL, SIG_IGN);//该信号不能被阻塞、处理或者忽略 ::signal(SIGTERM, SIG_IGN); std::cout &lt;&lt; &#34;program recv signal &#34; &lt;&lt; signo &lt;&lt; &#34; to exit."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Reactor模式",
      "item": "https://haokiu.com/23cb111095cb47f3b6115efccd11086d/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reactor模式",
  "name": "Reactor模式",
  "description": "Reactor模式 最近一直在看游双的《高性能Linux服务器编程》一书，下载链接： http://download.csdn.net/detail/analogous_love/9673008\n书上是这么介绍Reactor模式的：\n按照这个思路，我写个简单的练习：\n/** *@desc: 用reactor模式练习服务器程序，main.cpp *@author: zhangyl *@date: 2016.11.23 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; //for htonl() and htons() #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;signal.h\u0026gt; //for signal() #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;semaphore.h\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;iomanip\u0026gt; //for std::setw()/setfill() #include \u0026lt;stdlib.h\u0026gt; #define WORKER_THREAD_NUM 5 #define min(a, b) ((a \u0026lt;= b) ? (a) : (b)) int g_epollfd = 0; bool g_bStop = false; int g_listenfd = 0; pthread_t g_acceptthreadid = 0; pthread_t g_threadid[WORKER_THREAD_NUM] = { 0 }; pthread_cond_t g_acceptcond; pthread_mutex_t g_acceptmutex; pthread_cond_t g_cond /*= PTHREAD_COND_INITIALIZER*/; pthread_mutex_t g_mutex /*= PTHREAD_MUTEX_INITIALIZER*/; pthread_mutex_t g_clientmutex; std::list\u0026lt;int\u0026gt; g_listClients; void prog_exit(int signo) { ::signal(SIGINT, SIG_IGN); //::signal(SIGKILL, SIG_IGN);//该信号不能被阻塞、处理或者忽略 ::signal(SIGTERM, SIG_IGN); std::cout \u0026lt;\u0026lt; \u0026#34;program recv signal \u0026#34; \u0026lt;\u0026lt; signo \u0026lt;\u0026lt; \u0026#34; to exit.",
  "keywords": [
    
  ],
  "articleBody": "Reactor模式 最近一直在看游双的《高性能Linux服务器编程》一书，下载链接： http://download.csdn.net/detail/analogous_love/9673008\n书上是这么介绍Reactor模式的：\n按照这个思路，我写个简单的练习：\n/** *@desc: 用reactor模式练习服务器程序，main.cpp *@author: zhangyl *@date: 2016.11.23 */ #include #include #include #include #include #include //for htonl() and htons() #include #include #include #include //for signal() #include #include #include #include #include #include #include //for std::setw()/setfill() #include #define WORKER_THREAD_NUM 5 #define min(a, b) ((a \u003c= b) ? (a) : (b)) int g_epollfd = 0; bool g_bStop = false; int g_listenfd = 0; pthread_t g_acceptthreadid = 0; pthread_t g_threadid[WORKER_THREAD_NUM] = { 0 }; pthread_cond_t g_acceptcond; pthread_mutex_t g_acceptmutex; pthread_cond_t g_cond /*= PTHREAD_COND_INITIALIZER*/; pthread_mutex_t g_mutex /*= PTHREAD_MUTEX_INITIALIZER*/; pthread_mutex_t g_clientmutex; std::list g_listClients; void prog_exit(int signo) { ::signal(SIGINT, SIG_IGN); //::signal(SIGKILL, SIG_IGN);//该信号不能被阻塞、处理或者忽略 ::signal(SIGTERM, SIG_IGN); std::cout \u003c\u003c \"program recv signal \" \u003c\u003c signo \u003c\u003c \" to exit.\" \u003c\u003c std::endl; g_bStop = true; ::epoll_ctl(g_epollfd, EPOLL_CTL_DEL, g_listenfd, NULL); //TODO: 是否需要先调用shutdown()一下？ ::shutdown(g_listenfd, SHUT_RDWR); ::close(g_listenfd); ::close(g_epollfd); ::pthread_cond_destroy(\u0026g_acceptcond); ::pthread_mutex_destroy(\u0026g_acceptmutex); ::pthread_cond_destroy(\u0026g_cond); ::pthread_mutex_destroy(\u0026g_mutex); ::pthread_mutex_destroy(\u0026g_clientmutex); } bool create_server_listener(const char* ip, short port) { g_listenfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0); if (g_listenfd == -1) return false; int on = 1; ::setsockopt(g_listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)\u0026on, sizeof(on)); ::setsockopt(g_listenfd, SOL_SOCKET, SO_REUSEPORT, (char *)\u0026on, sizeof(on)); struct sockaddr_in servaddr; memset(\u0026servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr(ip); servaddr.sin_port = htons(port); if (::bind(g_listenfd, (sockaddr *)\u0026servaddr, sizeof(servaddr)) == -1) return false; if (::listen(g_listenfd, 50) == -1) return false; g_epollfd = ::epoll_create(1); if (g_epollfd == -1) return false; struct epoll_event e; memset(\u0026e, 0, sizeof(e)); e.events = EPOLLIN | EPOLLRDHUP; e.data.fd = g_listenfd; if (::epoll_ctl(g_epollfd, EPOLL_CTL_ADD, g_listenfd, \u0026e) == -1) return false; return true; } void release_client(int clientfd) { if (::epoll_ctl(g_epollfd, EPOLL_CTL_DEL, clientfd, NULL) == -1) std::cout \u003c\u003c \"release client socket failed as call epoll_ctl failed\" \u003c\u003c std::endl; ::close(clientfd); } void* accept_thread_func(void* arg) { while (!g_bStop) { ::pthread_mutex_lock(\u0026g_acceptmutex); ::pthread_cond_wait(\u0026g_acceptcond, \u0026g_acceptmutex); //::pthread_mutex_lock(\u0026g_acceptmutex); //std::cout \u003c\u003c \"run loop in accept_thread_func\" \u003c\u003c std::endl; struct sockaddr_in clientaddr; socklen_t addrlen; int newfd = ::accept(g_listenfd, (struct sockaddr *)\u0026clientaddr, \u0026addrlen); ::pthread_mutex_unlock(\u0026g_acceptmutex); if (newfd == -1) continue; std::cout \u003c\u003c \"new client connected: \" \u003c\u003c ::inet_ntoa(clientaddr.sin_addr) \u003c\u003c \":\" \u003c\u003c ::ntohs(clientaddr.sin_port) \u003c\u003c std::endl; //将新socket设置为non-blocking int oldflag = ::fcntl(newfd, F_GETFL, 0); int newflag = oldflag | O_NONBLOCK; if (::fcntl(newfd, F_SETFL, newflag) == -1) { std::cout \u003c\u003c \"fcntl error, oldflag =\" \u003c\u003c oldflag \u003c\u003c \", newflag = \" \u003c\u003c newflag \u003c\u003c std::endl; continue; } struct epoll_event e; memset(\u0026e, 0, sizeof(e)); e.events = EPOLLIN | EPOLLRDHUP | EPOLLET; e.data.fd = newfd; if (::epoll_ctl(g_epollfd, EPOLL_CTL_ADD, newfd, \u0026e) == -1) { std::cout \u003c\u003c \"epoll_ctl error, fd =\" \u003c\u003c newfd \u003c\u003c std::endl; } } return NULL; } void* worker_thread_func(void* arg) { while (!g_bStop) { int clientfd; ::pthread_mutex_lock(\u0026g_clientmutex); while (g_listClients.empty()) ::pthread_cond_wait(\u0026g_cond, \u0026g_clientmutex); clientfd = g_listClients.front(); g_listClients.pop_front(); pthread_mutex_unlock(\u0026g_clientmutex); //gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来 std::cout \u003c\u003c std::endl; std::string strclientmsg; char buff[256]; bool bError = false; while (true) { memset(buff, 0, sizeof(buff)); int nRecv = ::recv(clientfd, buff, 256, 0); if (nRecv == -1) { if (errno == EWOULDBLOCK) break; else { std::cout \u003c\u003c \"recv error, client disconnected, fd = \" \u003c\u003c clientfd \u003c\u003c std::endl; release_client(clientfd); bError = true; break; } } //对端关闭了socket，这端也关闭。 else if (nRecv == 0) { std::cout \u003c\u003c \"peer closed, client disconnected, fd = \" \u003c\u003c clientfd \u003c\u003c std::endl; release_client(clientfd); bError = true; break; } strclientmsg += buff; } //出错了，就不要再继续往下执行了 if (bError) continue; std::cout \u003c\u003c \"client msg: \" \u003c\u003c strclientmsg; //将消息加上时间标签后发回 time_t now = time(NULL); struct tm* nowstr = localtime(\u0026now); std::ostringstream ostimestr; ostimestr \u003c\u003c \"[\" \u003c\u003c nowstr-\u003etm_year + 1900 \u003c\u003c \"-\" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_mon + 1 \u003c\u003c \"-\" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_mday \u003c\u003c \" \" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_hour \u003c\u003c \":\" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_min \u003c\u003c \":\" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_sec \u003c\u003c \"]server reply: \"; strclientmsg.insert(0, ostimestr.str()); while (true) { int nSent = ::send(clientfd, strclientmsg.c_str(), strclientmsg.length(), 0); if (nSent == -1) { if (errno == EWOULDBLOCK) { ::sleep(10); continue; } else { std::cout \u003c\u003c \"send error, fd = \" \u003c\u003c clientfd \u003c\u003c std::endl; release_client(clientfd); break; } } std::cout \u003c\u003c \"send: \" \u003c\u003c strclientmsg; strclientmsg.erase(0, nSent); if (strclientmsg.empty()) break; } } return NULL; } void daemon_run() { int pid; signal(SIGCHLD, SIG_IGN); //1）在父进程中，fork返回新创建子进程的进程ID； //2）在子进程中，fork返回0； //3）如果出现错误，fork返回一个负值； pid = fork(); if (pid \u003c 0) { std:: cout \u003c\u003c \"fork error\" \u003c\u003c std::endl; exit(-1); } //父进程退出，子进程独立运行 else if (pid \u003e 0) { exit(0); } //之前parent和child运行在同一个session里,parent是会话（session）的领头进程, //parent进程作为会话的领头进程，如果exit结束执行的话，那么子进程会成为孤儿进程，并被init收养。 //执行setsid()之后,child将重新获得一个新的会话(session)id。 //这时parent退出之后,将不会影响到child了。 setsid(); int fd; fd = open(\"/dev/null\", O_RDWR, 0); if (fd != -1) { dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); } if (fd \u003e 2) close(fd); } int main(int argc, char* argv[]) { short port = 0; int ch; bool bdaemon = false; while ((ch = getopt(argc, argv, \"p:d\")) != -1) { switch (ch) { case 'd': bdaemon = true; break; case 'p': port = atol(optarg); break; } } if (bdaemon) daemon_run(); if (port == 0) port = 12345; if (!create_server_listener(\"0.0.0.0\", port)) { std::cout \u003c\u003c \"Unable to create listen server: ip=0.0.0.0, port=\" \u003c\u003c port \u003c\u003c \".\" \u003c\u003c std::endl; return -1; } //设置信号处理 signal(SIGCHLD, SIG_DFL); signal(SIGPIPE, SIG_IGN); signal(SIGINT, prog_exit); //signal(SIGKILL, prog_exit);//该信号不能被阻塞、处理或者忽略 signal(SIGTERM, prog_exit); ::pthread_cond_init(\u0026g_acceptcond, NULL); ::pthread_mutex_init(\u0026g_acceptmutex, NULL); ::pthread_cond_init(\u0026g_cond, NULL); ::pthread_mutex_init(\u0026g_mutex, NULL); ::pthread_mutex_init(\u0026g_clientmutex, NULL); ::pthread_create(\u0026g_acceptthreadid, NULL, accept_thread_func, NULL); //启动工作线程 for (int i = 0; i \u003c WORKER_THREAD_NUM; ++i) { ::pthread_create(\u0026g_threadid[i], NULL, worker_thread_func, NULL); } while (!g_bStop) { struct epoll_event ev[1024]; int n = ::epoll_wait(g_epollfd, ev, 1024, 10); if (n == 0) continue; else if (n \u003c 0) { std::cout \u003c\u003c \"epoll_wait error\" \u003c\u003c std::endl; continue; } int m = min(n, 1024); for (int i = 0; i \u003c m; ++i) { //通知接收连接线程接收新连接 if (ev[i].data.fd == g_listenfd) pthread_cond_signal(\u0026g_acceptcond); //通知普通工作线程接收数据 else { pthread_mutex_lock(\u0026g_clientmutex); g_listClients.push_back(ev[i].data.fd); pthread_mutex_unlock(\u0026g_clientmutex); pthread_cond_signal(\u0026g_cond); //std::cout \u003c\u003c \"signal\" \u003c\u003c std::endl; } } } return 0; } 程序的功能一个简单的echo服务：客户端连接上服务器之后，给服务器发送信息，服务器加上时间戳等信息后返回给客户端。\n使用到的知识点有：\n条件变量\nepoll的边缘触发模式\n程序的大致框架是：\n主线程只负责监听侦听socket上是否有新连接，如果有新连接到来，交给一个叫accept的工作线程去接收新连接，并将新连接socket绑定到主线程使用epollfd上去。 主线程如果侦听到客户端的socket上有可读事件，则通知另外五个工作线程去接收处理客户端发来的数据，并将数据加上时间戳后发回给客户端。 可以通过传递-p port来设置程序的监听端口号；可以通过传递-d来使程序以daemon模式运行在后台。这也是标准linux daemon模式的书写方法。 程序难点和需要注意的地方是：\n条件变量为了防止虚假唤醒，一定要在一个循环里面调用pthread_cond_wait()函数，我在worker_thread_func()中使用了： while (g_listClients.empty()) ::pthread_cond_wait(\u0026g_cond, \u0026g_clientmutex); 在accept_thread_func()函数里面我没有使用循环，这样会有问题吗？\n使用条件变量pthread_cond_wait()函数的时候一定要先获得与该条件变量相关的mutex，即像下面这样的结构： mutex_lock(...); while (condition is true) ::pthread_cond_wait(...); //这里可以有其他代码... mutex_unlock(...); //这里可以有其他代码... 因为pthread_cond_wait()如果阻塞的话，它解锁相关mutex和阻塞当前线程这两个动作加在一起是原子的。\n作为服务器端程序最好对侦听socket调用setsocketopt()设置SO_REUSEADDR和SO_REUSEPORT两个标志，因为服务程序有时候会需要重启（比如调试的时候就会不断重启），如果不设置这两个标志的话，绑定端口时就会调用失败。因为一个端口使用后，即使不再使用，因为四次挥手该端口处于TIME_WAIT状态，有大约2min的MSL（Maximum Segment Lifetime，最大存活期）。这2min内，该端口是不能被重复使用的。你的服务器程序上次使用了这个端口号，接着重启，因为这个缘故，你再次绑定这个端口就会失败（bind函数调用失败）。要不你就每次重启时需要等待2min后再试（这在频繁重启程序调试是难以接收的），或者设置这种SO_REUSEADDR和SO_REUSEPORT立即回收端口使用。 其实，SO_REUSEADDR在Windows上和Unix平台上还有些细微的区别，我在libevent源码中看到这样的描述：\nint evutil_make_listen_socket_reuseable(evutil_socket_t sock) { #ifndef WIN32 int one = 1; /* REUSEADDR on Unix means, \"don't hang on to this address after the * listener is closed.\" On Windows, though, it means \"don't keep other * processes from binding to this address while we're using it. */ return setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void*) \u0026one, (ev_socklen_t)sizeof(one)); #else return 0; #endif } 注意注释部分，在Unix平台上设置这个选项意味着，任意进程可以复用该地址；而在windows，不要阻止其他进程复用该地址。也就是在在Unix平台上，如果不设置这个选项，任意进程在一定时间内，不能bind该地址；在windows平台上，在一定时间内，其他进程不能bind该地址，而本进程却可以再次bind该地址。\nepoll_wait对新连接socket使用的是边缘触发模式EPOLLET（edge trigger），而不是默认的水平触发模式（level trigger)。因为如果采取水平触发模式的话，主线程检测到某个客户端socket数据可读时，通知工作线程去收取该socket上的数据，这个时候主线程继续循环，只要在工作线程没有将该socket上数据全部收完，或者在工作线程收取数据的过程中，客户端有新数据到来，主线程会继续发通知（通过pthread_cond_signal()）函数，再次通知工作线程收取数据。这样会可能导致多个工作线程同时调用recv函数收取该客户端socket上的数据，这样产生的结果将会导致数据错乱。 相反，采取边缘触发模式，只有等某个工作线程将那个客户端socket上数据全部收取完毕，主线程的epoll_wait才可能会再次触发来通知工作线程继续收取那个客户端socket新来的数据。\n代码中有这样一行：\n//gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来 std::cout \u003c\u003c std::endl; 如果不加上这一行，正常运行服务器程序，程序中要打印到控制台的信息都会打印出来，但是如果用gdb调试状态下，程序的所有输出就不显示了。我不知道这是不是gdb的一个bug，所以这里加上std::endl来输出一个换行符并flush标准输出，让输出显示出来。（std::endl不仅是输出一个换行符而且是同时刷新输出，相当于fflush()函数）。\n程序我部署起来了，你可以使用linux的nc命令或自己写程序连接服务器来查看程序效果，当然也可以使用telnet命令，方法：\nLinux:\nnc 120.55.94.78 12345 或\ntelnet 120.55.94.78 12345 然后就可以给服务器自由发送数据了，服务器会给你发送的信息加上时间戳返回给你。效果如图：\n另外我将这个代码改写了成纯C++11版本，使用CMake编译，为了支持编译必须加上这-std=c++11：\nCMakeLists.txt代码如下：\ncmake_minimum_required(VERSION 2.8) PROJECT(myreactorserver) AUX_SOURCE_DIRECTORY(./ SRC_LIST) SET(EXECUTABLE_OUTPUT_PATH ./) ADD_DEFINITIONS(-g -W -Wall -Wno-deprecated -DLINUX -D_REENTRANT -D_FILE_OFFSET_BITS=64 -DAC_HAS_INFO -DAC_HAS_WARNING -DAC_HAS_ERROR -DAC_HAS_CRITICAL -DTIXML_USE_STL -DHAVE_CXX_STDHEADERS NULL -std=c++11) INCLUDE_DIRECTORIES( ./ ) LINK_DIRECTORIES( ./ ) set( main.cpp myreator.cpp ) ADD_EXECUTABLE(myreactorserver NULL) TARGET_LINK_LIBRARIES(myreactorserver pthread) myreactor.h文件内容：\n/** *@desc: myreactor头文件, myreactor.h *@author: zhangyl *@date: 2016.12.03 */ #ifndef __MYREACTOR_H__ #define __MYREACTOR_H__ #include #include #include #include #include #define WORKER_THREAD_NUM 5 class CMyReactor { public: CMyReactor(); ~CMyReactor(); bool init(const char* ip, short nport); bool uninit(); bool close_client(int clientfd); static void* main_loop(void* p); private: //no copyable CMyReactor(const CMyReactor\u0026 rhs); CMyReactor\u0026 operator = (const CMyReactor\u0026 rhs); bool create_server_listener(const char* ip, short port); static void accept_thread_proc(CMyReactor* pReatcor); static void worker_thread_proc(CMyReactor* pReatcor); private: //C11语法可以在这里初始化 int\tm_listenfd = 0; int\tm_epollfd = 0; bool\tm_bStop = false; std::shared_ptr m_acceptthread; std::shared_ptr m_workerthreads[WORKER_THREAD_NUM]; std::condition_variable\tm_acceptcond; std::mutex\tm_acceptmutex; std::condition_variable\tm_workercond ; std::mutex\tm_workermutex; std::list\tm_listClients; }; #endif //!__MYREACTOR_H__ myreactor.cpp文件内容：\n/** *@desc: myreactor实现文件, myreactor.cpp *@author: zhangyl *@date: 2016.12.03 */ #include \"myreactor.h\" #include #include #include #include #include #include //for htonl() and htons() #include #include #include #include #include #include #include //for std::setw()/setfill() #include #define min(a, b) ((a \u003c= b) ? (a) : (b)) CMyReactor::CMyReactor() { //m_listenfd = 0; //m_epollfd = 0; //m_bStop = false; } CMyReactor::~CMyReactor() { } bool CMyReactor::init(const char* ip, short nport) { if (!create_server_listener(ip, nport)) { std::cout \u003c\u003c \"Unable to bind: \" \u003c\u003c ip \u003c\u003c \":\" \u003c\u003c nport \u003c\u003c \".\" \u003c\u003c std::endl; return false; } std::cout \u003c\u003c \"main thread id = \" \u003c\u003c std::this_thread::get_id() \u003c\u003c std::endl; //启动接收新连接的线程 m_acceptthread.reset(new std::thread(CMyReactor::accept_thread_proc, this)); //启动工作线程 for (auto\u0026 t : m_workerthreads) { t.reset(new std::thread(CMyReactor::worker_thread_proc, this)); } return true; } bool CMyReactor::uninit() { m_bStop = true; m_acceptcond.notify_one(); m_workercond.notify_all(); m_acceptthread-\u003ejoin(); for (auto\u0026 t : m_workerthreads) { t-\u003ejoin(); } ::epoll_ctl(m_epollfd, EPOLL_CTL_DEL, m_listenfd, NULL); //TODO: 是否需要先调用shutdown()一下？ ::shutdown(m_listenfd, SHUT_RDWR); ::close(m_listenfd); ::close(m_epollfd); return true; } bool CMyReactor::close_client(int clientfd) { if (::epoll_ctl(m_epollfd, EPOLL_CTL_DEL, clientfd, NULL) == -1) { std::cout \u003c\u003c \"close client socket failed as call epoll_ctl failed\" \u003c\u003c std::endl; //return false; } ::close(clientfd); return true; } void* CMyReactor::main_loop(void* p) { std::cout \u003c\u003c \"main thread id = \" \u003c\u003c std::this_thread::get_id() \u003c\u003c std::endl; CMyReactor* pReatcor = static_cast(p); while (!pReatcor-\u003em_bStop) { struct epoll_event ev[1024]; int n = ::epoll_wait(pReatcor-\u003em_epollfd, ev, 1024, 10); if (n == 0) continue; else if (n \u003c 0) { std::cout \u003c\u003c \"epoll_wait error\" \u003c\u003c std::endl; continue; } int m = min(n, 1024); for (int i = 0; i \u003c m; ++i) { //通知接收连接线程接收新连接 if (ev[i].data.fd == pReatcor-\u003em_listenfd) pReatcor-\u003em_acceptcond.notify_one(); //通知普通工作线程接收数据 else { { std::unique_lock guard(pReatcor-\u003em_workermutex); pReatcor-\u003em_listClients.push_back(ev[i].data.fd); } pReatcor-\u003em_workercond.notify_one(); //std::cout \u003c\u003c \"signal\" \u003c\u003c std::endl; }// end if }// end for-loop }// end while std::cout \u003c\u003c \"main loop exit ...\" \u003c\u003c std::endl; return NULL; } void CMyReactor::accept_thread_proc(CMyReactor* pReatcor) { std::cout \u003c\u003c \"accept thread, thread id = \" \u003c\u003c std::this_thread::get_id() \u003c\u003c std::endl; while (true) { int newfd; struct sockaddr_in clientaddr; socklen_t addrlen; { std::unique_lock guard(pReatcor-\u003em_acceptmutex); pReatcor-\u003em_acceptcond.wait(guard); if (pReatcor-\u003em_bStop) break; //std::cout \u003c\u003c \"run loop in accept_thread_proc\" \u003c\u003c std::endl; newfd = ::accept(pReatcor-\u003em_listenfd, (struct sockaddr *)\u0026clientaddr, \u0026addrlen); } if (newfd == -1) continue; std::cout \u003c\u003c \"new client connected: \" \u003c\u003c ::inet_ntoa(clientaddr.sin_addr) \u003c\u003c \":\" \u003c\u003c ::ntohs(clientaddr.sin_port) \u003c\u003c std::endl; //将新socket设置为non-blocking int oldflag = ::fcntl(newfd, F_GETFL, 0); int newflag = oldflag | O_NONBLOCK; if (::fcntl(newfd, F_SETFL, newflag) == -1) { std::cout \u003c\u003c \"fcntl error, oldflag =\" \u003c\u003c oldflag \u003c\u003c \", newflag = \" \u003c\u003c newflag \u003c\u003c std::endl; continue; } struct epoll_event e; memset(\u0026e, 0, sizeof(e)); e.events = EPOLLIN | EPOLLRDHUP | EPOLLET; e.data.fd = newfd; if (::epoll_ctl(pReatcor-\u003em_epollfd, EPOLL_CTL_ADD, newfd, \u0026e) == -1) { std::cout \u003c\u003c \"epoll_ctl error, fd =\" \u003c\u003c newfd \u003c\u003c std::endl; } } std::cout \u003c\u003c \"accept thread exit ...\" \u003c\u003c std::endl; } void CMyReactor::worker_thread_proc(CMyReactor* pReatcor) { std::cout \u003c\u003c \"new worker thread, thread id = \" \u003c\u003c std::this_thread::get_id() \u003c\u003c std::endl; while (true) { int clientfd; { std::unique_lock guard(pReatcor-\u003em_workermutex); while (pReatcor-\u003em_listClients.empty()) { if (pReatcor-\u003em_bStop) { std::cout \u003c\u003c \"worker thread exit ...\" \u003c\u003c std::endl; return; } pReatcor-\u003em_workercond.wait(guard); } clientfd = pReatcor-\u003em_listClients.front(); pReatcor-\u003em_listClients.pop_front(); } //gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来 std::cout \u003c\u003c std::endl; std::string strclientmsg; char buff[256]; bool bError = false; while (true) { memset(buff, 0, sizeof(buff)); int nRecv = ::recv(clientfd, buff, 256, 0); if (nRecv == -1) { if (errno == EWOULDBLOCK) break; else { std::cout \u003c\u003c \"recv error, client disconnected, fd = \" \u003c\u003c clientfd \u003c\u003c std::endl; pReatcor-\u003eclose_client(clientfd); bError = true; break; } } //对端关闭了socket，这端也关闭。 else if (nRecv == 0) { std::cout \u003c\u003c \"peer closed, client disconnected, fd = \" \u003c\u003c clientfd \u003c\u003c std::endl; pReatcor-\u003eclose_client(clientfd); bError = true; break; } strclientmsg += buff; } //出错了，就不要再继续往下执行了 if (bError) continue; std::cout \u003c\u003c \"client msg: \" \u003c\u003c strclientmsg; //将消息加上时间标签后发回 time_t now = time(NULL); struct tm* nowstr = localtime(\u0026now); std::ostringstream ostimestr; ostimestr \u003c\u003c \"[\" \u003c\u003c nowstr-\u003etm_year + 1900 \u003c\u003c \"-\" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_mon + 1 \u003c\u003c \"-\" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_mday \u003c\u003c \" \" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_hour \u003c\u003c \":\" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_min \u003c\u003c \":\" \u003c\u003c std::setw(2) \u003c\u003c std::setfill('0') \u003c\u003c nowstr-\u003etm_sec \u003c\u003c \"]server reply: \"; strclientmsg.insert(0, ostimestr.str()); while (true) { int nSent = ::send(clientfd, strclientmsg.c_str(), strclientmsg.length(), 0); if (nSent == -1) { if (errno == EWOULDBLOCK) { std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; } else { std::cout \u003c\u003c \"send error, fd = \" \u003c\u003c clientfd \u003c\u003c std::endl; pReatcor-\u003eclose_client(clientfd); break; } } std::cout \u003c\u003c \"send: \" \u003c\u003c strclientmsg; strclientmsg.erase(0, nSent); if (strclientmsg.empty()) break; } } } bool CMyReactor::create_server_listener(const char* ip, short port) { m_listenfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0); if (m_listenfd == -1) return false; int on = 1; ::setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)\u0026on, sizeof(on)); ::setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEPORT, (char *)\u0026on, sizeof(on)); struct sockaddr_in servaddr; memset(\u0026servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr(ip); servaddr.sin_port = htons(port); if (::bind(m_listenfd, (sockaddr *)\u0026servaddr, sizeof(servaddr)) == -1) return false; if (::listen(m_listenfd, 50) == -1) return false; m_epollfd = ::epoll_create(1); if (m_epollfd == -1) return false; struct epoll_event e; memset(\u0026e, 0, sizeof(e)); e.events = EPOLLIN | EPOLLRDHUP; e.data.fd = m_listenfd; if (::epoll_ctl(m_epollfd, EPOLL_CTL_ADD, m_listenfd, \u0026e) == -1) return false; return true; } main.cpp文件内容：\n/** *@desc: 用reactor模式练习服务器程序 *@author: zhangyl *@date: 2016.12.03 */ #include #include //for signal() #include #include //for exit() #include #include #include #include \"myreactor.h\" CMyReactor g_reator; void prog_exit(int signo) { std::cout \u003c\u003c \"program recv signal \" \u003c\u003c signo \u003c\u003c \" to exit.\" \u003c\u003c std::endl; g_reator.uninit(); } void daemon_run() { int pid; signal(SIGCHLD, SIG_IGN); //1）在父进程中，fork返回新创建子进程的进程ID； //2）在子进程中，fork返回0； //3）如果出现错误，fork返回一个负值； pid = fork(); if (pid \u003c 0) { std:: cout \u003c\u003c \"fork error\" \u003c\u003c std::endl; exit(-1); } //父进程退出，子进程独立运行 else if (pid \u003e 0) { exit(0); } //之前parent和child运行在同一个session里,parent是会话（session）的领头进程, //parent进程作为会话的领头进程，如果exit结束执行的话，那么子进程会成为孤儿进程，并被init收养。 //执行setsid()之后,child将重新获得一个新的会话(session)id。 //这时parent退出之后,将不会影响到child了。 setsid(); int fd; fd = open(\"/dev/null\", O_RDWR, 0); if (fd != -1) { dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); } if (fd \u003e 2) close(fd); } int main(int argc, char* argv[]) { //设置信号处理 signal(SIGCHLD, SIG_DFL); signal(SIGPIPE, SIG_IGN); signal(SIGINT, prog_exit); signal(SIGKILL, prog_exit); signal(SIGTERM, prog_exit); short port = 0; int ch; bool bdaemon = false; while ((ch = getopt(argc, argv, \"p:d\")) != -1) { switch (ch) { case 'd': bdaemon = true; break; case 'p': port = atol(optarg); break; } } if (bdaemon) daemon_run(); if (port == 0) port = 12345; if (!g_reator.init(\"0.0.0.0\", 12345)) return -1; g_reator.main_loop(\u0026g_reator); return 0; } 完整实例代码下载地址：\n普通版本：https://pan.baidu.com/s/1o82Mkno\nC++11版本：https://pan.baidu.com/s/1dEJdrih\n",
  "wordCount" : "2167",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:43Z",
  "dateModified": "2021-01-11T09:20:43Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/23cb111095cb47f3b6115efccd11086d/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      Reactor模式
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:43 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#reactor%e6%a8%a1%e5%bc%8f" aria-label="Reactor模式">Reactor模式</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="reactor模式">Reactor模式</h2>
<p>最近一直在看游双的《高性能Linux服务器编程》一书，下载链接： <a href="http://download.csdn.net/detail/analogous_love/9673008">http://download.csdn.net/detail/analogous_love/9673008</a></p>
<p>书上是这么介绍Reactor模式的：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/56183677f2cb237e32d76d96a5701a21.jpg" alt=""  />
</p>
<p>按照这个思路，我写个简单的练习：</p>
<pre tabindex="0"><code>/** 
 *@desc:   用reactor模式练习服务器程序，main.cpp
 *@author: zhangyl
 *@date:   2016.11.23
 */
 
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;  //for htonl() and htons()
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;signal.h&gt;     //for signal()
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;list&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt; //for std::setw()/setfill()
#include &lt;stdlib.h&gt;
 
 
#define WORKER_THREAD_NUM   5
 
#define min(a, b) ((a &lt;= b) ? (a) : (b)) 
 
int g_epollfd = 0;
bool g_bStop = false;
int g_listenfd = 0;
pthread_t g_acceptthreadid = 0;
pthread_t g_threadid[WORKER_THREAD_NUM] = { 0 };
pthread_cond_t g_acceptcond;
pthread_mutex_t g_acceptmutex;
 
pthread_cond_t g_cond /*= PTHREAD_COND_INITIALIZER*/;
pthread_mutex_t g_mutex /*= PTHREAD_MUTEX_INITIALIZER*/;
 
pthread_mutex_t g_clientmutex;
 
std::list&lt;int&gt; g_listClients;
 
void prog_exit(int signo)
{
    ::signal(SIGINT, SIG_IGN);
    //::signal(SIGKILL, SIG_IGN);//该信号不能被阻塞、处理或者忽略
    ::signal(SIGTERM, SIG_IGN);
 
    std::cout &lt;&lt; &#34;program recv signal &#34; &lt;&lt; signo &lt;&lt; &#34; to exit.&#34; &lt;&lt; std::endl;
 
    g_bStop = true;
 
    ::epoll_ctl(g_epollfd, EPOLL_CTL_DEL, g_listenfd, NULL);
 
    //TODO: 是否需要先调用shutdown()一下？
    ::shutdown(g_listenfd, SHUT_RDWR);
    ::close(g_listenfd);
    ::close(g_epollfd);
 
    ::pthread_cond_destroy(&amp;g_acceptcond);
    ::pthread_mutex_destroy(&amp;g_acceptmutex);
    
    ::pthread_cond_destroy(&amp;g_cond);
    ::pthread_mutex_destroy(&amp;g_mutex);
 
    ::pthread_mutex_destroy(&amp;g_clientmutex);
}
 
bool create_server_listener(const char* ip, short port)
{
    g_listenfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
    if (g_listenfd == -1)
        return false;
 
    int on = 1;
    ::setsockopt(g_listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on));
    ::setsockopt(g_listenfd, SOL_SOCKET, SO_REUSEPORT, (char *)&amp;on, sizeof(on));
 
    struct sockaddr_in servaddr;
    memset(&amp;servaddr, 0, sizeof(servaddr)); 
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr(ip);
    servaddr.sin_port = htons(port);
    if (::bind(g_listenfd, (sockaddr *)&amp;servaddr, sizeof(servaddr)) == -1)
        return false;
 
    if (::listen(g_listenfd, 50) == -1)
        return false;
 
    g_epollfd = ::epoll_create(1);
    if (g_epollfd == -1)
        return false;
 
    struct epoll_event e;
    memset(&amp;e, 0, sizeof(e));
    e.events = EPOLLIN | EPOLLRDHUP;
    e.data.fd = g_listenfd;
    if (::epoll_ctl(g_epollfd, EPOLL_CTL_ADD, g_listenfd, &amp;e) == -1)
        return false;
 
    return true;
}
 
void release_client(int clientfd)
{
    if (::epoll_ctl(g_epollfd, EPOLL_CTL_DEL, clientfd, NULL) == -1)
        std::cout &lt;&lt; &#34;release client socket failed as call epoll_ctl failed&#34; &lt;&lt; std::endl;
 
    ::close(clientfd);
}
 
void* accept_thread_func(void* arg)
{   
    while (!g_bStop)
    {
        ::pthread_mutex_lock(&amp;g_acceptmutex);
        ::pthread_cond_wait(&amp;g_acceptcond, &amp;g_acceptmutex);
        //::pthread_mutex_lock(&amp;g_acceptmutex);
 
        //std::cout &lt;&lt; &#34;run loop in accept_thread_func&#34; &lt;&lt; std::endl;
 
        struct sockaddr_in clientaddr;
        socklen_t addrlen;
        int newfd = ::accept(g_listenfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen);
        ::pthread_mutex_unlock(&amp;g_acceptmutex);
        if (newfd == -1)
            continue;
 
        std::cout &lt;&lt; &#34;new client connected: &#34; &lt;&lt; ::inet_ntoa(clientaddr.sin_addr) &lt;&lt; &#34;:&#34; &lt;&lt; ::ntohs(clientaddr.sin_port) &lt;&lt; std::endl;
 
        //将新socket设置为non-blocking
        int oldflag = ::fcntl(newfd, F_GETFL, 0);
        int newflag = oldflag | O_NONBLOCK;
        if (::fcntl(newfd, F_SETFL, newflag) == -1)
        {
            std::cout &lt;&lt; &#34;fcntl error, oldflag =&#34; &lt;&lt; oldflag &lt;&lt; &#34;, newflag = &#34; &lt;&lt; newflag &lt;&lt; std::endl;
            continue;
        }
 
        struct epoll_event e;
        memset(&amp;e, 0, sizeof(e));
        e.events = EPOLLIN | EPOLLRDHUP | EPOLLET;
        e.data.fd = newfd;
        if (::epoll_ctl(g_epollfd, EPOLL_CTL_ADD, newfd, &amp;e) == -1)
        {
            std::cout &lt;&lt; &#34;epoll_ctl error, fd =&#34; &lt;&lt; newfd &lt;&lt; std::endl;
        }
    }
 
    return NULL;
}
  
void* worker_thread_func(void* arg)
{   
    while (!g_bStop)
    {
        int clientfd;
        ::pthread_mutex_lock(&amp;g_clientmutex);
        while (g_listClients.empty())
            ::pthread_cond_wait(&amp;g_cond, &amp;g_clientmutex);
        clientfd = g_listClients.front();
        g_listClients.pop_front();  
        pthread_mutex_unlock(&amp;g_clientmutex);
 
        //gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来
        std::cout &lt;&lt; std::endl;
 
        std::string strclientmsg;
        char buff[256];
        bool bError = false;
        while (true)
        {
            memset(buff, 0, sizeof(buff));
            int nRecv = ::recv(clientfd, buff, 256, 0);
            if (nRecv == -1)
            {
                if (errno == EWOULDBLOCK)
                    break;
                else
                {
                    std::cout &lt;&lt; &#34;recv error, client disconnected, fd = &#34; &lt;&lt; clientfd &lt;&lt; std::endl;
                    release_client(clientfd);
                    bError = true;
                    break;
                }
                    
            }
            //对端关闭了socket，这端也关闭。
            else if (nRecv == 0)
            {
                std::cout &lt;&lt; &#34;peer closed, client disconnected, fd = &#34; &lt;&lt; clientfd &lt;&lt; std::endl;
                release_client(clientfd);
                bError = true;
                break;
            }
 
            strclientmsg += buff;
        }
 
        //出错了，就不要再继续往下执行了
        if (bError)
            continue;
        
        std::cout &lt;&lt; &#34;client msg: &#34; &lt;&lt; strclientmsg;
 
        //将消息加上时间标签后发回
        time_t now = time(NULL);
        struct tm* nowstr = localtime(&amp;now);
        std::ostringstream ostimestr;
        ostimestr &lt;&lt; &#34;[&#34; &lt;&lt; nowstr-&gt;tm_year + 1900 &lt;&lt; &#34;-&#34; 
                  &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_mon + 1 &lt;&lt; &#34;-&#34; 
                  &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_mday &lt;&lt; &#34; &#34;
                  &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_hour &lt;&lt; &#34;:&#34; 
                  &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_min &lt;&lt; &#34;:&#34; 
                  &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_sec &lt;&lt; &#34;]server reply: &#34;;
 
        strclientmsg.insert(0, ostimestr.str());
        
        while (true)
        {
            int nSent = ::send(clientfd, strclientmsg.c_str(), strclientmsg.length(), 0);
            if (nSent == -1)
            {
                if (errno == EWOULDBLOCK)
                {
                    ::sleep(10);
                    continue;
                }
                else
                {
                    std::cout &lt;&lt; &#34;send error, fd = &#34; &lt;&lt; clientfd &lt;&lt; std::endl;
                    release_client(clientfd);
                    break;
                }
                   
            }          
 
            std::cout &lt;&lt; &#34;send: &#34; &lt;&lt; strclientmsg;
            strclientmsg.erase(0, nSent);
 
            if (strclientmsg.empty())
                break;
        }
    }
 
    return NULL;
}
 
void daemon_run()
{
    int pid;
    signal(SIGCHLD, SIG_IGN);
    //1）在父进程中，fork返回新创建子进程的进程ID；
    //2）在子进程中，fork返回0；
    //3）如果出现错误，fork返回一个负值；
    pid = fork();
    if (pid &lt; 0)
    {
        std:: cout &lt;&lt; &#34;fork error&#34; &lt;&lt; std::endl;
        exit(-1);
    }
    //父进程退出，子进程独立运行
    else if (pid &gt; 0) {
        exit(0);
    }
    //之前parent和child运行在同一个session里,parent是会话（session）的领头进程,
    //parent进程作为会话的领头进程，如果exit结束执行的话，那么子进程会成为孤儿进程，并被init收养。
    //执行setsid()之后,child将重新获得一个新的会话(session)id。
    //这时parent退出之后,将不会影响到child了。
    setsid();
    int fd;
    fd = open(&#34;/dev/null&#34;, O_RDWR, 0);
    if (fd != -1)
    {
        dup2(fd, STDIN_FILENO);
        dup2(fd, STDOUT_FILENO);
        dup2(fd, STDERR_FILENO);
    }
    if (fd &gt; 2)
        close(fd);
 
}
 
 
int main(int argc, char* argv[])
{  
    short port = 0;
    int ch;
    bool bdaemon = false;
    while ((ch = getopt(argc, argv, &#34;p:d&#34;)) != -1)
    {
        switch (ch)
        {
        case &#39;d&#39;:
            bdaemon = true;
            break;
        case &#39;p&#39;:
            port = atol(optarg);
            break;
        }
    }
 
    if (bdaemon)
        daemon_run();
 
 
    if (port == 0)
        port = 12345;
     
    if (!create_server_listener(&#34;0.0.0.0&#34;, port))
    {
        std::cout &lt;&lt; &#34;Unable to create listen server: ip=0.0.0.0, port=&#34; &lt;&lt; port &lt;&lt; &#34;.&#34; &lt;&lt; std::endl;
        return -1;
    }
 
    
    //设置信号处理
    signal(SIGCHLD, SIG_DFL);
    signal(SIGPIPE, SIG_IGN);
    signal(SIGINT, prog_exit);
    //signal(SIGKILL, prog_exit);//该信号不能被阻塞、处理或者忽略
 
    signal(SIGTERM, prog_exit);
 
    ::pthread_cond_init(&amp;g_acceptcond, NULL);
    ::pthread_mutex_init(&amp;g_acceptmutex, NULL);
 
    ::pthread_cond_init(&amp;g_cond, NULL);
    ::pthread_mutex_init(&amp;g_mutex, NULL);
 
    ::pthread_mutex_init(&amp;g_clientmutex, NULL);
     
    ::pthread_create(&amp;g_acceptthreadid, NULL, accept_thread_func, NULL);
    //启动工作线程
    for (int i = 0; i &lt; WORKER_THREAD_NUM; ++i)
    {
        ::pthread_create(&amp;g_threadid[i], NULL, worker_thread_func, NULL);
    }
 
    while (!g_bStop)
    {       
        struct epoll_event ev[1024];
        int n = ::epoll_wait(g_epollfd, ev, 1024, 10);
        if (n == 0)
            continue;
        else if (n &lt; 0)
        {
            std::cout &lt;&lt; &#34;epoll_wait error&#34; &lt;&lt; std::endl;
            continue;
        }
 
        int m = min(n, 1024);
        for (int i = 0; i &lt; m; ++i)
        {
            //通知接收连接线程接收新连接
            if (ev[i].data.fd == g_listenfd)
                pthread_cond_signal(&amp;g_acceptcond);
            //通知普通工作线程接收数据
            else
            {               
                pthread_mutex_lock(&amp;g_clientmutex);              
                g_listClients.push_back(ev[i].data.fd);
                pthread_mutex_unlock(&amp;g_clientmutex);
                pthread_cond_signal(&amp;g_cond);
                //std::cout &lt;&lt; &#34;signal&#34; &lt;&lt; std::endl;
            }
                
        }
 
    }
    
    return 0;
}
</code></pre><p>程序的功能一个简单的echo服务：客户端连接上服务器之后，给服务器发送信息，服务器加上时间戳等信息后返回给客户端。</p>
<p>使用到的知识点有：</p>
<ol>
<li>
<p>条件变量</p>
</li>
<li>
<p>epoll的边缘触发模式</p>
</li>
</ol>
<p>程序的大致框架是：</p>
<ol>
<li>主线程只负责监听侦听socket上是否有新连接，如果有新连接到来，交给一个叫accept的工作线程去接收新连接，并将新连接socket绑定到主线程使用epollfd上去。</li>
<li>主线程如果侦听到客户端的socket上有可读事件，则通知另外五个工作线程去接收处理客户端发来的数据，并将数据加上时间戳后发回给客户端。</li>
<li>可以通过传递-p port来设置程序的监听端口号；可以通过传递-d来使程序以daemon模式运行在后台。这也是标准linux daemon模式的书写方法。</li>
</ol>
<p>程序难点和需要注意的地方是：</p>
<ol>
<li>条件变量为了防止虚假唤醒，一定要在一个循环里面调用pthread_cond_wait()函数，我在worker_thread_func()中使用了：</li>
</ol>
<pre tabindex="0"><code>while (g_listClients.empty())  
	::pthread_cond_wait(&amp;g_cond, &amp;g_clientmutex); 
</code></pre><p>在accept_thread_func()函数里面我没有使用循环，这样会有问题吗？</p>
<ol>
<li>使用条件变量pthread_cond_wait()函数的时候一定要先获得与该条件变量相关的mutex，即像下面这样的结构：</li>
</ol>
<pre tabindex="0"><code>mutex_lock(...);
 
while (condition is true)
    ::pthread_cond_wait(...);
 
//这里可以有其他代码...
mutex_unlock(...);
 
//这里可以有其他代码...
</code></pre><p>因为pthread_cond_wait()如果阻塞的话，它解锁相关mutex和阻塞当前线程这两个动作加在一起是原子的。</p>
<ol>
<li>作为服务器端程序最好对侦听socket调用setsocketopt()设置SO_REUSEADDR和SO_REUSEPORT两个标志，因为服务程序有时候会需要重启（比如调试的时候就会不断重启），如果不设置这两个标志的话，绑定端口时就会调用失败。因为一个端口使用后，即使不再使用，因为四次挥手该端口处于TIME_WAIT状态，有大约2min的MSL（Maximum Segment Lifetime，最大存活期）。这2min内，该端口是不能被重复使用的。你的服务器程序上次使用了这个端口号，接着重启，因为这个缘故，你再次绑定这个端口就会失败（bind函数调用失败）。要不你就每次重启时需要等待2min后再试（这在频繁重启程序调试是难以接收的），或者设置这种SO_REUSEADDR和SO_REUSEPORT立即回收端口使用。</li>
</ol>
<p>其实，SO_REUSEADDR在Windows上和Unix平台上还有些细微的区别，我在libevent源码中看到这样的描述：</p>
<pre tabindex="0"><code>int evutil_make_listen_socket_reuseable(evutil_socket_t sock)
{
#ifndef WIN32
	int one = 1;
	/* REUSEADDR on Unix means, &#34;don&#39;t hang on to this address after the
	 * listener is closed.&#34;  On Windows, though, it means &#34;don&#39;t keep other
	 * processes from binding to this address while we&#39;re using it. */
	return setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one,
	    (ev_socklen_t)sizeof(one));
#else
	return 0;
#endif
} 
</code></pre><p>注意注释部分，在Unix平台上设置这个选项意味着，任意进程可以复用该地址；而在windows，不要阻止其他进程复用该地址。也就是在在Unix平台上，如果不设置这个选项，任意进程在一定时间内，不能bind该地址；在windows平台上，在一定时间内，其他进程不能bind该地址，而本进程却可以再次bind该地址。</p>
<ol>
<li>epoll_wait对新连接socket使用的是边缘触发模式EPOLLET（edge trigger），而不是默认的水平触发模式（level trigger)。因为如果采取水平触发模式的话，主线程检测到某个客户端socket数据可读时，通知工作线程去收取该socket上的数据，这个时候主线程继续循环，只要在工作线程没有将该socket上数据全部收完，或者在工作线程收取数据的过程中，客户端有新数据到来，主线程会继续发通知（通过pthread_cond_signal()）函数，再次通知工作线程收取数据。这样会可能导致多个工作线程同时调用recv函数收取该客户端socket上的数据，这样产生的结果将会导致数据错乱。</li>
</ol>
<p>相反，采取边缘触发模式，只有等某个工作线程将那个客户端socket上数据全部收取完毕，主线程的epoll_wait才可能会再次触发来通知工作线程继续收取那个客户端socket新来的数据。</p>
<ol>
<li>
<p>代码中有这样一行：</p>
<pre tabindex="0"><code>//gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来 
std::cout &lt;&lt; std::endl;
</code></pre></li>
</ol>
<p>如果不加上这一行，正常运行服务器程序，程序中要打印到控制台的信息都会打印出来，但是如果用gdb调试状态下，程序的所有输出就不显示了。我不知道这是不是gdb的一个bug，所以这里加上std::endl来输出一个换行符并flush标准输出，让输出显示出来。（std::endl不仅是输出一个换行符而且是同时刷新输出，相当于fflush()函数）。</p>
<p>程序我部署起来了，你可以使用linux的nc命令或自己写程序连接服务器来查看程序效果，当然也可以使用telnet命令，方法：</p>
<p>Linux:</p>
<pre tabindex="0"><code>nc 120.55.94.78 12345
</code></pre><p>或</p>
<pre tabindex="0"><code>telnet 120.55.94.78 12345
</code></pre><p>然后就可以给服务器自由发送数据了，服务器会给你发送的信息加上时间戳返回给你。效果如图：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/3011692d1a77bab933adeb451919d52a.jpg" alt=""  />
</p>
<p>另外我将这个代码改写了成纯C++11版本，使用CMake编译，为了支持编译必须加上这-std=c++11：</p>
<p>CMakeLists.txt代码如下：</p>
<pre tabindex="0"><code>cmake_minimum_required(VERSION 2.8)
 
PROJECT(myreactorserver)
 
AUX_SOURCE_DIRECTORY(./ SRC_LIST)
SET(EXECUTABLE_OUTPUT_PATH ./)
 
ADD_DEFINITIONS(-g -W -Wall -Wno-deprecated -DLINUX -D_REENTRANT -D_FILE_OFFSET_BITS=64 -DAC_HAS_INFO -DAC_HAS_WARNING -DAC_HAS_ERROR -DAC_HAS_CRITICAL -DTIXML_USE_STL -DHAVE_CXX_STDHEADERS NULL -std=c++11)
 
INCLUDE_DIRECTORIES(
./
)
LINK_DIRECTORIES(
./
)
 
set(
main.cpp
myreator.cpp
)
 
ADD_EXECUTABLE(myreactorserver NULL)
 
TARGET_LINK_LIBRARIES(myreactorserver pthread)
</code></pre><p>myreactor.h文件内容：</p>
<pre tabindex="0"><code>/**
 *@desc: myreactor头文件, myreactor.h
 *@author: zhangyl
 *@date: 2016.12.03
 */
#ifndef __MYREACTOR_H__
#define __MYREACTOR_H__
 
#include &lt;list&gt;
#include &lt;memory&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
 
#define WORKER_THREAD_NUM   5
 
class CMyReactor
{
public:
	CMyReactor();
	~CMyReactor();
 
	bool init(const char* ip, short nport);
	bool uninit();
 
	bool close_client(int clientfd);
 
	static void* main_loop(void* p);
 
private:
	//no copyable
	CMyReactor(const CMyReactor&amp; rhs);
	CMyReactor&amp; operator = (const CMyReactor&amp; rhs);
 
	bool create_server_listener(const char* ip, short port);
	
	static void accept_thread_proc(CMyReactor* pReatcor);
	static void worker_thread_proc(CMyReactor* pReatcor);
 
private:
	//C11语法可以在这里初始化
	int							 m_listenfd = 0;
	int							 m_epollfd  = 0;
	bool						 m_bStop    = false;
	
	std::shared_ptr&lt;std::thread&gt; m_acceptthread;
	std::shared_ptr&lt;std::thread&gt; m_workerthreads[WORKER_THREAD_NUM];
	
	std::condition_variable		 m_acceptcond;
	std::mutex					 m_acceptmutex;
 
	std::condition_variable		 m_workercond ;
	std::mutex					 m_workermutex;
 
	std::list&lt;int&gt;				 m_listClients;
};
 
#endif //!__MYREACTOR_H__
</code></pre><p>myreactor.cpp文件内容：</p>
<pre tabindex="0"><code>/** 
 *@desc: myreactor实现文件, myreactor.cpp
 *@author: zhangyl
 *@date: 2016.12.03
 */
#include &#34;myreactor.h&#34;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;  //for htonl() and htons()
#include &lt;fcntl.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;list&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt; //for std::setw()/setfill()
#include &lt;unistd.h&gt;
 
#define min(a, b) ((a &lt;= b) ? (a) : (b))
 
CMyReactor::CMyReactor()
{
	//m_listenfd = 0;
	//m_epollfd = 0;
	//m_bStop = false;
}
 
CMyReactor::~CMyReactor()
{
 
}
 
bool CMyReactor::init(const char* ip, short nport)
{
	if (!create_server_listener(ip, nport))
	{
		std::cout &lt;&lt; &#34;Unable to bind: &#34; &lt;&lt; ip &lt;&lt; &#34;:&#34; &lt;&lt; nport &lt;&lt; &#34;.&#34; &lt;&lt; std::endl;
		return false;
	}
 
 
	std::cout &lt;&lt; &#34;main thread id = &#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
 
	//启动接收新连接的线程
	m_acceptthread.reset(new std::thread(CMyReactor::accept_thread_proc, this));
	
	//启动工作线程
	for (auto&amp; t : m_workerthreads)
	{
		t.reset(new std::thread(CMyReactor::worker_thread_proc, this));
	}
 
 
	return true;
}
 
bool CMyReactor::uninit()
{
	m_bStop = true;
	m_acceptcond.notify_one();
	m_workercond.notify_all();
 
	m_acceptthread-&gt;join();
	for (auto&amp; t : m_workerthreads)
	{
		t-&gt;join();
	}
 
	::epoll_ctl(m_epollfd, EPOLL_CTL_DEL, m_listenfd, NULL);
 
	//TODO: 是否需要先调用shutdown()一下？
	::shutdown(m_listenfd, SHUT_RDWR);
	::close(m_listenfd);
	::close(m_epollfd);
 
	return true;
}
 
bool CMyReactor::close_client(int clientfd)
{
	if (::epoll_ctl(m_epollfd, EPOLL_CTL_DEL, clientfd, NULL) == -1)
	{
		std::cout &lt;&lt; &#34;close client socket failed as call epoll_ctl failed&#34; &lt;&lt; std::endl;
		//return false;
	}
		
 
	::close(clientfd);
 
	return true;
}
 
 
void* CMyReactor::main_loop(void* p)
{
	std::cout &lt;&lt; &#34;main thread id = &#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	
	CMyReactor* pReatcor = static_cast&lt;CMyReactor*&gt;(p);
	
	while (!pReatcor-&gt;m_bStop)
	{
		struct epoll_event ev[1024];
		int n = ::epoll_wait(pReatcor-&gt;m_epollfd, ev, 1024, 10);
		if (n == 0)
			continue;
		else if (n &lt; 0)
		{
			std::cout &lt;&lt; &#34;epoll_wait error&#34; &lt;&lt; std::endl;
			continue;
		}
 
		int m = min(n, 1024);
		for (int i = 0; i &lt; m; ++i)
		{
			//通知接收连接线程接收新连接
			if (ev[i].data.fd == pReatcor-&gt;m_listenfd)
				pReatcor-&gt;m_acceptcond.notify_one();
			//通知普通工作线程接收数据
			else
			{
				{
					std::unique_lock&lt;std::mutex&gt; guard(pReatcor-&gt;m_workermutex);
					pReatcor-&gt;m_listClients.push_back(ev[i].data.fd);
				}
								
				pReatcor-&gt;m_workercond.notify_one();
				//std::cout &lt;&lt; &#34;signal&#34; &lt;&lt; std::endl;
			}// end if
 
		}// end for-loop
	}// end while
 
	std::cout &lt;&lt; &#34;main loop exit ...&#34; &lt;&lt; std::endl;
 
	return NULL;
}
 
void CMyReactor::accept_thread_proc(CMyReactor* pReatcor)
{
	std::cout &lt;&lt; &#34;accept thread, thread id = &#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
 
	while (true)
	{
		int newfd;
		struct sockaddr_in clientaddr;
		socklen_t addrlen;
		{
			std::unique_lock&lt;std::mutex&gt; guard(pReatcor-&gt;m_acceptmutex);
			pReatcor-&gt;m_acceptcond.wait(guard);
			if (pReatcor-&gt;m_bStop)
				break;
 
			//std::cout &lt;&lt; &#34;run loop in accept_thread_proc&#34; &lt;&lt; std::endl;
			
			newfd = ::accept(pReatcor-&gt;m_listenfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen);
		}
		if (newfd == -1)
			continue;
 
		std::cout &lt;&lt; &#34;new client connected: &#34; &lt;&lt; ::inet_ntoa(clientaddr.sin_addr) &lt;&lt; &#34;:&#34; &lt;&lt; ::ntohs(clientaddr.sin_port) &lt;&lt; std::endl;
 
		//将新socket设置为non-blocking
		int oldflag = ::fcntl(newfd, F_GETFL, 0);
		int newflag = oldflag | O_NONBLOCK;
		if (::fcntl(newfd, F_SETFL, newflag) == -1)
		{
			std::cout &lt;&lt; &#34;fcntl error, oldflag =&#34; &lt;&lt; oldflag &lt;&lt; &#34;, newflag = &#34; &lt;&lt; newflag &lt;&lt; std::endl;
			continue;
		}
 
		struct epoll_event e;
		memset(&amp;e, 0, sizeof(e));
		e.events = EPOLLIN | EPOLLRDHUP | EPOLLET;
		e.data.fd = newfd;
		if (::epoll_ctl(pReatcor-&gt;m_epollfd, EPOLL_CTL_ADD, newfd, &amp;e) == -1)
		{
			std::cout &lt;&lt; &#34;epoll_ctl error, fd =&#34; &lt;&lt; newfd &lt;&lt; std::endl;
		}
	}
 
	std::cout &lt;&lt; &#34;accept thread exit ...&#34; &lt;&lt; std::endl;
}
 
void CMyReactor::worker_thread_proc(CMyReactor* pReatcor)
{
	std::cout &lt;&lt; &#34;new worker thread, thread id = &#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
 
	while (true)
	{
		int clientfd;
		{
			std::unique_lock&lt;std::mutex&gt; guard(pReatcor-&gt;m_workermutex);
			while (pReatcor-&gt;m_listClients.empty())
			{
				if (pReatcor-&gt;m_bStop)
				{
					std::cout &lt;&lt; &#34;worker thread exit ...&#34; &lt;&lt; std::endl;
					return;
				}
					
				pReatcor-&gt;m_workercond.wait(guard);
			}
				
			clientfd = pReatcor-&gt;m_listClients.front();
			pReatcor-&gt;m_listClients.pop_front();
		}
 
		//gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来
		std::cout &lt;&lt; std::endl;
 
		std::string strclientmsg;
		char buff[256];
		bool bError = false;
		while (true)
		{
			memset(buff, 0, sizeof(buff));
			int nRecv = ::recv(clientfd, buff, 256, 0);
			if (nRecv == -1)
			{
				if (errno == EWOULDBLOCK)
					break;
				else
				{
					std::cout &lt;&lt; &#34;recv error, client disconnected, fd = &#34; &lt;&lt; clientfd &lt;&lt; std::endl;
					pReatcor-&gt;close_client(clientfd);
					bError = true;
					break;
				}
 
			}
			//对端关闭了socket，这端也关闭。
			else if (nRecv == 0)
			{
				std::cout &lt;&lt; &#34;peer closed, client disconnected, fd = &#34; &lt;&lt; clientfd &lt;&lt; std::endl;
				pReatcor-&gt;close_client(clientfd);
				bError = true;
				break;
			}
 
			strclientmsg += buff;
		}
 
		//出错了，就不要再继续往下执行了
		if (bError)
			continue;
 
		std::cout &lt;&lt; &#34;client msg: &#34; &lt;&lt; strclientmsg;
 
		//将消息加上时间标签后发回
		time_t now = time(NULL);
		struct tm* nowstr = localtime(&amp;now);
		std::ostringstream ostimestr;
		ostimestr &lt;&lt; &#34;[&#34; &lt;&lt; nowstr-&gt;tm_year + 1900 &lt;&lt; &#34;-&#34;
			&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_mon + 1 &lt;&lt; &#34;-&#34;
			&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_mday &lt;&lt; &#34; &#34;
			&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_hour &lt;&lt; &#34;:&#34;
			&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_min &lt;&lt; &#34;:&#34;
			&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; nowstr-&gt;tm_sec &lt;&lt; &#34;]server reply: &#34;;
 
		strclientmsg.insert(0, ostimestr.str());
 
		while (true)
		{
			int nSent = ::send(clientfd, strclientmsg.c_str(), strclientmsg.length(), 0);
			if (nSent == -1)
			{
				if (errno == EWOULDBLOCK)
				{
					std::this_thread::sleep_for(std::chrono::milliseconds(10));
					continue;
				}
				else
				{
					std::cout &lt;&lt; &#34;send error, fd = &#34; &lt;&lt; clientfd &lt;&lt; std::endl;
					pReatcor-&gt;close_client(clientfd);
					break;
				}
 
			}
 
			std::cout &lt;&lt; &#34;send: &#34; &lt;&lt; strclientmsg;
			strclientmsg.erase(0, nSent);
 
			if (strclientmsg.empty())
				break;
		}
	}
}
 
bool CMyReactor::create_server_listener(const char* ip, short port)
{
	m_listenfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
	if (m_listenfd == -1)
		return false;
 
	int on = 1;
	::setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on));
	::setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEPORT, (char *)&amp;on, sizeof(on));
 
	struct sockaddr_in servaddr;
	memset(&amp;servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = inet_addr(ip);
	servaddr.sin_port = htons(port);
	if (::bind(m_listenfd, (sockaddr *)&amp;servaddr, sizeof(servaddr)) == -1)
		return false;
 
	if (::listen(m_listenfd, 50) == -1)
		return false;
 
	m_epollfd = ::epoll_create(1);
	if (m_epollfd == -1)
		return false;
 
	struct epoll_event e;
	memset(&amp;e, 0, sizeof(e));
	e.events = EPOLLIN | EPOLLRDHUP;
	e.data.fd = m_listenfd;
	if (::epoll_ctl(m_epollfd, EPOLL_CTL_ADD, m_listenfd, &amp;e) == -1)
		return false;
 
	return true;
}
</code></pre><p>main.cpp文件内容：</p>
<pre tabindex="0"><code>/** 
 *@desc:   用reactor模式练习服务器程序
 *@author: zhangyl
 *@date:   2016.12.03
 */
 
#include &lt;iostream&gt;
#include &lt;signal.h&gt;     //for signal()
#include&lt;unistd.h&gt;
#include &lt;stdlib.h&gt;		//for exit()
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &#34;myreactor.h&#34;
 
CMyReactor g_reator;
 
void prog_exit(int signo)
{
    std::cout &lt;&lt; &#34;program recv signal &#34; &lt;&lt; signo &lt;&lt; &#34; to exit.&#34; &lt;&lt; std::endl; 
 
	g_reator.uninit();
}
 
void daemon_run()
{
    int pid;
    signal(SIGCHLD, SIG_IGN);
    //1）在父进程中，fork返回新创建子进程的进程ID；
    //2）在子进程中，fork返回0；
    //3）如果出现错误，fork返回一个负值；
    pid = fork();
    if (pid &lt; 0)
    {
        std:: cout &lt;&lt; &#34;fork error&#34; &lt;&lt; std::endl;
        exit(-1);
    }
    //父进程退出，子进程独立运行
    else if (pid &gt; 0) {
        exit(0);
    }
    //之前parent和child运行在同一个session里,parent是会话（session）的领头进程,
    //parent进程作为会话的领头进程，如果exit结束执行的话，那么子进程会成为孤儿进程，并被init收养。
    //执行setsid()之后,child将重新获得一个新的会话(session)id。
    //这时parent退出之后,将不会影响到child了。
    setsid();
    int fd;
    fd = open(&#34;/dev/null&#34;, O_RDWR, 0);
    if (fd != -1)
    {
        dup2(fd, STDIN_FILENO);
        dup2(fd, STDOUT_FILENO);
        dup2(fd, STDERR_FILENO);
    }
    if (fd &gt; 2)
        close(fd);
}
 
 
int main(int argc, char* argv[])
{  
	//设置信号处理
	signal(SIGCHLD, SIG_DFL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGINT, prog_exit);
	signal(SIGKILL, prog_exit);
	signal(SIGTERM, prog_exit);
	
	short port = 0;
	int ch;
	bool bdaemon = false;
	while ((ch = getopt(argc, argv, &#34;p:d&#34;)) != -1)
	{
		switch (ch)
		{
		case &#39;d&#39;:
			bdaemon = true;
			break;
		case &#39;p&#39;:
			port = atol(optarg);
			break;
		}
	}
 
	if (bdaemon)
		daemon_run();
 
 
	if (port == 0)
		port = 12345;
 
	
	if (!g_reator.init(&#34;0.0.0.0&#34;, 12345))
		return -1;
    
	g_reator.main_loop(&amp;g_reator);
 
    return 0;
}
</code></pre><p>完整实例代码下载地址：</p>
<p>普通版本：https://pan.baidu.com/s/1o82Mkno</p>
<p>C++11版本：https://pan.baidu.com/s/1dEJdrih</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/bk-1/">
    <span class="title">« Prev</span>
    <br>
    <span>CppGuide</span>
  </a>
  <a class="next" href="https://haokiu.com/d7e436585f754029be5279a858049912/">
    <span class="title">Next »</span>
    <br>
    <span>业务数据处理一定要单独开线程吗</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
