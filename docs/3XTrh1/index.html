<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>elasticsearch | haokiu</title>
<meta name="keywords" content="es">
<meta name="description" content="基本概念 Node 与 Cluster Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。
单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。
Index Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。
所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。
Document Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。
Type Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。
不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。
在6.0之前的版本，一个ElasticSearch索引中，可以有多个类型；从6.0版本开始，，一个ElasticSearch索引中，只有1个类型。一个类型是索引的一个逻辑上的分类，通常具有一组相同字段的文档组成。ElasticSearch的类型概念相当于关系数据库的数据表。
shard 当数据量较大时，索引的存储空间需求超出单个节点磁盘容量的限制，或者出现单个节点处理速度较慢。为了解决这些问题，ElasticSearch将索引中的数据进行切分成多个分片（shard），每个分片存储这个索引的一部分数据，分布在不同节点上。当需要查询索引时，ElasticSearch将查询发送到每个相关分片，之后将查询结果合并，这个过程对ElasticSearch应用来说是透明的，用户感知不到分片的存在。 一个索引的分片一旦指定，不再修改。
副本 其实，分片全称是主分片，简称为分片。主分片是相对于副本来说的，副本是对主分片的一个或多个复制版本（或称拷贝），这些复制版本（拷贝）可以称为复制分片，可以直接称之为副本。当主分片丢失时，集群可以将一个副本升级为新的主分片。
对比 ElasticSearch RDBMS 索引（index） 数据库（database） 类型（type） 表（table） 文档（document） 行（row） 字段（field） 列（column） 映射（mapping） 表结构（schema） 全文索引 索引 查询DSL SQL GET select PUT/POST update DELETE delete 节点信息 查看节点信息 curl localhost:9200 查看节点健康度 curl localhost:9200/_cat/health?v&amp;pretty=true 查看集群状况 curl localhost:9200/_cat/nodes?v&amp;pretty=true index(索引)操作 查看当前节点的所有 Index。 curl -X GET &#39;http://localhost:9200/_cat/indices?v&#39; 可以列出每个 Index 所包含的 Type curl &#39;localhost:9200/_mapping?pretty=true&#39; 新建一个名叫weather的 Index。 curl -X PUT &#39;localhost:9200/weather&#39; 删除这个 Index。 curl -X DELETE &#39;localhost:9200/weather&#39; 文档操作 获取 GET /website/blog/123?">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/3XTrh1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="elasticsearch" />
<meta property="og:description" content="基本概念 Node 与 Cluster Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。
单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。
Index Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。
所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。
Document Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。
Type Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。
不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。
在6.0之前的版本，一个ElasticSearch索引中，可以有多个类型；从6.0版本开始，，一个ElasticSearch索引中，只有1个类型。一个类型是索引的一个逻辑上的分类，通常具有一组相同字段的文档组成。ElasticSearch的类型概念相当于关系数据库的数据表。
shard 当数据量较大时，索引的存储空间需求超出单个节点磁盘容量的限制，或者出现单个节点处理速度较慢。为了解决这些问题，ElasticSearch将索引中的数据进行切分成多个分片（shard），每个分片存储这个索引的一部分数据，分布在不同节点上。当需要查询索引时，ElasticSearch将查询发送到每个相关分片，之后将查询结果合并，这个过程对ElasticSearch应用来说是透明的，用户感知不到分片的存在。 一个索引的分片一旦指定，不再修改。
副本 其实，分片全称是主分片，简称为分片。主分片是相对于副本来说的，副本是对主分片的一个或多个复制版本（或称拷贝），这些复制版本（拷贝）可以称为复制分片，可以直接称之为副本。当主分片丢失时，集群可以将一个副本升级为新的主分片。
对比 ElasticSearch RDBMS 索引（index） 数据库（database） 类型（type） 表（table） 文档（document） 行（row） 字段（field） 列（column） 映射（mapping） 表结构（schema） 全文索引 索引 查询DSL SQL GET select PUT/POST update DELETE delete 节点信息 查看节点信息 curl localhost:9200 查看节点健康度 curl localhost:9200/_cat/health?v&amp;pretty=true 查看集群状况 curl localhost:9200/_cat/nodes?v&amp;pretty=true index(索引)操作 查看当前节点的所有 Index。 curl -X GET &#39;http://localhost:9200/_cat/indices?v&#39; 可以列出每个 Index 所包含的 Type curl &#39;localhost:9200/_mapping?pretty=true&#39; 新建一个名叫weather的 Index。 curl -X PUT &#39;localhost:9200/weather&#39; 删除这个 Index。 curl -X DELETE &#39;localhost:9200/weather&#39; 文档操作 获取 GET /website/blog/123?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/3XTrh1/" /><meta property="article:section" content="4" />
<meta property="article:published_time" content="2020-09-23T16:53:39+00:00" />
<meta property="article:modified_time" content="2020-09-23T16:53:39+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="elasticsearch"/>
<meta name="twitter:description" content="基本概念 Node 与 Cluster Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。
单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。
Index Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。
所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。
Document Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。
Type Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。
不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。
在6.0之前的版本，一个ElasticSearch索引中，可以有多个类型；从6.0版本开始，，一个ElasticSearch索引中，只有1个类型。一个类型是索引的一个逻辑上的分类，通常具有一组相同字段的文档组成。ElasticSearch的类型概念相当于关系数据库的数据表。
shard 当数据量较大时，索引的存储空间需求超出单个节点磁盘容量的限制，或者出现单个节点处理速度较慢。为了解决这些问题，ElasticSearch将索引中的数据进行切分成多个分片（shard），每个分片存储这个索引的一部分数据，分布在不同节点上。当需要查询索引时，ElasticSearch将查询发送到每个相关分片，之后将查询结果合并，这个过程对ElasticSearch应用来说是透明的，用户感知不到分片的存在。 一个索引的分片一旦指定，不再修改。
副本 其实，分片全称是主分片，简称为分片。主分片是相对于副本来说的，副本是对主分片的一个或多个复制版本（或称拷贝），这些复制版本（拷贝）可以称为复制分片，可以直接称之为副本。当主分片丢失时，集群可以将一个副本升级为新的主分片。
对比 ElasticSearch RDBMS 索引（index） 数据库（database） 类型（type） 表（table） 文档（document） 行（row） 字段（field） 列（column） 映射（mapping） 表结构（schema） 全文索引 索引 查询DSL SQL GET select PUT/POST update DELETE delete 节点信息 查看节点信息 curl localhost:9200 查看节点健康度 curl localhost:9200/_cat/health?v&amp;pretty=true 查看集群状况 curl localhost:9200/_cat/nodes?v&amp;pretty=true index(索引)操作 查看当前节点的所有 Index。 curl -X GET &#39;http://localhost:9200/_cat/indices?v&#39; 可以列出每个 Index 所包含的 Type curl &#39;localhost:9200/_mapping?pretty=true&#39; 新建一个名叫weather的 Index。 curl -X PUT &#39;localhost:9200/weather&#39; 删除这个 Index。 curl -X DELETE &#39;localhost:9200/weather&#39; 文档操作 获取 GET /website/blog/123?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "4s",
      "item": "https://haokiu.com/4/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "elasticsearch",
      "item": "https://haokiu.com/3XTrh1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "elasticsearch",
  "name": "elasticsearch",
  "description": "基本概念 Node 与 Cluster Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。\n单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。\nIndex Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。\n所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。\nDocument Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。\nType Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。\n不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。\n在6.0之前的版本，一个ElasticSearch索引中，可以有多个类型；从6.0版本开始，，一个ElasticSearch索引中，只有1个类型。一个类型是索引的一个逻辑上的分类，通常具有一组相同字段的文档组成。ElasticSearch的类型概念相当于关系数据库的数据表。\nshard 当数据量较大时，索引的存储空间需求超出单个节点磁盘容量的限制，或者出现单个节点处理速度较慢。为了解决这些问题，ElasticSearch将索引中的数据进行切分成多个分片（shard），每个分片存储这个索引的一部分数据，分布在不同节点上。当需要查询索引时，ElasticSearch将查询发送到每个相关分片，之后将查询结果合并，这个过程对ElasticSearch应用来说是透明的，用户感知不到分片的存在。 一个索引的分片一旦指定，不再修改。\n副本 其实，分片全称是主分片，简称为分片。主分片是相对于副本来说的，副本是对主分片的一个或多个复制版本（或称拷贝），这些复制版本（拷贝）可以称为复制分片，可以直接称之为副本。当主分片丢失时，集群可以将一个副本升级为新的主分片。\n对比 ElasticSearch RDBMS 索引（index） 数据库（database） 类型（type） 表（table） 文档（document） 行（row） 字段（field） 列（column） 映射（mapping） 表结构（schema） 全文索引 索引 查询DSL SQL GET select PUT/POST update DELETE delete 节点信息 查看节点信息 curl localhost:9200 查看节点健康度 curl localhost:9200/_cat/health?v\u0026amp;pretty=true 查看集群状况 curl localhost:9200/_cat/nodes?v\u0026amp;pretty=true index(索引)操作 查看当前节点的所有 Index。 curl -X GET \u0026#39;http://localhost:9200/_cat/indices?v\u0026#39; 可以列出每个 Index 所包含的 Type curl \u0026#39;localhost:9200/_mapping?pretty=true\u0026#39; 新建一个名叫weather的 Index。 curl -X PUT \u0026#39;localhost:9200/weather\u0026#39; 删除这个 Index。 curl -X DELETE \u0026#39;localhost:9200/weather\u0026#39; 文档操作 获取 GET /website/blog/123?",
  "keywords": [
    "es"
  ],
  "articleBody": "基本概念 Node 与 Cluster Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。\n单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。\nIndex Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。\n所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。\nDocument Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。\nType Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。\n不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。\n在6.0之前的版本，一个ElasticSearch索引中，可以有多个类型；从6.0版本开始，，一个ElasticSearch索引中，只有1个类型。一个类型是索引的一个逻辑上的分类，通常具有一组相同字段的文档组成。ElasticSearch的类型概念相当于关系数据库的数据表。\nshard 当数据量较大时，索引的存储空间需求超出单个节点磁盘容量的限制，或者出现单个节点处理速度较慢。为了解决这些问题，ElasticSearch将索引中的数据进行切分成多个分片（shard），每个分片存储这个索引的一部分数据，分布在不同节点上。当需要查询索引时，ElasticSearch将查询发送到每个相关分片，之后将查询结果合并，这个过程对ElasticSearch应用来说是透明的，用户感知不到分片的存在。 一个索引的分片一旦指定，不再修改。\n副本 其实，分片全称是主分片，简称为分片。主分片是相对于副本来说的，副本是对主分片的一个或多个复制版本（或称拷贝），这些复制版本（拷贝）可以称为复制分片，可以直接称之为副本。当主分片丢失时，集群可以将一个副本升级为新的主分片。\n对比 ElasticSearch RDBMS 索引（index） 数据库（database） 类型（type） 表（table） 文档（document） 行（row） 字段（field） 列（column） 映射（mapping） 表结构（schema） 全文索引 索引 查询DSL SQL GET select PUT/POST update DELETE delete 节点信息 查看节点信息 curl localhost:9200 查看节点健康度 curl localhost:9200/_cat/health?v\u0026pretty=true 查看集群状况 curl localhost:9200/_cat/nodes?v\u0026pretty=true index(索引)操作 查看当前节点的所有 Index。 curl -X GET 'http://localhost:9200/_cat/indices?v' 可以列出每个 Index 所包含的 Type curl 'localhost:9200/_mapping?pretty=true' 新建一个名叫weather的 Index。 curl -X PUT 'localhost:9200/weather' 删除这个 Index。 curl -X DELETE 'localhost:9200/weather' 文档操作 获取 GET /website/blog/123?pretty { \"_index\" : \"website\", \"_type\" : \"blog\", \"_id\" : \"123\", \"_version\" : 1, \"found\" : true, \"_source\" : { \"title\": \"My first blog entry\", \"text\": \"Just trying this out...\", \"date\": \"2014/01/01\" } } 检索文档的一部分\nGET /website/blog/123?_source=title,text { \"_index\" : \"website\", \"_type\" : \"blog\", \"_id\" : \"123\", \"_version\" : 1, \"exists\" : true, \"_source\" : { \"title\": \"My first blog entry\" , \"text\": \"Just trying this out...\" } } 只想得到_source字段而不要其他的元数据\nGET /website/blog/123/_source { \"title\": \"My first blog entry\", \"text\": \"Just trying this out...\", \"date\": \"2014/01/01\" } 存在 如果你想做的只是检查文档是否存在——你对内容完全不感兴趣——使用HEAD方法来代替GET。HEAD请求不会返回响应体，只有HTTP头：\ncurl -i -XHEAD http://localhost:9200/website/blog/123 Elasticsearch将会返回200 OK状态如果你的文档存在：\nHTTP/1.1 200 OK Content-Type: text/plain; charset=UTF-8 Content-Length: 0 如果不存在返回404 Not Found：\nHTTP/1.1 404 Not Found Content-Type: text/plain; charset=UTF-8 Content-Length: 0 更新整个文档 PUT /website/blog/123 { \"title\": \"My first blog entry\", \"text\": \"I am starting to get the hang of this...\", \"date\": \"2014/01/02\" } 新建文档 PUT /website/blog/123 { ... } 删除文档 DELETE /website/blog/123 配置 elasticsearch的config文件夹里面有两个配置文件：elasticsearch.yml和log4j2.properties，第一个是es的基本配置文件，第二个是日志配置文件，es也是使用log4j2来记录日志的，所以log4j2.properties里的设置按普通log4j2配置文件来设置就行了。\ncluster.name Elasticsearch 默认启动的集群名字叫 elasticsearch 。 你最好给你的生产环境的集群改个名字，改名字的目的很简单， 就是防止某人的笔记本电脑加入了集群这种意外。简单修改成 elasticsearch_production 会很省心。\n你可以在你的 elasticsearch.yml 文件中修改：\ncluster.name: elasticsearch_production\nnode.name 建议给每个节点设置一个有意义的、清楚的、描述性的名字，同样你可以在 elasticsearch.yml 中配置：\nnode.name: elasticsearch_005_data\nMaster节点 （主节点） node.master: true node.data: false 这样配置的节点为master节点。主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。稳定的主节点对集群的健康是非常重要的。\ndiscovery.zen.minimum_master_nodes 为了防止数据丢失，配置discovery.zen.minimum_master_nodes设置是至关重要的（默认为1），每个主节点应该知道形成一个集群的最小数量的主资格节点的数量。\n假设我们有一个集群。有3个主资格节点，当网络发生故障的时候，有可能其中一个节点不能和其他节点进行通信了。这个时候，当discovery.zen.minimum_master_nodes设置为1的时候，就会分成两个小的独立集群，当网络好的时候，就会出现数据错误或者丢失数据的情况。当discovery.zen.minimum_master_nodes设置为2的时候，一个网络中有两个主资格节点，可以继续工作，另一部分，由于只有一个主资格节点，则不会形成一个独立的集群，这个时候当网络回复的时候，节点又会从新加入集群。\n设置这个值的原则是：（master_eligible_nodes / 2）+ 1\ndiscovery.zen.ping.unicast.hosts Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。\n虽然组播仍然作为插件提供， 但它应该永远不被使用在生产环境了，否则你得到的结果就是一个节点意外的加入到了你的生产环境，仅仅是因为他们收到了一个错误的组播信号。 对于组播本身并没有错，组播会导致一些愚蠢的问题，并且导致集群变的脆弱（比如，一个网络工程师正在捣鼓网络，而没有告诉你，你会发现所有的节点突然发现不了对方了）。\n使用单播，你可以为 Elasticsearch 提供一些它应该去尝试连接的节点列表。 当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 master 节点，并加入集群。\n这意味着你的单播列表不需要包含你的集群中的所有节点， 它只是需要足够的节点，当一个新节点联系上其中一个并且说上话就可以了。如果你使用 master 候选节点作为单播列表，你只要列出三个就可以了。 这个配置在 elasticsearch.yml 文件中：\ndiscovery.zen.ping.unicast.hosts: [\"host1\", \"host2:port\"]\n注：端口非9200的节点， ip后需加端口号， 因 es 默认识别端口是9200\nData节点（数据节点） node.master: false node.data: true 数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等。数据节点对cpu，内存，io要求较高，在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。\nClient节点 (客户端节点) node.master: false node.data: false 当主节点和数据节点配置都设置为false的时候，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求。 警告：添加太多的客户端节点对集群是一种负担，因为主节点必须等待每一个节点集群状态的更新确认！客户节点的作用不应被夸大，数据节点也可以起到类似的作用。\n安全 search-guard是elastcisearch的一款插件，提供加密，身份验证和授权，基于search guard SSL，另外提供可插入的身份验证/授权模块，search-guard是shield的替代品，可免费提供所有的基本安全功能。\n参考 阮一蜂的博客\n",
  "wordCount" : "342",
  "inLanguage": "en",
  "datePublished": "2020-09-23T16:53:39Z",
  "dateModified": "2020-09-23T16:53:39Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/3XTrh1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/4/">4s</a></div>
    <h1 class="post-title">
      elasticsearch
    </h1>
    <div class="post-meta"><span title='2020-09-23 16:53:39 +0000 UTC'>September 23, 2020</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="基本概念">基本概念</a><ul>
                        
                <li>
                    <a href="#node-%e4%b8%8e-cluster" aria-label="Node 与 Cluster">Node 与 Cluster</a></li>
                <li>
                    <a href="#index" aria-label="Index">Index</a></li>
                <li>
                    <a href="#document" aria-label="Document">Document</a></li>
                <li>
                    <a href="#type" aria-label="Type">Type</a></li>
                <li>
                    <a href="#shard" aria-label="shard">shard</a></li>
                <li>
                    <a href="#%e5%89%af%e6%9c%ac" aria-label="副本">副本</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%af%b9%e6%af%94" aria-label="对比">对比</a></li>
                <li>
                    <a href="#%e8%8a%82%e7%82%b9%e4%bf%a1%e6%81%af" aria-label="节点信息">节点信息</a><ul>
                        
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%8a%82%e7%82%b9%e4%bf%a1%e6%81%af" aria-label="查看节点信息">查看节点信息</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%8a%82%e7%82%b9%e5%81%a5%e5%ba%b7%e5%ba%a6" aria-label="查看节点健康度">查看节点健康度</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e9%9b%86%e7%be%a4%e7%8a%b6%e5%86%b5" aria-label="查看集群状况">查看集群状况</a></li></ul>
                </li>
                <li>
                    <a href="#index%e7%b4%a2%e5%bc%95%e6%93%8d%e4%bd%9c" aria-label="index(索引)操作">index(索引)操作</a><ul>
                        
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e8%8a%82%e7%82%b9%e7%9a%84%e6%89%80%e6%9c%89-index" aria-label="查看当前节点的所有 Index。">查看当前节点的所有 Index。</a></li>
                <li>
                    <a href="#%e5%8f%af%e4%bb%a5%e5%88%97%e5%87%ba%e6%af%8f%e4%b8%aa-index-%e6%89%80%e5%8c%85%e5%90%ab%e7%9a%84-type" aria-label="可以列出每个 Index 所包含的 Type">可以列出每个 Index 所包含的 Type</a></li>
                <li>
                    <a href="#%e6%96%b0%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%90%8d%e5%8f%abweather%e7%9a%84-index" aria-label="新建一个名叫weather的 Index。">新建一个名叫weather的 Index。</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e8%bf%99%e4%b8%aa-index" aria-label="删除这个 Index。">删除这个 Index。</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%96%87%e6%a1%a3%e6%93%8d%e4%bd%9c" aria-label="文档操作">文档操作</a><ul>
                        
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96" aria-label="获取">获取</a></li>
                <li>
                    <a href="#%e5%ad%98%e5%9c%a8" aria-label="存在">存在</a></li>
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0%e6%95%b4%e4%b8%aa%e6%96%87%e6%a1%a3" aria-label="更新整个文档">更新整个文档</a></li>
                <li>
                    <a href="#%e6%96%b0%e5%bb%ba%e6%96%87%e6%a1%a3" aria-label="新建文档">新建文档</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e6%96%87%e6%a1%a3" aria-label="删除文档">删除文档</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae" aria-label="配置">配置</a><ul>
                        
                <li>
                    <a href="#clustername" aria-label="cluster.name">cluster.name</a></li>
                <li>
                    <a href="#nodename" aria-label="node.name">node.name</a></li>
                <li>
                    <a href="#master%e8%8a%82%e7%82%b9-%e4%b8%bb%e8%8a%82%e7%82%b9" aria-label="Master节点 （主节点）">Master节点 （主节点）</a><ul>
                        
                <li>
                    <a href="#discoveryzenminimum_master_nodes" aria-label="discovery.zen.minimum_master_nodes">discovery.zen.minimum_master_nodes</a></li>
                <li>
                    <a href="#discoveryzenpingunicasthosts" aria-label="discovery.zen.ping.unicast.hosts">discovery.zen.ping.unicast.hosts</a></li></ul>
                </li>
                <li>
                    <a href="#data%e8%8a%82%e7%82%b9%e6%95%b0%e6%8d%ae%e8%8a%82%e7%82%b9" aria-label="Data节点（数据节点）">Data节点（数据节点）</a></li>
                <li>
                    <a href="#client%e8%8a%82%e7%82%b9-%e5%ae%a2%e6%88%b7%e7%ab%af%e8%8a%82%e7%82%b9" aria-label="Client节点 (客户端节点)">Client节点 (客户端节点)</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%89%e5%85%a8" aria-label="安全">安全</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="基本概念">基本概念</h2>
<h3 id="node-与-cluster">Node 与 Cluster</h3>
<p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p>
<p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p>
<h3 id="index">Index</h3>
<p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>
<h3 id="document">Document</h3>
<p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
<h3 id="type">Type</h3>
<p>Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p>
<p>不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>
<p>在6.0之前的版本，一个ElasticSearch索引中，可以有多个类型；从6.0版本开始，，一个ElasticSearch索引中，只有1个类型。一个类型是索引的一个逻辑上的分类，通常具有一组相同字段的文档组成。ElasticSearch的类型概念相当于关系数据库的数据表。</p>
<h3 id="shard">shard</h3>
<p>当数据量较大时，索引的存储空间需求超出单个节点磁盘容量的限制，或者出现单个节点处理速度较慢。为了解决这些问题，ElasticSearch将索引中的数据进行切分成多个分片（shard），每个分片存储这个索引的一部分数据，分布在不同节点上。当需要查询索引时，ElasticSearch将查询发送到每个相关分片，之后将查询结果合并，这个过程对ElasticSearch应用来说是透明的，用户感知不到分片的存在。 一个索引的分片一旦指定，不再修改。</p>
<h3 id="副本">副本</h3>
<p>其实，分片全称是主分片，简称为分片。主分片是相对于副本来说的，副本是对主分片的一个或多个复制版本（或称拷贝），这些复制版本（拷贝）可以称为复制分片，可以直接称之为副本。当主分片丢失时，集群可以将一个副本升级为新的主分片。</p>
<h2 id="对比">对比</h2>
<table>
<thead>
<tr>
<th>ElasticSearch</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>索引（index）</td>
<td>数据库（database）</td>
</tr>
<tr>
<td>类型（type）</td>
<td>表（table）</td>
</tr>
<tr>
<td>文档（document）</td>
<td>行（row）</td>
</tr>
<tr>
<td>字段（field）</td>
<td>列（column）</td>
</tr>
<tr>
<td>映射（mapping）</td>
<td>表结构（schema）</td>
</tr>
<tr>
<td>全文索引</td>
<td>索引</td>
</tr>
<tr>
<td>查询DSL</td>
<td>SQL</td>
</tr>
<tr>
<td>GET</td>
<td>select</td>
</tr>
<tr>
<td>PUT/POST</td>
<td>update</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete</td>
</tr>
</tbody>
</table>
<h2 id="节点信息">节点信息</h2>
<h3 id="查看节点信息">查看节点信息</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl localhost:9200
</span></span></code></pre></div><h3 id="查看节点健康度">查看节点健康度</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl localhost:9200/_cat/health?v&amp;pretty<span style="color:#f92672">=</span>true
</span></span></code></pre></div><h3 id="查看集群状况">查看集群状况</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl localhost:9200/_cat/nodes?v&amp;pretty<span style="color:#f92672">=</span>true
</span></span></code></pre></div><h2 id="index索引操作">index(索引)操作</h2>
<h3 id="查看当前节点的所有-index">查看当前节点的所有 Index。</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl -X GET <span style="color:#e6db74">&#39;http://localhost:9200/_cat/indices?v&#39;</span>
</span></span></code></pre></div><h3 id="可以列出每个-index-所包含的-type">可以列出每个 Index 所包含的 Type</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl <span style="color:#e6db74">&#39;localhost:9200/_mapping?pretty=true&#39;</span>
</span></span></code></pre></div><h3 id="新建一个名叫weather的-index">新建一个名叫weather的 Index。</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl -X PUT <span style="color:#e6db74">&#39;localhost:9200/weather&#39;</span>
</span></span></code></pre></div><h3 id="删除这个-index">删除这个 Index。</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl -X DELETE <span style="color:#e6db74">&#39;localhost:9200/weather&#39;</span>
</span></span></code></pre></div><h2 id="文档操作">文档操作</h2>
<h3 id="获取">获取</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>GET /website/blog/123?pretty
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_index&#34;</span> :   <span style="color:#e6db74">&#34;website&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_type&#34;</span> :    <span style="color:#e6db74">&#34;blog&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_id&#34;</span> :      <span style="color:#e6db74">&#34;123&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_version&#34;</span> : 1,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;found&#34;</span> :    true,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_source&#34;</span> :  <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;title&#34;</span>: <span style="color:#e6db74">&#34;My first blog entry&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;text&#34;</span>:  <span style="color:#e6db74">&#34;Just trying this out...&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;date&#34;</span>:  <span style="color:#e6db74">&#34;2014/01/01&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>检索文档的一部分</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>GET /website/blog/123?_source<span style="color:#f92672">=</span>title,text
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_index&#34;</span> :   <span style="color:#e6db74">&#34;website&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_type&#34;</span> :    <span style="color:#e6db74">&#34;blog&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_id&#34;</span> :      <span style="color:#e6db74">&#34;123&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_version&#34;</span> : 1,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;exists&#34;</span> :   true,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_source&#34;</span> : <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;title&#34;</span>: <span style="color:#e6db74">&#34;My first blog entry&#34;</span> ,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;text&#34;</span>:  <span style="color:#e6db74">&#34;Just trying this out...&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>只想得到_source字段而不要其他的元数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>GET /website/blog/123/_source
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;title&#34;</span>: <span style="color:#e6db74">&#34;My first blog entry&#34;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;text&#34;</span>:  <span style="color:#e6db74">&#34;Just trying this out...&#34;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;date&#34;</span>:  <span style="color:#e6db74">&#34;2014/01/01&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="存在">存在</h3>
<p>如果你想做的只是检查文档是否存在——你对内容完全不感兴趣——使用HEAD方法来代替GET。HEAD请求不会返回响应体，只有HTTP头：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl -i -XHEAD http://localhost:9200/website/blog/123
</span></span></code></pre></div><p>Elasticsearch将会返回200 OK状态如果你的文档存在：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: text/plain; charset<span style="color:#f92672">=</span>UTF-8
</span></span><span style="display:flex;"><span>Content-Length: <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>如果不存在返回404 Not Found：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">404</span> Not Found
</span></span><span style="display:flex;"><span>Content-Type: text/plain; charset<span style="color:#f92672">=</span>UTF-8
</span></span><span style="display:flex;"><span>Content-Length: <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><h3 id="更新整个文档">更新整个文档</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>PUT /website/blog/123
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;title&#34;</span>: <span style="color:#e6db74">&#34;My first blog entry&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>:  <span style="color:#e6db74">&#34;I am starting to get the hang of this...&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;date&#34;</span>:  <span style="color:#e6db74">&#34;2014/01/02&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="新建文档">新建文档</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>PUT /website/blog/123
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span> ... <span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="删除文档">删除文档</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>DELETE /website/blog/123
</span></span></code></pre></div><h2 id="配置">配置</h2>
<p>elasticsearch的config文件夹里面有两个配置文件：elasticsearch.yml和log4j2.properties，第一个是es的基本配置文件，第二个是日志配置文件，es也是使用log4j2来记录日志的，所以log4j2.properties里的设置按普通log4j2配置文件来设置就行了。</p>
<h3 id="clustername">cluster.name</h3>
<p>Elasticsearch 默认启动的集群名字叫 elasticsearch 。 你最好给你的生产环境的集群改个名字，改名字的目的很简单， 就是防止某人的笔记本电脑加入了集群这种意外。简单修改成 elasticsearch_production 会很省心。</p>
<p>你可以在你的 elasticsearch.yml 文件中修改：</p>
<p><code>cluster.name: elasticsearch_production</code></p>
<h3 id="nodename">node.name</h3>
<p>建议给每个节点设置一个有意义的、清楚的、描述性的名字，同样你可以在 elasticsearch.yml 中配置：</p>
<p><code>node.name: elasticsearch_005_data</code></p>
<h3 id="master节点-主节点">Master节点 （主节点）</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>node.master: true
</span></span><span style="display:flex;"><span>node.data: false
</span></span></code></pre></div><p>这样配置的节点为master节点。主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。稳定的主节点对集群的健康是非常重要的。</p>
<h4 id="discoveryzenminimum_master_nodes">discovery.zen.minimum_master_nodes</h4>
<p>为了防止数据丢失，配置discovery.zen.minimum_master_nodes设置是至关重要的（默认为1），每个主节点应该知道形成一个集群的最小数量的主资格节点的数量。</p>
<p>假设我们有一个集群。有3个主资格节点，当网络发生故障的时候，有可能其中一个节点不能和其他节点进行通信了。这个时候，当discovery.zen.minimum_master_nodes设置为1的时候，就会分成两个小的独立集群，当网络好的时候，就会出现数据错误或者丢失数据的情况。当discovery.zen.minimum_master_nodes设置为2的时候，一个网络中有两个主资格节点，可以继续工作，另一部分，由于只有一个主资格节点，则不会形成一个独立的集群，这个时候当网络回复的时候，节点又会从新加入集群。</p>
<p>设置这个值的原则是：（master_eligible_nodes / 2）+ 1</p>
<h4 id="discoveryzenpingunicasthosts">discovery.zen.ping.unicast.hosts</h4>
<p>Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。</p>
<p>虽然组播仍然作为插件提供， 但它应该永远不被使用在生产环境了，否则你得到的结果就是一个节点意外的加入到了你的生产环境，仅仅是因为他们收到了一个错误的组播信号。 对于组播本身并没有错，组播会导致一些愚蠢的问题，并且导致集群变的脆弱（比如，一个网络工程师正在捣鼓网络，而没有告诉你，你会发现所有的节点突然发现不了对方了）。</p>
<p>使用单播，你可以为 Elasticsearch 提供一些它应该去尝试连接的节点列表。 当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 master 节点，并加入集群。</p>
<p>这意味着你的单播列表不需要包含你的集群中的所有节点， 它只是需要足够的节点，当一个新节点联系上其中一个并且说上话就可以了。如果你使用 master 候选节点作为单播列表，你只要列出三个就可以了。 这个配置在 elasticsearch.yml 文件中：</p>
<p><code>discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2:port&quot;]</code></p>
<p>注：端口非9200的节点， ip后需加端口号， 因 es 默认识别端口是9200</p>
<h3 id="data节点数据节点">Data节点（数据节点）</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>node.master: false
</span></span><span style="display:flex;"><span>node.data: true
</span></span></code></pre></div><p>数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等。数据节点对cpu，内存，io要求较高，在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。</p>
<h3 id="client节点-客户端节点">Client节点 (客户端节点)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>node.master: false
</span></span><span style="display:flex;"><span>node.data: false
</span></span></code></pre></div><p>当主节点和数据节点配置都设置为false的时候，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求。
警告：添加太多的客户端节点对集群是一种负担，因为主节点必须等待每一个节点集群状态的更新确认！客户节点的作用不应被夸大，数据节点也可以起到类似的作用。</p>
<h2 id="安全">安全</h2>
<p>search-guard是elastcisearch的一款插件，提供加密，身份验证和授权，基于search guard SSL，另外提供可插入的身份验证/授权模块，search-guard是shield的替代品，可免费提供所有的基本安全功能。</p>
<h2 id="参考">参考</h2>
<p><a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">阮一蜂的博客</a></p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://haokiu.com/tags/bigdata/">bigdata</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
