<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>03 服务器端的程序架构介绍 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="03 服务器端的程序架构介绍 通过上一节的编译与部署，我们会得到TeamTalk服务器端以下部署程序：
db_proxy_server file_server http_msg_server login_server msfs msg_server push_server router_server 这些服务构成的拓扑图如下：
各个服务程序的作用描述如下：
LoginServer (C&#43;&#43;): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C&#43;&#43;): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C&#43;&#43;): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C&#43;&#43;): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C&#43;&#43;): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C&#43;&#43;): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C&#43;&#43;) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C&#43;&#43;): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 注意：上图中并没有push_server和http_push_server。如果你不调试ios版本的客户端，可以暂且不启动push_server，另外http_push_server也可以暂不启动。
启动顺序：
一般来说，前端的服务会依赖后端的服务，所以一般先启动后端服务，再启动前端服务。建议按以下顺序启动服务：
1、启动db_proxy。 2、启动route_server，file_server，msfs 3、启动login_server 4、启动msg_server 那么我就按照服务端的启动顺序去讲解服务端的一个流程概述。 第一步:启动db_proxy后，db_proxy会去根据配置文件连接相应的MySQL实例，以及redis实例。 第二步:启动route_server,file_server,msfs后，各个服务端都会开始监听相应的端口。 第三步:启动login_server,login_server就开始监听相应的端口(8080)，等待客户端的连接，而分配一个负载相对较小的msg_server给客户端。 第四步:启动msg_server(端口8000)，msg_server启动后，会去主动连接route_server，login_server，db_proxy_server，会将自己的监听的端口信息注册到login_server去，同时在用户上线，下线的时候会将自己的负载情况汇报给login_server.
各个服务的端口号 (注意：如果出现部署完成后但是服务进程启动有问题或者只有部分服务进程启动了，请查看相应的log日志，请查看相应的log日志，请查看相应的log日志。)
服务 端口 login_server 8080/8008 msg_server 8000 db_proxy_server 10600 route_server 8200 http_msg_server 8400 file_server 8600/8601 服务网络通信框架介绍：
上面介绍的每一个服务都使用了相同的网络通信框架，该通信框架可以单独拿出来做为一个通用的网络通信框架。该网络框架是在一个循环里面不断地检测IO事件，然后对检测到的事件进行处理。流程如下：
使用IO复用技术（linux和windows平台用select、mac平台用kevent）分离网络IO。
对分离出来的网络IO进行操作，分为socket句柄可读、可写和出错三种情况。
当然再加上定时器事件，即检测一个定时器事件列表，如果有定时器到期，则执行该定时器事件。
整个框架的伪码大致如下：
while (running) { //处理定时器事件 _CheckTimer(); //IO multiplexing int n = select(socket集合, ...); //事件处理 **if** (某些socket可读) { pSocket-&gt;OnRead(); } **if** (某些socket可写) { pSocket-&gt;OnWrite(); } **if** (某些socket出错) { pSocket-&gt;OnClose(); } } 处理定时器事件的代码如下：
void CEventDispatch::_CheckTimer() { uint64_t curr_tick = get_tick_count(); list&lt;TimerItem*&gt;::iterator it; for (it = m_timer_list.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/74f8790b79af42ab856a668b8927b38a/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="03 服务器端的程序架构介绍" />
<meta property="og:description" content="03 服务器端的程序架构介绍 通过上一节的编译与部署，我们会得到TeamTalk服务器端以下部署程序：
db_proxy_server file_server http_msg_server login_server msfs msg_server push_server router_server 这些服务构成的拓扑图如下：
各个服务程序的作用描述如下：
LoginServer (C&#43;&#43;): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C&#43;&#43;): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C&#43;&#43;): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C&#43;&#43;): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C&#43;&#43;): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C&#43;&#43;): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C&#43;&#43;) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C&#43;&#43;): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 注意：上图中并没有push_server和http_push_server。如果你不调试ios版本的客户端，可以暂且不启动push_server，另外http_push_server也可以暂不启动。
启动顺序：
一般来说，前端的服务会依赖后端的服务，所以一般先启动后端服务，再启动前端服务。建议按以下顺序启动服务：
1、启动db_proxy。 2、启动route_server，file_server，msfs 3、启动login_server 4、启动msg_server 那么我就按照服务端的启动顺序去讲解服务端的一个流程概述。 第一步:启动db_proxy后，db_proxy会去根据配置文件连接相应的MySQL实例，以及redis实例。 第二步:启动route_server,file_server,msfs后，各个服务端都会开始监听相应的端口。 第三步:启动login_server,login_server就开始监听相应的端口(8080)，等待客户端的连接，而分配一个负载相对较小的msg_server给客户端。 第四步:启动msg_server(端口8000)，msg_server启动后，会去主动连接route_server，login_server，db_proxy_server，会将自己的监听的端口信息注册到login_server去，同时在用户上线，下线的时候会将自己的负载情况汇报给login_server.
各个服务的端口号 (注意：如果出现部署完成后但是服务进程启动有问题或者只有部分服务进程启动了，请查看相应的log日志，请查看相应的log日志，请查看相应的log日志。)
服务 端口 login_server 8080/8008 msg_server 8000 db_proxy_server 10600 route_server 8200 http_msg_server 8400 file_server 8600/8601 服务网络通信框架介绍：
上面介绍的每一个服务都使用了相同的网络通信框架，该通信框架可以单独拿出来做为一个通用的网络通信框架。该网络框架是在一个循环里面不断地检测IO事件，然后对检测到的事件进行处理。流程如下：
使用IO复用技术（linux和windows平台用select、mac平台用kevent）分离网络IO。
对分离出来的网络IO进行操作，分为socket句柄可读、可写和出错三种情况。
当然再加上定时器事件，即检测一个定时器事件列表，如果有定时器到期，则执行该定时器事件。
整个框架的伪码大致如下：
while (running) { //处理定时器事件 _CheckTimer(); //IO multiplexing int n = select(socket集合, ...); //事件处理 **if** (某些socket可读) { pSocket-&gt;OnRead(); } **if** (某些socket可写) { pSocket-&gt;OnWrite(); } **if** (某些socket出错) { pSocket-&gt;OnClose(); } } 处理定时器事件的代码如下：
void CEventDispatch::_CheckTimer() { uint64_t curr_tick = get_tick_count(); list&lt;TimerItem*&gt;::iterator it; for (it = m_timer_list." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/74f8790b79af42ab856a668b8927b38a/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="03 服务器端的程序架构介绍"/>
<meta name="twitter:description" content="03 服务器端的程序架构介绍 通过上一节的编译与部署，我们会得到TeamTalk服务器端以下部署程序：
db_proxy_server file_server http_msg_server login_server msfs msg_server push_server router_server 这些服务构成的拓扑图如下：
各个服务程序的作用描述如下：
LoginServer (C&#43;&#43;): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C&#43;&#43;): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C&#43;&#43;): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C&#43;&#43;): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C&#43;&#43;): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C&#43;&#43;): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C&#43;&#43;) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C&#43;&#43;): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 注意：上图中并没有push_server和http_push_server。如果你不调试ios版本的客户端，可以暂且不启动push_server，另外http_push_server也可以暂不启动。
启动顺序：
一般来说，前端的服务会依赖后端的服务，所以一般先启动后端服务，再启动前端服务。建议按以下顺序启动服务：
1、启动db_proxy。 2、启动route_server，file_server，msfs 3、启动login_server 4、启动msg_server 那么我就按照服务端的启动顺序去讲解服务端的一个流程概述。 第一步:启动db_proxy后，db_proxy会去根据配置文件连接相应的MySQL实例，以及redis实例。 第二步:启动route_server,file_server,msfs后，各个服务端都会开始监听相应的端口。 第三步:启动login_server,login_server就开始监听相应的端口(8080)，等待客户端的连接，而分配一个负载相对较小的msg_server给客户端。 第四步:启动msg_server(端口8000)，msg_server启动后，会去主动连接route_server，login_server，db_proxy_server，会将自己的监听的端口信息注册到login_server去，同时在用户上线，下线的时候会将自己的负载情况汇报给login_server.
各个服务的端口号 (注意：如果出现部署完成后但是服务进程启动有问题或者只有部分服务进程启动了，请查看相应的log日志，请查看相应的log日志，请查看相应的log日志。)
服务 端口 login_server 8080/8008 msg_server 8000 db_proxy_server 10600 route_server 8200 http_msg_server 8400 file_server 8600/8601 服务网络通信框架介绍：
上面介绍的每一个服务都使用了相同的网络通信框架，该通信框架可以单独拿出来做为一个通用的网络通信框架。该网络框架是在一个循环里面不断地检测IO事件，然后对检测到的事件进行处理。流程如下：
使用IO复用技术（linux和windows平台用select、mac平台用kevent）分离网络IO。
对分离出来的网络IO进行操作，分为socket句柄可读、可写和出错三种情况。
当然再加上定时器事件，即检测一个定时器事件列表，如果有定时器到期，则执行该定时器事件。
整个框架的伪码大致如下：
while (running) { //处理定时器事件 _CheckTimer(); //IO multiplexing int n = select(socket集合, ...); //事件处理 **if** (某些socket可读) { pSocket-&gt;OnRead(); } **if** (某些socket可写) { pSocket-&gt;OnWrite(); } **if** (某些socket出错) { pSocket-&gt;OnClose(); } } 处理定时器事件的代码如下：
void CEventDispatch::_CheckTimer() { uint64_t curr_tick = get_tick_count(); list&lt;TimerItem*&gt;::iterator it; for (it = m_timer_list."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "03 服务器端的程序架构介绍",
      "item": "https://haokiu.com/74f8790b79af42ab856a668b8927b38a/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "03 服务器端的程序架构介绍",
  "name": "03 服务器端的程序架构介绍",
  "description": "03 服务器端的程序架构介绍 通过上一节的编译与部署，我们会得到TeamTalk服务器端以下部署程序：\ndb_proxy_server file_server http_msg_server login_server msfs msg_server push_server router_server 这些服务构成的拓扑图如下：\n各个服务程序的作用描述如下：\nLoginServer (C++): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C++): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C++): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C++): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C++): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C++): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C++) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C++): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 注意：上图中并没有push_server和http_push_server。如果你不调试ios版本的客户端，可以暂且不启动push_server，另外http_push_server也可以暂不启动。\n启动顺序：\n一般来说，前端的服务会依赖后端的服务，所以一般先启动后端服务，再启动前端服务。建议按以下顺序启动服务：\n1、启动db_proxy。 2、启动route_server，file_server，msfs 3、启动login_server 4、启动msg_server 那么我就按照服务端的启动顺序去讲解服务端的一个流程概述。 第一步:启动db_proxy后，db_proxy会去根据配置文件连接相应的MySQL实例，以及redis实例。 第二步:启动route_server,file_server,msfs后，各个服务端都会开始监听相应的端口。 第三步:启动login_server,login_server就开始监听相应的端口(8080)，等待客户端的连接，而分配一个负载相对较小的msg_server给客户端。 第四步:启动msg_server(端口8000)，msg_server启动后，会去主动连接route_server，login_server，db_proxy_server，会将自己的监听的端口信息注册到login_server去，同时在用户上线，下线的时候会将自己的负载情况汇报给login_server.\n各个服务的端口号 (注意：如果出现部署完成后但是服务进程启动有问题或者只有部分服务进程启动了，请查看相应的log日志，请查看相应的log日志，请查看相应的log日志。)\n服务 端口 login_server 8080/8008 msg_server 8000 db_proxy_server 10600 route_server 8200 http_msg_server 8400 file_server 8600/8601 服务网络通信框架介绍：\n上面介绍的每一个服务都使用了相同的网络通信框架，该通信框架可以单独拿出来做为一个通用的网络通信框架。该网络框架是在一个循环里面不断地检测IO事件，然后对检测到的事件进行处理。流程如下：\n使用IO复用技术（linux和windows平台用select、mac平台用kevent）分离网络IO。\n对分离出来的网络IO进行操作，分为socket句柄可读、可写和出错三种情况。\n当然再加上定时器事件，即检测一个定时器事件列表，如果有定时器到期，则执行该定时器事件。\n整个框架的伪码大致如下：\nwhile (running) { //处理定时器事件 _CheckTimer(); //IO multiplexing int n = select(socket集合, ...); //事件处理 **if** (某些socket可读) { pSocket-\u0026gt;OnRead(); } **if** (某些socket可写) { pSocket-\u0026gt;OnWrite(); } **if** (某些socket出错) { pSocket-\u0026gt;OnClose(); } } 处理定时器事件的代码如下：\nvoid CEventDispatch::_CheckTimer() { uint64_t curr_tick = get_tick_count(); list\u0026lt;TimerItem*\u0026gt;::iterator it; for (it = m_timer_list.",
  "keywords": [
    
  ],
  "articleBody": "03 服务器端的程序架构介绍 通过上一节的编译与部署，我们会得到TeamTalk服务器端以下部署程序：\ndb_proxy_server file_server http_msg_server login_server msfs msg_server push_server router_server 这些服务构成的拓扑图如下：\n各个服务程序的作用描述如下：\nLoginServer (C++): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C++): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C++): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C++): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C++): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C++): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C++) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C++): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 注意：上图中并没有push_server和http_push_server。如果你不调试ios版本的客户端，可以暂且不启动push_server，另外http_push_server也可以暂不启动。\n启动顺序：\n一般来说，前端的服务会依赖后端的服务，所以一般先启动后端服务，再启动前端服务。建议按以下顺序启动服务：\n1、启动db_proxy。 2、启动route_server，file_server，msfs 3、启动login_server 4、启动msg_server 那么我就按照服务端的启动顺序去讲解服务端的一个流程概述。 第一步:启动db_proxy后，db_proxy会去根据配置文件连接相应的MySQL实例，以及redis实例。 第二步:启动route_server,file_server,msfs后，各个服务端都会开始监听相应的端口。 第三步:启动login_server,login_server就开始监听相应的端口(8080)，等待客户端的连接，而分配一个负载相对较小的msg_server给客户端。 第四步:启动msg_server(端口8000)，msg_server启动后，会去主动连接route_server，login_server，db_proxy_server，会将自己的监听的端口信息注册到login_server去，同时在用户上线，下线的时候会将自己的负载情况汇报给login_server.\n各个服务的端口号 (注意：如果出现部署完成后但是服务进程启动有问题或者只有部分服务进程启动了，请查看相应的log日志，请查看相应的log日志，请查看相应的log日志。)\n服务 端口 login_server 8080/8008 msg_server 8000 db_proxy_server 10600 route_server 8200 http_msg_server 8400 file_server 8600/8601 服务网络通信框架介绍：\n上面介绍的每一个服务都使用了相同的网络通信框架，该通信框架可以单独拿出来做为一个通用的网络通信框架。该网络框架是在一个循环里面不断地检测IO事件，然后对检测到的事件进行处理。流程如下：\n使用IO复用技术（linux和windows平台用select、mac平台用kevent）分离网络IO。\n对分离出来的网络IO进行操作，分为socket句柄可读、可写和出错三种情况。\n当然再加上定时器事件，即检测一个定时器事件列表，如果有定时器到期，则执行该定时器事件。\n整个框架的伪码大致如下：\nwhile (running) { //处理定时器事件 _CheckTimer(); //IO multiplexing int n = select(socket集合, ...); //事件处理 **if** (某些socket可读) { pSocket-\u003eOnRead(); } **if** (某些socket可写) { pSocket-\u003eOnWrite(); } **if** (某些socket出错) { pSocket-\u003eOnClose(); } } 处理定时器事件的代码如下：\nvoid CEventDispatch::_CheckTimer() { uint64_t curr_tick = get_tick_count(); list::iterator it; for (it = m_timer_list.begin(); it != m_timer_list.end(); ) { TimerItem* pItem = *it; // iterator maybe deleted in the callback, so we should increment it before callback it++; if(curr_tick \u003e= pItem-\u003enext_tick) { pItem-\u003enext_tick += pItem-\u003einterval; pItem-\u003ecallback(pItem-\u003euser_data, NETLIB_MSG_TIMER, 0, NULL); } } } 即遍历一个定时器列表，将定时器对象与当前时间（curr_tick）做比较，如果当前时间已经大于或等于定时器设置的时间，则表明定时器时间已经到了，执行定时器对象对应的回调函数。\n在来看看OnRead、OnWrite和OnClose这三个函数。在TeamTalk源码中每一个socket连接被封装成一个CBaseSocket对象，该对象是一个使用引用计数的类的子类，通过这种方法来实现生存期自动管理。\nvoid CBaseSocket::OnRead() { if (m_state == SOCKET_STATE_LISTENING) { _AcceptNewSocket(); } else { u_long avail = 0; if ( (ioctlsocket(m_socket, FIONREAD, \u0026avail) == SOCKET_ERROR) || (avail == 0) ) { m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } else { m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL); } } } OnRead()方法根据状态标识m_state确定一个socket是侦听的socket还是普通与客户端连接的socket，如果是侦听sokcet则接收客户端的连接；如果是与客户端连接的socket，则先检测socket上有多少字节可读，如果没有字节可读或者检测字节数时出错，则关闭socket，反之调用设置的回调函数。\nvoid CBaseSocket::OnWrite() { \\#if ((defined _WIN32) || (defined __APPLE__)) CEventDispatch::Instance()-\u003eRemoveEvent(m_socket, SOCKET_WRITE); \\#endif if (m_state == SOCKET_STATE_CONNECTING) { int error = 0; socklen_t len = sizeof(error); \\#ifdef _WIN32 getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (**char***)\u0026error, \u0026len); \\#else getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (**void***)\u0026error, \u0026len); \\#endif if (error) { m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } else { m_state = SOCKET_STATE_CONNECTED; m_callback(m_callback_data, NETLIB_MSG_CONFIRM, (net_handle_t)m_socket, NULL); } } else { m_callback(m_callback_data, NETLIB_MSG_WRITE, (net_handle_t)m_socket, NULL); } } OnWrite()函数则根据m_state标识检测socket是否是尝试连接的socket（connect函数中的socket），用于判断socket是否已经连接成功，反之则是与客户端保持连接的socket，调用预先设置的回调函数。\nvoid CBaseSocket::OnClose() { m_state = SOCKET_STATE_CLOSING; m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } OnClose()方法将标识m_state设置为需要关闭状态，并调用预先设置的回调函数。\n每个服务程序都使用一个stl hash_map来管理所有的socket，键是socket句柄，值是CBaseSocket对象指针：\ntypedef hash_map SocketMap; SocketMap\tg_socket_map; 所以在删除或者新增socket时，实际上就是从这个hash_map中删除或者向这个hash_map中增加对象。多线程操作，需要一个锁来进行保护：\nvoid CEventDispatch::AddEvent(SOCKET fd, uint8_t socket_event) { CAutoLock func_lock(\u0026m_lock); if ((socket_event \u0026 SOCKET_READ) != 0) { FD_SET(fd, \u0026m_read_set); } if ((socket_event \u0026 SOCKET_WRITE) != 0) { FD_SET(fd, \u0026m_write_set); } if ((socket_event \u0026 SOCKET_EXCEP) != 0) { FD_SET(fd, \u0026m_excep_set); } } 代码CAutoLock func_lock(\u0026m_lock);即保护该hash_map的锁对象。\n而管理以上功能的是一个单例类CEventDispatch，所以不难才出CEventDispatch提供的接口：\nclass CEventDispatch { public: virtual ~CEventDispatch(); void AddEvent(SOCKET fd, uint8_t socket_event); void RemoveEvent(SOCKET fd, uint8_t socket_event); void AddTimer(callback_t callback, void* user_data, uint64_t interval); void RemoveTimer(callback_t callback, void* user_data); void AddLoop(callback_t callback, void* user_data); void StartDispatch(uint32_t wait_timeout = 100); void StopDispatch(); bool isRunning() {return running;} static CEventDispatch* Instance(); protected: CEventDispatch(); private: void _CheckTimer(); void _CheckLoop(); typedef struct { callback_t\tcallback; void*\tuser_data; uint64_t\tinterval; uint64_t\tnext_tick; } TimerItem; private: #ifdef _WIN32 fd_set\tm_read_set; fd_set\tm_write_set; fd_set\tm_excep_set; #elif __APPLE__ int m_kqfd; #else int\tm_epfd; #endif CLock\tm_lock; list\tm_timer_list; list\tm_loop_list; static CEventDispatch* m_pEventDispatch; bool running; }; 其中StartDispatch()和StopDispatcher()分别用于启动和停止整个循环流程。一般在程序初始化的时候StartDispatch()，在程序退出时StopDispatcher()。\n下面我们以pc端登录为例来具体看一个数据包在服务器端各个服务之间走过的流程：\n步骤1：login_server初始化侦听socket，设置新连接到来的回调函数。8080端口，该端口是为http服务配置的。\n在login_server.cpp main函数中调用：\nnetlib_listen调用如下：\npSocket-\u003eListen调用：\nAddBaseSocket将该socket加入hash_map中。AddEvent设置需要关注的socket上的事件，这里只关注可读和出错事件。\n步骤2： 客户端调用connect()函数连接login_server的8080端口。\n步骤3：login_server收到连接请求后调用OnRead方法，OnRead()方法里面调用_AcceptNewSocket()，_AcceptNewSocket()接收新连接，创建新的socket，并调用之前初始化阶段netlib_listen设置的回调函数http_callback。\nvoid CBaseSocket::OnRead() { if (m_state == SOCKET_STATE_LISTENING) { _AcceptNewSocket(); } else { u_long avail = 0; if ( (ioctlsocket(m_socket, FIONREAD, \u0026avail) == SOCKET_ERROR) || (avail == 0) ) { m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } else { m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL); } } } void CBaseSocket::_AcceptNewSocket() { SOCKET fd = 0; sockaddr_in peer_addr; socklen_t addr_len = sizeof(sockaddr_in); char ip_str[64]; while ( (fd = accept(m_socket, (sockaddr*)\u0026peer_addr, \u0026addr_len)) != INVALID_SOCKET ) { CBaseSocket* pSocket = new CBaseSocket(); uint32_t ip = ntohl(peer_addr.sin_addr.s_addr); uint16_t port = ntohs(peer_addr.sin_port); snprintf(ip_str, sizeof(ip_str), \"%d.%d.%d.%d\", ip \u003e\u003e 24, (ip \u003e\u003e 16) \u0026 0xFF, (ip \u003e\u003e 8) \u0026 0xFF, ip \u0026 0xFF); log(\"AcceptNewSocket, socket=%d from %s:%d\\n\", fd, ip_str, port); pSocket-\u003eSetSocket(fd); pSocket-\u003eSetCallback(m_callback); pSocket-\u003eSetCallbackData(m_callback_data); pSocket-\u003eSetState(SOCKET_STATE_CONNECTED); pSocket-\u003eSetRemoteIP(ip_str); pSocket-\u003eSetRemotePort(port); _SetNoDelay(fd); _SetNonblock(fd); AddBaseSocket(pSocket); CEventDispatch::Instance()-\u003eAddEvent(fd, SOCKET_READ | SOCKET_EXCEP); m_callback(m_callback_data, NETLIB_MSG_CONNECT, (net_handle_t)fd, NULL); } } void http_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { if (msg == NETLIB_MSG_CONNECT) { CHttpConn* pConn = new CHttpConn(); pConn-\u003eOnConnect(handle); } else { log(\"!!!error msg: %d \", msg); } } pConn-\u003eOnConnect(handle)中设置http数据的回调函数httpconn_callback：\nvoid CHttpConn::OnConnect(net_handle_t handle) { printf(\"OnConnect, handle=%d\\n\", handle); m_sock_handle = handle; m_state = CONN_STATE_CONNECTED; g_http_conn_map.insert(make_pair(m_conn_handle, this)); netlib_option(handle, NETLIB_OPT_SET_CALLBACK, (void*)httpconn_callback); netlib_option(handle, NETLIB_OPT_SET_CALLBACK_DATA, reinterpret_cast(m_conn_handle) ); netlib_option(handle, NETLIB_OPT_GET_REMOTE_IP, (void*)\u0026m_peer_ip); } httpconn_callback中处理http可读可写出错事件：\nvoid httpconn_callback(void* callback_data, uint8_t msg, uint32_t handle, uint32_t uParam, void* pParam) { NOTUSED_ARG(uParam); NOTUSED_ARG(pParam); // convert void* to uint32_t, oops uint32_t conn_handle = *((uint32_t*)(\u0026callback_data)); CHttpConn* pConn = FindHttpConnByHandle(conn_handle); if (!pConn) { return; } switch (msg) { case NETLIB_MSG_READ: pConn-\u003eOnRead(); break; case NETLIB_MSG_WRITE: pConn-\u003eOnWrite(); break; case NETLIB_MSG_CLOSE: pConn-\u003eOnClose(); break; default: log(\"!!!httpconn_callback error msg: %d \", msg); break; } } 步骤4：客户端连接成功以后，发送http请求，方法是get，请求url：http://192.168.226.128:8080/msg_server。（具体网址与你的机器配置的网址有关）\n步骤5：login_server检测到该socket可读，调用pConn-\u003eOnRead()方法。\nvoid CHttpConn::OnRead() { for (;;) { uint32_t free_buf_len = m_in_buf.GetAllocSize() - m_in_buf.GetWriteOffset(); if (free_buf_len \u003c READ_BUF_SIZE + 1) m_in_buf.Extend(READ_BUF_SIZE + 1); int ret = netlib_recv(m_sock_handle, m_in_buf.GetBuffer() + m_in_buf.GetWriteOffset(), READ_BUF_SIZE); if (ret \u003c= 0) break; m_in_buf.IncWriteOffset(ret); m_last_recv_tick = get_tick_count(); } // 每次请求对应一个HTTP连接，所以读完数据后，不用在同一个连接里面准备读取下个请求 char* in_buf = (char*)m_in_buf.GetBuffer(); uint32_t buf_len = m_in_buf.GetWriteOffset(); in_buf[buf_len] = '\\0'; // 如果buf_len 过长可能是受到攻击，则断开连接 // 正常的url最大长度为2048，我们接受的所有数据长度不得大于1K if(buf_len \u003e 1024) { log(\"get too much data:%s \", in_buf); Close(); return; } //log(\"OnRead, buf_len=%u, conn_handle=%u\\n\", buf_len, m_conn_handle); // for debug m_cHttpParser.ParseHttpContent(in_buf, buf_len); if (m_cHttpParser.IsReadAll()) { string url = m_cHttpParser.GetUrl(); if (strncmp(url.c_str(), \"/msg_server\", 11) == 0) { string content = m_cHttpParser.GetBodyContent(); _HandleMsgServRequest(url, content); } else { log(\"url unknown, url=%s \", url.c_str()); Close(); } } } CHttpConn::OnRead()先用recv收取数据，接着解析数据，如果出错或者非法数据就关闭连接。如果客户端发送的请求的http object正好是/msg_server，则调用_HandleMsgServRequest(url, content);进行处理：\nvoid CHttpConn::_HandleMsgServRequest(string\u0026 url, string\u0026 post_data) { msg_serv_info_t* pMsgServInfo; uint32_t min_user_cnt = (uint32_t)-1; map::iterator it_min_conn = g_msg_serv_info.end(); map::iterator it; if(g_msg_serv_info.size() \u003c= 0) { Json::Value value; value[\"code\"] = 1; value[\"msg\"] = \"没有msg_server\"; string strContent = value.toStyledString(); char* szContent = new char[HTTP_RESPONSE_HTML_MAX]; snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, strContent.length(), strContent.c_str()); Send((void*)szContent, strlen(szContent)); delete [] szContent; return ; } for (it = g_msg_serv_info.begin() ; it != g_msg_serv_info.end(); it++) { pMsgServInfo = it-\u003esecond; if ( (pMsgServInfo-\u003ecur_conn_cnt \u003c pMsgServInfo-\u003emax_conn_cnt) \u0026\u0026 (pMsgServInfo-\u003ecur_conn_cnt \u003c min_user_cnt)) { it_min_conn = it; min_user_cnt = pMsgServInfo-\u003ecur_conn_cnt; } } if (it_min_conn == g_msg_serv_info.end()) { log(\"All TCP MsgServer are full \"); Json::Value value; value[\"code\"] = 2; value[\"msg\"] = \"负载过高\"; string strContent = value.toStyledString(); char* szContent = new char[HTTP_RESPONSE_HTML_MAX]; snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, strContent.length(), strContent.c_str()); Send((void*)szContent, strlen(szContent)); delete [] szContent; return; } else { Json::Value value; value[\"code\"] = 0; value[\"msg\"] = \"\"; if(pIpParser-\u003eisTelcome(GetPeerIP())) { value[\"priorIP\"] = string(it_min_conn-\u003esecond-\u003eip_addr1); value[\"backupIP\"] = string(it_min_conn-\u003esecond-\u003eip_addr2); value[\"msfsPrior\"] = strMsfsUrl; value[\"msfsBackup\"] = strMsfsUrl; } else { value[\"priorIP\"] = string(it_min_conn-\u003esecond-\u003eip_addr2); value[\"backupIP\"] = string(it_min_conn-\u003esecond-\u003eip_addr1); value[\"msfsPrior\"] = strMsfsUrl; value[\"msfsBackup\"] = strMsfsUrl; } value[\"discovery\"] = strDiscovery; value[\"port\"] = int2string(it_min_conn-\u003esecond-\u003eport); string strContent = value.toStyledString(); char* szContent = new char[HTTP_RESPONSE_HTML_MAX]; uint32_t nLen = strContent.length(); snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, nLen, strContent.c_str()); Send((void*)szContent, strlen(szContent)); delete [] szContent; return; } } 该方法根据客户端ip地址将msg_server的地址组装成json格式，返回给客户端。json格式内容如下：\n{ \"backupIP\" : \"localhost\", \"code\" : 0, \"discovery\" : \"http://192.168.226.128/api/discovery\", \"msfsBackup\" : \"http://192.168.226.128:8700/\", \"msfsPrior\" : \"http://192.168.226.128:8700/\", \"msg\" : \"\", \"port\" : \"8000\", \"priorIP\" : \"localhost\" } 注意，发送数据给客户端调用的是Send方法，该方法会先尝试着调用底层的send()函数去发送，如果不能全部发送出去，则将剩余数据加入到对应的写数据缓冲区内。这样这些数据会在该socket可写时再继续发送。这是也是设计网络通信库一个通用的技巧，即先试着去send，如果send不了，将数据放入待发送缓冲区内，并设置检测可写标识位，当socket可写时，从待发送缓冲区取出数据发送出去。如果还是不能全部发送出去，继续设置检测可写标识位，下次再次发送，如此循环一直到所有数据都发送出去为止。\nint CHttpConn::Send(void* data, int len) { m_last_send_tick = get_tick_count(); if (m_busy) { m_out_buf.Write(data, len); return len; } int ret = netlib_send(m_sock_handle, data, len); if (ret \u003c 0) ret = 0; if (ret \u003c len) { m_out_buf.Write((char*)data + ret, len - ret); m_busy = true; //log(\"not send all, remain=%d\\n\", m_out_buf.GetWriteOffset()); } else { OnWriteComlete(); } return len; } 当然，由于这里http设置成了短连接，每次应答完客户度之后立即关闭连接，在OnWriteComplete()里面：\nvoid CHttpConn::OnWriteComlete() { log(\"write complete \"); Close(); } 步骤6：客户端收到http请求的应答后，根据收到的json得到msg_server的ip地址，这里是ip地址是192.168.226.128，端口号是8000。客户端开始连接这个ip地址和端口号，连接过程与msg_server接收连接过程与上面的步骤相同。接着客户端给服务器发送登录数据包。\n步骤7：msg_server收到登录请求后，在CImConn::OnRead()收取数据，解包，调用子类CMsgConn重写的HandlePdu，处理登录请求，如何处理呢？处理如下：\n//MsgConn.cpp void CMsgConn::HandlePdu(CImPdu* pPdu) { // request authorization check if (pPdu-\u003eGetCommandId() != CID_LOGIN_REQ_USERLOGIN \u0026\u0026 !IsOpen() \u0026\u0026 IsKickOff()) { log(\"HandlePdu, wrong msg. \"); throw CPduException(pPdu-\u003eGetServiceId(), pPdu-\u003eGetCommandId(), ERROR_CODE_WRONG_SERVICE_ID, \"HandlePdu error, user not login. \"); return; } switch (pPdu-\u003eGetCommandId()) { case CID_OTHER_HEARTBEAT: _HandleHeartBeat(pPdu); break; case CID_LOGIN_REQ_USERLOGIN: _HandleLoginRequest(pPdu ); break; case CID_LOGIN_REQ_LOGINOUT: _HandleLoginOutRequest(pPdu); break; case CID_LOGIN_REQ_DEVICETOKEN: _HandleClientDeviceToken(pPdu); break; case CID_LOGIN_REQ_KICKPCCLIENT: _HandleKickPCClient(pPdu); break; case CID_LOGIN_REQ_PUSH_SHIELD: _HandlePushShieldRequest(pPdu); break; case CID_LOGIN_REQ_QUERY_PUSH_SHIELD: _HandleQueryPushShieldRequest(pPdu); break; case CID_MSG_DATA: _HandleClientMsgData(pPdu); break; case CID_MSG_DATA_ACK: _HandleClientMsgDataAck(pPdu); break; case CID_MSG_TIME_REQUEST: _HandleClientTimeRequest(pPdu); break; case CID_MSG_LIST_REQUEST: _HandleClientGetMsgListRequest(pPdu); break; case CID_MSG_GET_BY_MSG_ID_REQ: _HandleClientGetMsgByMsgIdRequest(pPdu); break; case CID_MSG_UNREAD_CNT_REQUEST: _HandleClientUnreadMsgCntRequest(pPdu ); break; case CID_MSG_READ_ACK: _HandleClientMsgReadAck(pPdu); break; case CID_MSG_GET_LATEST_MSG_ID_REQ: _HandleClientGetLatestMsgIDReq(pPdu); break; case CID_SWITCH_P2P_CMD: _HandleClientP2PCmdMsg(pPdu ); break; case CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST: _HandleClientRecentContactSessionRequest(pPdu); break; case CID_BUDDY_LIST_USER_INFO_REQUEST: _HandleClientUserInfoRequest( pPdu ); break; case CID_BUDDY_LIST_REMOVE_SESSION_REQ: _HandleClientRemoveSessionRequest( pPdu ); break; case CID_BUDDY_LIST_ALL_USER_REQUEST: _HandleClientAllUserRequest(pPdu ); break; case CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST: _HandleChangeAvatarRequest(pPdu); break; case CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST: _HandleChangeSignInfoRequest(pPdu); break; case CID_BUDDY_LIST_USERS_STATUS_REQUEST: _HandleClientUsersStatusRequest(pPdu); break; case CID_BUDDY_LIST_DEPARTMENT_REQUEST: _HandleClientDepartmentRequest(pPdu); break; // for group process case CID_GROUP_NORMAL_LIST_REQUEST: s_group_chat-\u003eHandleClientGroupNormalRequest(pPdu, this); break; case CID_GROUP_INFO_REQUEST: s_group_chat-\u003eHandleClientGroupInfoRequest(pPdu, this); break; case CID_GROUP_CREATE_REQUEST: s_group_chat-\u003eHandleClientGroupCreateRequest(pPdu, this); break; case CID_GROUP_CHANGE_MEMBER_REQUEST: s_group_chat-\u003eHandleClientGroupChangeMemberRequest(pPdu, this); break; case CID_GROUP_SHIELD_GROUP_REQUEST: s_group_chat-\u003eHandleClientGroupShieldGroupRequest(pPdu, this); break; case CID_FILE_REQUEST: s_file_handler-\u003eHandleClientFileRequest(this, pPdu); break; case CID_FILE_HAS_OFFLINE_REQ: s_file_handler-\u003eHandleClientFileHasOfflineReq(this, pPdu); break; case CID_FILE_ADD_OFFLINE_REQ: s_file_handler-\u003eHandleClientFileAddOfflineReq(this, pPdu); break; case CID_FILE_DEL_OFFLINE_REQ: s_file_handler-\u003eHandleClientFileDelOfflineReq(this, pPdu); break; default: log(\"wrong msg, cmd id=%d, user id=%u. \", pPdu-\u003eGetCommandId(), GetUserId()); break; } } 分支case CID_LOGIN_REQ_USERLOGIN即处理登录请求：\n//在MsgConn.cpp中 void CMsgConn::_HandleLoginRequest(CImPdu* pPdu) { // refuse second validate request if (m_login_name.length() != 0) { log(\"duplicate LoginRequest in the same conn \"); return; } // check if all server connection are OK uint32_t result = 0; string result_string = \"\"; CDBServConn* pDbConn = get_db_serv_conn_for_login(); if (!pDbConn) { result = IM::BaseDefine::REFUSE_REASON_NO_DB_SERVER; result_string = \"服务端异常\"; } else if (!is_login_server_available()) { result = IM::BaseDefine::REFUSE_REASON_NO_LOGIN_SERVER; result_string = \"服务端异常\"; } else if (!is_route_server_available()) { result = IM::BaseDefine::REFUSE_REASON_NO_ROUTE_SERVER; result_string = \"服务端异常\"; } if (result) { IM::Login::IMLoginRes msg; msg.set_server_time(time(NULL)); msg.set_result_code((IM::BaseDefine::ResultType)result); msg.set_result_string(result_string); CImPdu pdu; pdu.SetPBMsg(\u0026msg); pdu.SetServiceId(SID_LOGIN); pdu.SetCommandId(CID_LOGIN_RES_USERLOGIN); pdu.SetSeqNum(pPdu-\u003eGetSeqNum()); SendPdu(\u0026pdu); Close(); return; } IM::Login::IMLoginReq msg; CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength())); //假如是汉字，则转成拼音 m_login_name = msg.user_name(); string password = msg.password(); uint32_t online_status = msg.online_status(); if (online_status \u003c IM::BaseDefine::USER_STATUS_ONLINE || online_status \u003e IM::BaseDefine::USER_STATUS_LEAVE) { log(\"HandleLoginReq, online status wrong: %u \", online_status); online_status = IM::BaseDefine::USER_STATUS_ONLINE; } m_client_version = msg.client_version(); m_client_type = msg.client_type(); m_online_status = online_status; log(\"HandleLoginReq, user_name=%s, status=%u, client_type=%u, client=%s, \", m_login_name.c_str(), online_status, m_client_type, m_client_version.c_str()); CImUser* pImUser = CImUserManager::GetInstance()-\u003eGetImUserByLoginName(GetLoginName()); if (!pImUser) { pImUser = new CImUser(GetLoginName()); CImUserManager::GetInstance()-\u003eAddImUserByLoginName(GetLoginName(), pImUser); } pImUser-\u003eAddUnValidateMsgConn(this); CDbAttachData attach_data(ATTACH_TYPE_HANDLE, m_handle, 0); // continue to validate if the user is OK IM::Server::IMValidateReq msg2; msg2.set_user_name(msg.user_name()); msg2.set_password(password); msg2.set_attach_data(attach_data.GetBuffer(), attach_data.GetLength()); CImPdu pdu; pdu.SetPBMsg(\u0026msg2); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_VALIDATE_REQ); pdu.SetSeqNum(pPdu-\u003eGetSeqNum()); pDbConn-\u003eSendPdu(\u0026pdu); } ",
  "wordCount" : "1484",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/74f8790b79af42ab856a668b8927b38a/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      03 服务器端的程序架构介绍
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#03-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af%e7%9a%84%e7%a8%8b%e5%ba%8f%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d" aria-label="03 服务器端的程序架构介绍">03 服务器端的程序架构介绍</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="03-服务器端的程序架构介绍">03 服务器端的程序架构介绍</h1>
<p>通过上一节的编译与部署，我们会得到TeamTalk服务器端以下部署程序：</p>
<pre tabindex="0"><code>db_proxy_server
file_server
http_msg_server
login_server
msfs
msg_server
push_server
router_server
</code></pre><p>这些服务构成的拓扑图如下：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/181c77214dc29e05e297dc9f93774fa1.jpeg" alt=""  />
</p>
<p>各个服务程序的作用描述如下：</p>
<ul>
<li>LoginServer (C++): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用</li>
<li>MsgServer (C++): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等</li>
<li>RouteServer (C++): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能</li>
<li>FileServer (C++): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输</li>
<li>MsfsServer (C++): 图片存储服务器，提供头像，图片传输中的图片存储服务</li>
<li>DBProxy (C++): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互</li>
<li>HttpMsgServer(C++) :对外接口服务器，提供对外接口功能。（目前只是框架）</li>
<li>PushServer(C++): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns）</li>
</ul>
<p>注意：上图中并没有push_server和http_push_server。如果你不调试ios版本的客户端，可以暂且不启动push_server，另外http_push_server也可以暂不启动。</p>
<p>启动顺序：</p>
<p>一般来说，前端的服务会依赖后端的服务，所以一般先启动后端服务，再启动前端服务。建议按以下顺序启动服务：</p>
<pre tabindex="0"><code>1、启动db_proxy。
2、启动route_server，file_server，msfs
3、启动login_server
4、启动msg_server
</code></pre><p>那么我就按照服务端的启动顺序去讲解服务端的一个流程概述。
第一步:启动db_proxy后，db_proxy会去根据配置文件连接相应的MySQL实例，以及redis实例。
第二步:启动route_server,file_server,msfs后，各个服务端都会开始监听相应的端口。
第三步:启动login_server,login_server就开始监听相应的端口(8080)，等待客户端的连接，而分配一个负载相对较小的msg_server给客户端。
第四步:启动msg_server(端口8000)，msg_server启动后，会去主动连接route_server，login_server，db_proxy_server，会将自己的监听的端口信息注册到login_server去，同时在用户上线，下线的时候会将自己的负载情况汇报给login_server.</p>
<blockquote>
<p>各个服务的端口号 (注意：如果出现部署完成后但是服务进程启动有问题或者只有部分服务进程启动了，请查看相应的log日志，请查看相应的log日志，请查看相应的log日志。)</p>
</blockquote>
<table>
<thead>
<tr>
<th>服务</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>login_server</td>
<td>8080/8008</td>
</tr>
<tr>
<td>msg_server</td>
<td>8000</td>
</tr>
<tr>
<td>db_proxy_server</td>
<td>10600</td>
</tr>
<tr>
<td>route_server</td>
<td>8200</td>
</tr>
<tr>
<td>http_msg_server</td>
<td>8400</td>
</tr>
<tr>
<td>file_server</td>
<td>8600/8601</td>
</tr>
</tbody>
</table>
<p>服务网络通信框架介绍：</p>
<p>上面介绍的每一个服务都使用了相同的网络通信框架，该通信框架可以单独拿出来做为一个通用的网络通信框架。该网络框架是在一个循环里面不断地检测IO事件，然后对检测到的事件进行处理。流程如下：</p>
<ol>
<li>
<p>使用IO复用技术（linux和windows平台用select、mac平台用kevent）分离网络IO。</p>
</li>
<li>
<p>对分离出来的网络IO进行操作，分为socket句柄可读、可写和出错三种情况。</p>
</li>
</ol>
<p>当然再加上定时器事件，即检测一个定时器事件列表，如果有定时器到期，则执行该定时器事件。</p>
<p>整个框架的伪码大致如下：</p>
<pre tabindex="0"><code>while (running) 
{ 
    //处理定时器事件 
    _CheckTimer(); 

    //IO multiplexing 
    int n = select(socket集合, ...); 

    //事件处理 
     **if** (某些socket可读) 
     { 
         pSocket-&gt;OnRead(); 
     } 

     **if** (某些socket可写) 
     { 
         pSocket-&gt;OnWrite(); 
     } 

     **if** (某些socket出错) 
     { 
         pSocket-&gt;OnClose(); 
     } 
 } 
</code></pre><p>处理定时器事件的代码如下：</p>
<pre tabindex="0"><code>void CEventDispatch::_CheckTimer() 
{ 
    uint64_t curr_tick = get_tick_count(); 
    list&lt;TimerItem*&gt;::iterator it; 

    for (it = m_timer_list.begin(); it != m_timer_list.end(); ) 
    { 
        TimerItem* pItem = *it; 
        // iterator maybe deleted in the callback, so we should increment it before callback 
        it++;    
        if(curr_tick &gt;= pItem-&gt;next_tick) 
        { 
            pItem-&gt;next_tick += pItem-&gt;interval; 
            pItem-&gt;callback(pItem-&gt;user_data, NETLIB_MSG_TIMER, 0, NULL); 
        } 
     } 
} 
</code></pre><p>即遍历一个定时器列表，将定时器对象与当前时间（curr_tick）做比较，如果当前时间已经大于或等于定时器设置的时间，则表明定时器时间已经到了，执行定时器对象对应的回调函数。</p>
<p>在来看看OnRead、OnWrite和OnClose这三个函数。在TeamTalk源码中每一个socket连接被封装成一个CBaseSocket对象，该对象是一个使用引用计数的类的子类，通过这种方法来实现生存期自动管理。</p>
<pre tabindex="0"><code>void CBaseSocket::OnRead() 
{ 
    if (m_state == SOCKET_STATE_LISTENING) 
    { 
		_AcceptNewSocket(); 
    } 
    else 
    { 
        u_long avail = 0; 
        if ( (ioctlsocket(m_socket, FIONREAD, &amp;avail) == SOCKET_ERROR) || (avail == 0) ) 
        { 
        	m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); 
        } 
        else 
        { 
            m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL); 
        } 
    } 
} 
</code></pre><p>OnRead()方法根据状态标识m_state确定一个socket是侦听的socket还是普通与客户端连接的socket，如果是侦听sokcet则接收客户端的连接；如果是与客户端连接的socket，则先检测socket上有多少字节可读，如果没有字节可读或者检测字节数时出错，则关闭socket，反之调用设置的回调函数。</p>
<pre tabindex="0"><code>void CBaseSocket::OnWrite() 
{ 
\#if ((defined _WIN32) || (defined __APPLE__)) 
	CEventDispatch::Instance()-&gt;RemoveEvent(m_socket, SOCKET_WRITE); 
\#endif 

    if (m_state == SOCKET_STATE_CONNECTING) 
    { 
        int error = 0; 
        socklen_t len = sizeof(error); 
\#ifdef _WIN32 
        getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (**char***)&amp;error, &amp;len); 
\#else 
        getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (**void***)&amp;error, &amp;len); 
\#endif 
        if (error) { 
        	m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); 
        } else { 
        	m_state = SOCKET_STATE_CONNECTED; 
        	m_callback(m_callback_data, NETLIB_MSG_CONFIRM, (net_handle_t)m_socket, NULL); 
        } 
    } 
    else 
    { 
    	m_callback(m_callback_data, NETLIB_MSG_WRITE, (net_handle_t)m_socket, NULL); 
    } 
} 
</code></pre><p>OnWrite()函数则根据m_state标识检测socket是否是尝试连接的socket（connect函数中的socket），用于判断socket是否已经连接成功，反之则是与客户端保持连接的socket，调用预先设置的回调函数。</p>
<pre tabindex="0"><code>void CBaseSocket::OnClose()
{
	m_state = SOCKET_STATE_CLOSING;
	m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL);
}
</code></pre><p>OnClose()方法将标识m_state设置为需要关闭状态，并调用预先设置的回调函数。</p>
<p>每个服务程序都使用一个stl hash_map来管理所有的socket，键是socket句柄，值是CBaseSocket对象指针：</p>
<pre tabindex="0"><code>typedef hash_map&lt;net_handle_t, CBaseSocket*&gt; SocketMap;
SocketMap	g_socket_map;
</code></pre><p>所以在删除或者新增socket时，实际上就是从这个hash_map中删除或者向这个hash_map中增加对象。多线程操作，需要一个锁来进行保护：</p>
<pre tabindex="0"><code>void CEventDispatch::AddEvent(SOCKET fd, uint8_t socket_event)
{
	CAutoLock func_lock(&amp;m_lock);
 
	if ((socket_event &amp; SOCKET_READ) != 0)
	{
		FD_SET(fd, &amp;m_read_set);
	}
		
	if ((socket_event &amp; SOCKET_WRITE) != 0)
	{
		FD_SET(fd, &amp;m_write_set);
	}
 
	if ((socket_event &amp; SOCKET_EXCEP) != 0)
	{
		FD_SET(fd, &amp;m_excep_set);
	}
}
</code></pre><p>代码CAutoLock func_lock(&amp;m_lock);即保护该hash_map的锁对象。</p>
<p>而管理以上功能的是一个单例类CEventDispatch，所以不难才出CEventDispatch提供的接口：</p>
<pre tabindex="0"><code>class CEventDispatch
{
public:
	virtual ~CEventDispatch();
 
	void AddEvent(SOCKET fd, uint8_t socket_event);
	void RemoveEvent(SOCKET fd, uint8_t socket_event);
 
	void AddTimer(callback_t callback, void* user_data, uint64_t interval);
	void RemoveTimer(callback_t callback, void* user_data);
    
    void AddLoop(callback_t callback, void* user_data);
 
	void StartDispatch(uint32_t wait_timeout = 100);
    void StopDispatch();
    
    bool isRunning() {return running;}
 
	static CEventDispatch* Instance();
protected:
	CEventDispatch();
 
private:
	void _CheckTimer();
    void _CheckLoop();
 
	typedef struct {
		callback_t	callback;
		void*		user_data;
		uint64_t	interval;
		uint64_t	next_tick;
	} TimerItem;
 
private:
#ifdef _WIN32
	fd_set	m_read_set;
	fd_set	m_write_set;
	fd_set	m_excep_set;
#elif __APPLE__
	int 	m_kqfd;
#else
	int		m_epfd;
#endif
	CLock			m_lock;
	list&lt;TimerItem*&gt;	m_timer_list;
	list&lt;TimerItem*&gt;	m_loop_list;
 
	static CEventDispatch* m_pEventDispatch;
    
    bool running;
};
</code></pre><p>其中StartDispatch()和StopDispatcher()分别用于启动和停止整个循环流程。一般在程序初始化的时候StartDispatch()，在程序退出时StopDispatcher()。</p>
<p>下面我们以pc端登录为例来具体看一个数据包在服务器端各个服务之间走过的流程：</p>
<p>步骤1：login_server初始化侦听socket，设置新连接到来的回调函数。8080端口，该端口是为http服务配置的。</p>
<p>在login_server.cpp main函数中调用：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/fe51ee95ebf85f9a7597b7262de9f183.png" alt=""  />
</p>
<p>netlib_listen调用如下：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/8d86a839a68fcc66cb7c199ef3c4c114.png" alt=""  />
</p>
<p>pSocket-&gt;Listen调用：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/8409dda4414708e79fce531309c706b4.png" alt=""  />
</p>
<p>AddBaseSocket将该socket加入hash_map中。AddEvent设置需要关注的socket上的事件，这里只关注可读和出错事件。</p>
<p>步骤2： 客户端调用connect()函数连接login_server的8080端口。</p>
<p>步骤3：login_server收到连接请求后调用OnRead方法，OnRead()方法里面调用_AcceptNewSocket()，_AcceptNewSocket()接收新连接，创建新的socket，并调用之前初始化阶段netlib_listen设置的回调函数http_callback。</p>
<pre tabindex="0"><code>void CBaseSocket::OnRead()
{
	if (m_state == SOCKET_STATE_LISTENING)
	{
		_AcceptNewSocket();
	}
	else
	{
		u_long avail = 0;
		if ( (ioctlsocket(m_socket, FIONREAD, &amp;avail) == SOCKET_ERROR) || (avail == 0) )
		{
			m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL);
		}
		else
		{
			m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL);
		}
	}
}
</code></pre><pre tabindex="0"><code>void CBaseSocket::_AcceptNewSocket()
{
	SOCKET fd = 0;
	sockaddr_in peer_addr;
	socklen_t addr_len = sizeof(sockaddr_in);
	char ip_str[64];
	while ( (fd = accept(m_socket, (sockaddr*)&amp;peer_addr, &amp;addr_len)) != INVALID_SOCKET )
	{
		CBaseSocket* pSocket = new CBaseSocket();
		uint32_t ip = ntohl(peer_addr.sin_addr.s_addr);
		uint16_t port = ntohs(peer_addr.sin_port);
 
		snprintf(ip_str, sizeof(ip_str), &#34;%d.%d.%d.%d&#34;, ip &gt;&gt; 24, (ip &gt;&gt; 16) &amp; 0xFF, (ip &gt;&gt; 8) &amp; 0xFF, ip &amp; 0xFF);
 
		log(&#34;AcceptNewSocket, socket=%d from %s:%d\n&#34;, fd, ip_str, port);
 
		pSocket-&gt;SetSocket(fd);
		pSocket-&gt;SetCallback(m_callback);
		pSocket-&gt;SetCallbackData(m_callback_data);
		pSocket-&gt;SetState(SOCKET_STATE_CONNECTED);
		pSocket-&gt;SetRemoteIP(ip_str);
		pSocket-&gt;SetRemotePort(port);
 
		_SetNoDelay(fd);
		_SetNonblock(fd);
		AddBaseSocket(pSocket);
		CEventDispatch::Instance()-&gt;AddEvent(fd, SOCKET_READ | SOCKET_EXCEP);
		m_callback(m_callback_data, NETLIB_MSG_CONNECT, (net_handle_t)fd, NULL);
	}
}
</code></pre><pre tabindex="0"><code>void http_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam)
{
    if (msg == NETLIB_MSG_CONNECT)
    {
        CHttpConn* pConn = new CHttpConn();
        pConn-&gt;OnConnect(handle);
    }
    else
    {
        log(&#34;!!!error msg: %d &#34;, msg);
    }
}
</code></pre><p>pConn-&gt;OnConnect(handle)中设置http数据的回调函数httpconn_callback：</p>
<pre tabindex="0"><code>void CHttpConn::OnConnect(net_handle_t handle)
{
    printf(&#34;OnConnect, handle=%d\n&#34;, handle);
    m_sock_handle = handle;
    m_state = CONN_STATE_CONNECTED;
    g_http_conn_map.insert(make_pair(m_conn_handle, this));
    
    netlib_option(handle, NETLIB_OPT_SET_CALLBACK, (void*)httpconn_callback);
    netlib_option(handle, NETLIB_OPT_SET_CALLBACK_DATA, reinterpret_cast&lt;void *&gt;(m_conn_handle) );
    netlib_option(handle, NETLIB_OPT_GET_REMOTE_IP, (void*)&amp;m_peer_ip);
}
</code></pre><p>httpconn_callback中处理http可读可写出错事件：</p>
<pre tabindex="0"><code>void httpconn_callback(void* callback_data, uint8_t msg, uint32_t handle, uint32_t uParam, void* pParam)
{
	NOTUSED_ARG(uParam);
	NOTUSED_ARG(pParam);
 
	// convert void* to uint32_t, oops
	uint32_t conn_handle = *((uint32_t*)(&amp;callback_data));
    CHttpConn* pConn = FindHttpConnByHandle(conn_handle);
    if (!pConn) {
        return;
    }
 
	switch (msg)
	{
	case NETLIB_MSG_READ:
		pConn-&gt;OnRead();
		break;
	case NETLIB_MSG_WRITE:
		pConn-&gt;OnWrite();
		break;
	case NETLIB_MSG_CLOSE:
		pConn-&gt;OnClose();
		break;
	default:
		log(&#34;!!!httpconn_callback error msg: %d &#34;, msg);
		break;
	}
}
</code></pre><p>步骤4：客户端连接成功以后，发送http请求，方法是get，请求url：http://192.168.226.128:8080/msg_server。（具体网址与你的机器配置的网址有关）</p>
<p>步骤5：login_server检测到该socket可读，调用pConn-&gt;OnRead()方法。</p>
<pre tabindex="0"><code>void CHttpConn::OnRead()
{
	for (;;)
	{
		uint32_t free_buf_len = m_in_buf.GetAllocSize() - m_in_buf.GetWriteOffset();
		if (free_buf_len &lt; READ_BUF_SIZE + 1)
			m_in_buf.Extend(READ_BUF_SIZE + 1);
 
		int ret = netlib_recv(m_sock_handle, m_in_buf.GetBuffer() + m_in_buf.GetWriteOffset(), READ_BUF_SIZE);
		if (ret &lt;= 0)
			break;
 
		m_in_buf.IncWriteOffset(ret);
 
		m_last_recv_tick = get_tick_count();
	}
 
	// 每次请求对应一个HTTP连接，所以读完数据后，不用在同一个连接里面准备读取下个请求
	char* in_buf = (char*)m_in_buf.GetBuffer();
	uint32_t buf_len = m_in_buf.GetWriteOffset();
	in_buf[buf_len] = &#39;\0&#39;;
    
    // 如果buf_len 过长可能是受到攻击，则断开连接
    // 正常的url最大长度为2048，我们接受的所有数据长度不得大于1K
    if(buf_len &gt; 1024)
    {
        log(&#34;get too much data:%s &#34;, in_buf);
        Close();
        return;
    }
 
	//log(&#34;OnRead, buf_len=%u, conn_handle=%u\n&#34;, buf_len, m_conn_handle); // for debug
 
	
	m_cHttpParser.ParseHttpContent(in_buf, buf_len);
 
	if (m_cHttpParser.IsReadAll()) {
		string url =  m_cHttpParser.GetUrl();
		if (strncmp(url.c_str(), &#34;/msg_server&#34;, 11) == 0) {
            string content = m_cHttpParser.GetBodyContent();
            _HandleMsgServRequest(url, content);
		} else {
			log(&#34;url unknown, url=%s &#34;, url.c_str());
			Close();
		}
	}
}
</code></pre><p>CHttpConn::OnRead()先用recv收取数据，接着解析数据，如果出错或者非法数据就关闭连接。如果客户端发送的请求的http object正好是/msg_server，则调用_HandleMsgServRequest(url, content);进行处理：</p>
<pre tabindex="0"><code>void CHttpConn::_HandleMsgServRequest(string&amp; url, string&amp; post_data)
{
    msg_serv_info_t* pMsgServInfo;
    uint32_t min_user_cnt = (uint32_t)-1;
    map&lt;uint32_t, msg_serv_info_t*&gt;::iterator it_min_conn = g_msg_serv_info.end();
    map&lt;uint32_t, msg_serv_info_t*&gt;::iterator it;
    if(g_msg_serv_info.size() &lt;= 0)
    {
        Json::Value value;
        value[&#34;code&#34;] = 1;
        value[&#34;msg&#34;] = &#34;没有msg_server&#34;;
        string strContent = value.toStyledString();
        char* szContent = new char[HTTP_RESPONSE_HTML_MAX];
        snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, strContent.length(), strContent.c_str());
        Send((void*)szContent, strlen(szContent));
        delete [] szContent;
        return ;
    }
    
    for (it = g_msg_serv_info.begin() ; it != g_msg_serv_info.end(); it++) {
        pMsgServInfo = it-&gt;second;
        if ( (pMsgServInfo-&gt;cur_conn_cnt &lt; pMsgServInfo-&gt;max_conn_cnt) &amp;&amp;
            (pMsgServInfo-&gt;cur_conn_cnt &lt; min_user_cnt)) {
            it_min_conn = it;
            min_user_cnt = pMsgServInfo-&gt;cur_conn_cnt;
        }
    }
    
    if (it_min_conn == g_msg_serv_info.end()) {
        log(&#34;All TCP MsgServer are full &#34;);
        Json::Value value;
        value[&#34;code&#34;] = 2;
        value[&#34;msg&#34;] = &#34;负载过高&#34;;
        string strContent = value.toStyledString();
        char* szContent = new char[HTTP_RESPONSE_HTML_MAX];
        snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, strContent.length(), strContent.c_str());
        Send((void*)szContent, strlen(szContent));
        delete [] szContent;
        return;
    } else {
        Json::Value value;
        value[&#34;code&#34;] = 0;
        value[&#34;msg&#34;] = &#34;&#34;;
        if(pIpParser-&gt;isTelcome(GetPeerIP()))
        {
            value[&#34;priorIP&#34;] = string(it_min_conn-&gt;second-&gt;ip_addr1);
            value[&#34;backupIP&#34;] = string(it_min_conn-&gt;second-&gt;ip_addr2);
            value[&#34;msfsPrior&#34;] = strMsfsUrl;
            value[&#34;msfsBackup&#34;] = strMsfsUrl;
        }
        else
        {
            value[&#34;priorIP&#34;] = string(it_min_conn-&gt;second-&gt;ip_addr2);
            value[&#34;backupIP&#34;] = string(it_min_conn-&gt;second-&gt;ip_addr1);
            value[&#34;msfsPrior&#34;] = strMsfsUrl;
            value[&#34;msfsBackup&#34;] = strMsfsUrl;
        }
        value[&#34;discovery&#34;] = strDiscovery;
        value[&#34;port&#34;] = int2string(it_min_conn-&gt;second-&gt;port);
        string strContent = value.toStyledString();
        char* szContent = new char[HTTP_RESPONSE_HTML_MAX];
        uint32_t nLen = strContent.length();
        snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, nLen, strContent.c_str());
        Send((void*)szContent, strlen(szContent));
        delete [] szContent;
        return;
    }
}
</code></pre><p>该方法根据客户端ip地址将msg_server的地址组装成json格式，返回给客户端。json格式内容如下：</p>
<pre tabindex="0"><code>{
    &#34;backupIP&#34; : &#34;localhost&#34;,
    &#34;code&#34; : 0,
    &#34;discovery&#34; : &#34;http://192.168.226.128/api/discovery&#34;,
    &#34;msfsBackup&#34; : &#34;http://192.168.226.128:8700/&#34;,
    &#34;msfsPrior&#34; : &#34;http://192.168.226.128:8700/&#34;,
    &#34;msg&#34; : &#34;&#34;,
    &#34;port&#34; : &#34;8000&#34;,
    &#34;priorIP&#34; : &#34;localhost&#34;
}
</code></pre><p>注意，发送数据给客户端调用的是Send方法，该方法会先尝试着调用底层的send()函数去发送，如果不能全部发送出去，则将剩余数据加入到对应的写数据缓冲区内。这样这些数据会在该socket可写时再继续发送。这是也是设计网络通信库一个通用的技巧，即先试着去send，如果send不了，将数据放入待发送缓冲区内，并设置检测可写标识位，当socket可写时，从待发送缓冲区取出数据发送出去。如果还是不能全部发送出去，继续设置检测可写标识位，下次再次发送，如此循环一直到所有数据都发送出去为止。</p>
<pre tabindex="0"><code>int CHttpConn::Send(void* data, int len)
{
	m_last_send_tick = get_tick_count();
 
	if (m_busy)
	{
		m_out_buf.Write(data, len);
		return len;
	}
 
	int ret = netlib_send(m_sock_handle, data, len);
	if (ret &lt; 0)
		ret = 0;
 
	if (ret &lt; len)
	{
		m_out_buf.Write((char*)data + ret, len - ret);
		m_busy = true;
		//log(&#34;not send all, remain=%d\n&#34;, m_out_buf.GetWriteOffset());
	}
    else
    {
        OnWriteComlete();
    }
 
	return len;
}
</code></pre><p>当然，由于这里http设置成了短连接，每次应答完客户度之后立即关闭连接，在OnWriteComplete()里面：</p>
<pre tabindex="0"><code>void CHttpConn::OnWriteComlete()
{
    log(&#34;write complete &#34;);
    Close();
}
</code></pre><p>步骤6：客户端收到http请求的应答后，根据收到的json得到msg_server的ip地址，这里是ip地址是192.168.226.128，端口号是8000。客户端开始连接这个ip地址和端口号，连接过程与msg_server接收连接过程与上面的步骤相同。接着客户端给服务器发送登录数据包。</p>
<p>步骤7：msg_server收到登录请求后，在CImConn::OnRead()收取数据，解包，调用子类CMsgConn重写的HandlePdu，处理登录请求，如何处理呢？处理如下：</p>
<pre tabindex="0"><code>//MsgConn.cpp
void CMsgConn::HandlePdu(CImPdu* pPdu)
{
	// request authorization check
	if (pPdu-&gt;GetCommandId() != CID_LOGIN_REQ_USERLOGIN &amp;&amp; !IsOpen() &amp;&amp; IsKickOff()) {
        log(&#34;HandlePdu, wrong msg. &#34;);
        throw CPduException(pPdu-&gt;GetServiceId(), pPdu-&gt;GetCommandId(), ERROR_CODE_WRONG_SERVICE_ID, &#34;HandlePdu error, user not login. &#34;);
		return;
    }
	switch (pPdu-&gt;GetCommandId()) {
        case CID_OTHER_HEARTBEAT:
            _HandleHeartBeat(pPdu);
            break;
        case CID_LOGIN_REQ_USERLOGIN:
            _HandleLoginRequest(pPdu );
            break;
        case CID_LOGIN_REQ_LOGINOUT:
            _HandleLoginOutRequest(pPdu);
            break;
        case CID_LOGIN_REQ_DEVICETOKEN:
            _HandleClientDeviceToken(pPdu);
            break;
        case CID_LOGIN_REQ_KICKPCCLIENT:
            _HandleKickPCClient(pPdu);
            break;
        case CID_LOGIN_REQ_PUSH_SHIELD:
            _HandlePushShieldRequest(pPdu);
            break;
            
        case CID_LOGIN_REQ_QUERY_PUSH_SHIELD:
            _HandleQueryPushShieldRequest(pPdu);
            break;
        case CID_MSG_DATA:
            _HandleClientMsgData(pPdu);
            break;
        case CID_MSG_DATA_ACK:
            _HandleClientMsgDataAck(pPdu);
            break;
        case CID_MSG_TIME_REQUEST:
            _HandleClientTimeRequest(pPdu);
            break;
        case CID_MSG_LIST_REQUEST:
            _HandleClientGetMsgListRequest(pPdu);
            break;
        case CID_MSG_GET_BY_MSG_ID_REQ:
            _HandleClientGetMsgByMsgIdRequest(pPdu);
            break;
        case CID_MSG_UNREAD_CNT_REQUEST:
            _HandleClientUnreadMsgCntRequest(pPdu );
            break;
        case CID_MSG_READ_ACK:
            _HandleClientMsgReadAck(pPdu);
            break;
        case CID_MSG_GET_LATEST_MSG_ID_REQ:
            _HandleClientGetLatestMsgIDReq(pPdu);
            break;
        case CID_SWITCH_P2P_CMD:
            _HandleClientP2PCmdMsg(pPdu );
            break;
        case CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST:
            _HandleClientRecentContactSessionRequest(pPdu);
            break;
        case CID_BUDDY_LIST_USER_INFO_REQUEST:
            _HandleClientUserInfoRequest( pPdu );
            break;
        case CID_BUDDY_LIST_REMOVE_SESSION_REQ:
            _HandleClientRemoveSessionRequest( pPdu );
            break;
        case CID_BUDDY_LIST_ALL_USER_REQUEST:
            _HandleClientAllUserRequest(pPdu );
            break;
        case CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST:
            _HandleChangeAvatarRequest(pPdu);
            break;
        case CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST:
            _HandleChangeSignInfoRequest(pPdu);
            break;
            
        case CID_BUDDY_LIST_USERS_STATUS_REQUEST:
            _HandleClientUsersStatusRequest(pPdu);
            break;
        case CID_BUDDY_LIST_DEPARTMENT_REQUEST:
            _HandleClientDepartmentRequest(pPdu);
            break;
        // for group process
        case CID_GROUP_NORMAL_LIST_REQUEST:
            s_group_chat-&gt;HandleClientGroupNormalRequest(pPdu, this);
            break;
        case CID_GROUP_INFO_REQUEST:
            s_group_chat-&gt;HandleClientGroupInfoRequest(pPdu, this);
            break;
        case CID_GROUP_CREATE_REQUEST:
            s_group_chat-&gt;HandleClientGroupCreateRequest(pPdu, this);
            break;
        case CID_GROUP_CHANGE_MEMBER_REQUEST:
            s_group_chat-&gt;HandleClientGroupChangeMemberRequest(pPdu, this);
            break;
        case CID_GROUP_SHIELD_GROUP_REQUEST:
            s_group_chat-&gt;HandleClientGroupShieldGroupRequest(pPdu, this);
            break;
            
        case CID_FILE_REQUEST:
            s_file_handler-&gt;HandleClientFileRequest(this, pPdu);
            break;
        case CID_FILE_HAS_OFFLINE_REQ:
            s_file_handler-&gt;HandleClientFileHasOfflineReq(this, pPdu);
            break;
        case CID_FILE_ADD_OFFLINE_REQ:
            s_file_handler-&gt;HandleClientFileAddOfflineReq(this, pPdu);
            break;
        case CID_FILE_DEL_OFFLINE_REQ:
            s_file_handler-&gt;HandleClientFileDelOfflineReq(this, pPdu);
            break;
        default:
            log(&#34;wrong msg, cmd id=%d, user id=%u. &#34;, pPdu-&gt;GetCommandId(), GetUserId());
            break;
	}
}
</code></pre><p>分支case CID_LOGIN_REQ_USERLOGIN即处理登录请求：</p>
<pre tabindex="0"><code>//在MsgConn.cpp中
void CMsgConn::_HandleLoginRequest(CImPdu* pPdu)
{
    // refuse second validate request
    if (m_login_name.length() != 0) {
        log(&#34;duplicate LoginRequest in the same conn &#34;);
        return;
    }
    
    // check if all server connection are OK
    uint32_t result = 0;
    string result_string = &#34;&#34;;
    CDBServConn* pDbConn = get_db_serv_conn_for_login();
    if (!pDbConn) {
        result = IM::BaseDefine::REFUSE_REASON_NO_DB_SERVER;
        result_string = &#34;服务端异常&#34;;
	}
    else if (!is_login_server_available()) {
        result = IM::BaseDefine::REFUSE_REASON_NO_LOGIN_SERVER;
        result_string = &#34;服务端异常&#34;;
	}
    else if (!is_route_server_available()) {
        result = IM::BaseDefine::REFUSE_REASON_NO_ROUTE_SERVER;
        result_string = &#34;服务端异常&#34;;
    
}
    if (result) {
        IM::Login::IMLoginRes msg;
        msg.set_server_time(time(NULL));
        msg.set_result_code((IM::BaseDefine::ResultType)result);
        msg.set_result_string(result_string);
        CImPdu pdu;
        pdu.SetPBMsg(&amp;msg);
        pdu.SetServiceId(SID_LOGIN);
        pdu.SetCommandId(CID_LOGIN_RES_USERLOGIN);
        pdu.SetSeqNum(pPdu-&gt;GetSeqNum());
        SendPdu(&amp;pdu);
        Close();
        return;
    }
    IM::Login::IMLoginReq msg;
    CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu-&gt;GetBodyData(), pPdu-&gt;GetBodyLength()));
    //假如是汉字，则转成拼音
    m_login_name = msg.user_name();
    string password = msg.password();
    uint32_t online_status = msg.online_status();
    if (online_status &lt; IM::BaseDefine::USER_STATUS_ONLINE || online_status &gt; IM::BaseDefine::USER_STATUS_LEAVE) {
        log(&#34;HandleLoginReq, online status wrong: %u &#34;, online_status);
        online_status = IM::BaseDefine::USER_STATUS_ONLINE;
    }
    m_client_version = msg.client_version();
    m_client_type = msg.client_type();
    m_online_status = online_status;
    log(&#34;HandleLoginReq, user_name=%s, status=%u, client_type=%u, client=%s, &#34;,
        m_login_name.c_str(), online_status, m_client_type, m_client_version.c_str());
    CImUser* pImUser = CImUserManager::GetInstance()-&gt;GetImUserByLoginName(GetLoginName());
    if (!pImUser) {
        pImUser = new CImUser(GetLoginName());
        CImUserManager::GetInstance()-&gt;AddImUserByLoginName(GetLoginName(), pImUser);
    }
    pImUser-&gt;AddUnValidateMsgConn(this);
    
    CDbAttachData attach_data(ATTACH_TYPE_HANDLE, m_handle, 0);
    // continue to validate if the user is OK
    
    IM::Server::IMValidateReq msg2;
    msg2.set_user_name(msg.user_name());
    msg2.set_password(password);
    msg2.set_attach_data(attach_data.GetBuffer(), attach_data.GetLength());
    CImPdu pdu;
    pdu.SetPBMsg(&amp;msg2);
    pdu.SetServiceId(SID_OTHER);
    pdu.SetCommandId(CID_OTHER_VALIDATE_REQ);
    pdu.SetSeqNum(pPdu-&gt;GetSeqNum());
    pDbConn-&gt;SendPdu(&amp;pdu);
}
</code></pre>
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/23af895a60264bfe949c3636689d3f83/">
    <span class="title">« Prev</span>
    <br>
    <span>02 服务器端的程序的编译与部署</span>
  </a>
  <a class="next" href="https://haokiu.com/5481b95ce7c64f8c99c98e3c59d74314/">
    <span class="title">Next »</span>
    <br>
    <span>04 服务器端db_proxy_server源码分析</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
