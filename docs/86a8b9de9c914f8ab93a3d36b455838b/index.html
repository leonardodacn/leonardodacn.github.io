<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>从零学习开源项目系列（三） CSBattleMgr服务源码研究 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="从零学习开源项目系列（三） CSBattleMgr服务源码研究 服务器项目工程如下图所示：
如上图所示，这篇文章我们将介绍CSBattleMgr的情况，但是我们不会去研究这个服务器的特别细节的东西（这些细节我们将在后面的文章中介绍）。阅读一个未知的项目源码如果我们开始就纠结于各种细节，那么我们最终会陷入“横看成岭侧成峰，远近高低各不同”的尴尬境界，浪费时间不说，可能收获也是事倍功半。所以，尽管我们不熟悉这套代码，我们还是尽量先从整体来把握，先大致了解各个服务的功能，细节部分回头再针对性地去研究。
这个系列的第二篇文章《从零学习开源项目系列（二） 最后一战概况》中我们介绍了，这套游戏的服务需要使用redis和mysql，我们先看下mysql是否准备好了（mysql服务启动起来，数据库建表数据存在，具体细节请参考第二篇文章）。打开Windows的cmd程序，输入以下指令连接mysql：
mysql -uroot -p123321 连接成功以后，如下图所示：
然后我们输入以下指令，查看我们需要的数据库是否创建成功：
show databases; 这些都是基本的sql语句，如果您不熟悉的话，可能需要专门学习一下。
数据库创建成功后如下图所示：
至于数据库中的表是否创建成功，我们这里先不关注，后面我们实际用到哪张数据表，我们再去研究。
mysql没问题了，接下来我们要启动一下redis，通过第二篇文章我们知道redis需要启动两次，也就是一共两个redis进程，我们游戏服务中分别称为redis-server和redis-login-server（它们的配置文件信息不一样），我们可以在Server\Bin\x64\Release目录下手动cmd命令行执行下列语句：
start /min &#34;redis-server&#34; &#34;redis-server.exe&#34; redis.conf start /min &#34;redis-Logicserver&#34; &#34;redis-server.exe&#34; redis-logic.conf 但是这样比较麻烦，我将这两句拷贝出来，放入一个叫start-redis.bat文件中了，每次启动只要执行一下这个bat文件就可以：
redis和redis-logic服务启动后如下图所示：
我们常见的redis服务都是linux下的源码，微软公司对redis源码进行了改造，出了一个Windows版本，稍微有点不尽人意（例如：Windows下没有完全与linux的fork()相匹配的API，所以只能用CreateProcess()去替代）。关于windows版本的redis源码官方下载地址为：https://github.com/MicrosoftArchive/redis/releases。
在启动好了mysql和redis后，我们现在正式来看一下CSBattleMgr这个服务。读者不禁可能要问，那么多服务，你怎么知道要先看这个服务呢？我们上一篇文章中也说过，我们再start.bat文件中发现除了redis以外，这是第三个需要启动的服务，所以我们先研究它（start.bat我们可以认为是源码作者为我们留下的部署步骤“文档”）：
我们打开CSBattleMgr服务main.cpp文件，找到入口main函数，内容如下：
int main(){ DbgLib::CDebugFx::SetExceptionHandler(true); DbgLib::CDebugFx::SetExceptionCallback(ExceptionCallback, NULL); GetCSKernelInstance(); GetCSUserMgrInstance(); GetBattleMgrInstance(); GetCSKernelInstance()-&gt;Initialize(); GetBattleMgrInstance()-&gt;Initialize(); GetCSUserMgrInstance()-&gt;Initialize(); GetCSKernelInstance()-&gt;Start(); mysql_library_init(0, NULL, NULL); GetCSKernelInstance()-&gt;MainLoop(); } 通过调试，我们发下这个函数大致做了以下任务：
//1. 设置程序异常处理函数 //2. 初始化一系列单例对象 //3. 初始化mysql //4. 进入一个被称作“主循环”的无限循环 步骤1设置程序异常处理函数没有好介绍的，我们看一下步骤2初始化一系列单例对象，总共初始化了三个类的对象CCSKernel、CCSUserMgr和CCSBattleMgr。单例模式本身没啥好介绍的，但是有人要提单例模式的线程安全性，所以出现很多通过加锁的单例模式代码，我个人觉得没必要；认为要加锁的朋友可能认为单例对象如果在第一次初始化时同时被多个线程调用就会有问题，我觉得加锁带来的开销还不如像上面的代码一样，在整个程序初始化初期获取一下单例对象，让单例对象生成出来，后面即使多个线程获取这个单例对象也都是读操作，无需加锁。以GetCSKernelInstance();为例：
CCSKernel* GetCSKernelInstance(){ return &amp;CCSKernel::GetInstance(); } CCSKernel&amp; CCSKernel::GetInstance(){ if (NULL == pInstance){ pInstance = new CCSKernel; } return *pInstance; } GetCSKernelInstance()-&gt;Initialize()的初始化动作其实是加载各种配置信息和事先设置一系列的回调函数和定时器：
INT32 CCSKernel::Initialize() { //JJIAZ加载配置的时候 不要随便调整顺序 CCSCfgMgr::getInstance().Initalize(); INT32 n32Init = LoadCfg(); if (eNormal != n32Init) { ELOG(LOG_ERROR,&#34; loadCfg()............failed!&#34;); return n32Init; } if(m_sCSKernelCfg.un32MaxSSNum &gt; 0 ) { m_psSSNetInfoList = new SSSNetInfo[m_sCSKernelCfg.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/86a8b9de9c914f8ab93a3d36b455838b/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="从零学习开源项目系列（三） CSBattleMgr服务源码研究" />
<meta property="og:description" content="从零学习开源项目系列（三） CSBattleMgr服务源码研究 服务器项目工程如下图所示：
如上图所示，这篇文章我们将介绍CSBattleMgr的情况，但是我们不会去研究这个服务器的特别细节的东西（这些细节我们将在后面的文章中介绍）。阅读一个未知的项目源码如果我们开始就纠结于各种细节，那么我们最终会陷入“横看成岭侧成峰，远近高低各不同”的尴尬境界，浪费时间不说，可能收获也是事倍功半。所以，尽管我们不熟悉这套代码，我们还是尽量先从整体来把握，先大致了解各个服务的功能，细节部分回头再针对性地去研究。
这个系列的第二篇文章《从零学习开源项目系列（二） 最后一战概况》中我们介绍了，这套游戏的服务需要使用redis和mysql，我们先看下mysql是否准备好了（mysql服务启动起来，数据库建表数据存在，具体细节请参考第二篇文章）。打开Windows的cmd程序，输入以下指令连接mysql：
mysql -uroot -p123321 连接成功以后，如下图所示：
然后我们输入以下指令，查看我们需要的数据库是否创建成功：
show databases; 这些都是基本的sql语句，如果您不熟悉的话，可能需要专门学习一下。
数据库创建成功后如下图所示：
至于数据库中的表是否创建成功，我们这里先不关注，后面我们实际用到哪张数据表，我们再去研究。
mysql没问题了，接下来我们要启动一下redis，通过第二篇文章我们知道redis需要启动两次，也就是一共两个redis进程，我们游戏服务中分别称为redis-server和redis-login-server（它们的配置文件信息不一样），我们可以在Server\Bin\x64\Release目录下手动cmd命令行执行下列语句：
start /min &#34;redis-server&#34; &#34;redis-server.exe&#34; redis.conf start /min &#34;redis-Logicserver&#34; &#34;redis-server.exe&#34; redis-logic.conf 但是这样比较麻烦，我将这两句拷贝出来，放入一个叫start-redis.bat文件中了，每次启动只要执行一下这个bat文件就可以：
redis和redis-logic服务启动后如下图所示：
我们常见的redis服务都是linux下的源码，微软公司对redis源码进行了改造，出了一个Windows版本，稍微有点不尽人意（例如：Windows下没有完全与linux的fork()相匹配的API，所以只能用CreateProcess()去替代）。关于windows版本的redis源码官方下载地址为：https://github.com/MicrosoftArchive/redis/releases。
在启动好了mysql和redis后，我们现在正式来看一下CSBattleMgr这个服务。读者不禁可能要问，那么多服务，你怎么知道要先看这个服务呢？我们上一篇文章中也说过，我们再start.bat文件中发现除了redis以外，这是第三个需要启动的服务，所以我们先研究它（start.bat我们可以认为是源码作者为我们留下的部署步骤“文档”）：
我们打开CSBattleMgr服务main.cpp文件，找到入口main函数，内容如下：
int main(){ DbgLib::CDebugFx::SetExceptionHandler(true); DbgLib::CDebugFx::SetExceptionCallback(ExceptionCallback, NULL); GetCSKernelInstance(); GetCSUserMgrInstance(); GetBattleMgrInstance(); GetCSKernelInstance()-&gt;Initialize(); GetBattleMgrInstance()-&gt;Initialize(); GetCSUserMgrInstance()-&gt;Initialize(); GetCSKernelInstance()-&gt;Start(); mysql_library_init(0, NULL, NULL); GetCSKernelInstance()-&gt;MainLoop(); } 通过调试，我们发下这个函数大致做了以下任务：
//1. 设置程序异常处理函数 //2. 初始化一系列单例对象 //3. 初始化mysql //4. 进入一个被称作“主循环”的无限循环 步骤1设置程序异常处理函数没有好介绍的，我们看一下步骤2初始化一系列单例对象，总共初始化了三个类的对象CCSKernel、CCSUserMgr和CCSBattleMgr。单例模式本身没啥好介绍的，但是有人要提单例模式的线程安全性，所以出现很多通过加锁的单例模式代码，我个人觉得没必要；认为要加锁的朋友可能认为单例对象如果在第一次初始化时同时被多个线程调用就会有问题，我觉得加锁带来的开销还不如像上面的代码一样，在整个程序初始化初期获取一下单例对象，让单例对象生成出来，后面即使多个线程获取这个单例对象也都是读操作，无需加锁。以GetCSKernelInstance();为例：
CCSKernel* GetCSKernelInstance(){ return &amp;CCSKernel::GetInstance(); } CCSKernel&amp; CCSKernel::GetInstance(){ if (NULL == pInstance){ pInstance = new CCSKernel; } return *pInstance; } GetCSKernelInstance()-&gt;Initialize()的初始化动作其实是加载各种配置信息和事先设置一系列的回调函数和定时器：
INT32 CCSKernel::Initialize() { //JJIAZ加载配置的时候 不要随便调整顺序 CCSCfgMgr::getInstance().Initalize(); INT32 n32Init = LoadCfg(); if (eNormal != n32Init) { ELOG(LOG_ERROR,&#34; loadCfg()............failed!&#34;); return n32Init; } if(m_sCSKernelCfg.un32MaxSSNum &gt; 0 ) { m_psSSNetInfoList = new SSSNetInfo[m_sCSKernelCfg." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/86a8b9de9c914f8ab93a3d36b455838b/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="从零学习开源项目系列（三） CSBattleMgr服务源码研究"/>
<meta name="twitter:description" content="从零学习开源项目系列（三） CSBattleMgr服务源码研究 服务器项目工程如下图所示：
如上图所示，这篇文章我们将介绍CSBattleMgr的情况，但是我们不会去研究这个服务器的特别细节的东西（这些细节我们将在后面的文章中介绍）。阅读一个未知的项目源码如果我们开始就纠结于各种细节，那么我们最终会陷入“横看成岭侧成峰，远近高低各不同”的尴尬境界，浪费时间不说，可能收获也是事倍功半。所以，尽管我们不熟悉这套代码，我们还是尽量先从整体来把握，先大致了解各个服务的功能，细节部分回头再针对性地去研究。
这个系列的第二篇文章《从零学习开源项目系列（二） 最后一战概况》中我们介绍了，这套游戏的服务需要使用redis和mysql，我们先看下mysql是否准备好了（mysql服务启动起来，数据库建表数据存在，具体细节请参考第二篇文章）。打开Windows的cmd程序，输入以下指令连接mysql：
mysql -uroot -p123321 连接成功以后，如下图所示：
然后我们输入以下指令，查看我们需要的数据库是否创建成功：
show databases; 这些都是基本的sql语句，如果您不熟悉的话，可能需要专门学习一下。
数据库创建成功后如下图所示：
至于数据库中的表是否创建成功，我们这里先不关注，后面我们实际用到哪张数据表，我们再去研究。
mysql没问题了，接下来我们要启动一下redis，通过第二篇文章我们知道redis需要启动两次，也就是一共两个redis进程，我们游戏服务中分别称为redis-server和redis-login-server（它们的配置文件信息不一样），我们可以在Server\Bin\x64\Release目录下手动cmd命令行执行下列语句：
start /min &#34;redis-server&#34; &#34;redis-server.exe&#34; redis.conf start /min &#34;redis-Logicserver&#34; &#34;redis-server.exe&#34; redis-logic.conf 但是这样比较麻烦，我将这两句拷贝出来，放入一个叫start-redis.bat文件中了，每次启动只要执行一下这个bat文件就可以：
redis和redis-logic服务启动后如下图所示：
我们常见的redis服务都是linux下的源码，微软公司对redis源码进行了改造，出了一个Windows版本，稍微有点不尽人意（例如：Windows下没有完全与linux的fork()相匹配的API，所以只能用CreateProcess()去替代）。关于windows版本的redis源码官方下载地址为：https://github.com/MicrosoftArchive/redis/releases。
在启动好了mysql和redis后，我们现在正式来看一下CSBattleMgr这个服务。读者不禁可能要问，那么多服务，你怎么知道要先看这个服务呢？我们上一篇文章中也说过，我们再start.bat文件中发现除了redis以外，这是第三个需要启动的服务，所以我们先研究它（start.bat我们可以认为是源码作者为我们留下的部署步骤“文档”）：
我们打开CSBattleMgr服务main.cpp文件，找到入口main函数，内容如下：
int main(){ DbgLib::CDebugFx::SetExceptionHandler(true); DbgLib::CDebugFx::SetExceptionCallback(ExceptionCallback, NULL); GetCSKernelInstance(); GetCSUserMgrInstance(); GetBattleMgrInstance(); GetCSKernelInstance()-&gt;Initialize(); GetBattleMgrInstance()-&gt;Initialize(); GetCSUserMgrInstance()-&gt;Initialize(); GetCSKernelInstance()-&gt;Start(); mysql_library_init(0, NULL, NULL); GetCSKernelInstance()-&gt;MainLoop(); } 通过调试，我们发下这个函数大致做了以下任务：
//1. 设置程序异常处理函数 //2. 初始化一系列单例对象 //3. 初始化mysql //4. 进入一个被称作“主循环”的无限循环 步骤1设置程序异常处理函数没有好介绍的，我们看一下步骤2初始化一系列单例对象，总共初始化了三个类的对象CCSKernel、CCSUserMgr和CCSBattleMgr。单例模式本身没啥好介绍的，但是有人要提单例模式的线程安全性，所以出现很多通过加锁的单例模式代码，我个人觉得没必要；认为要加锁的朋友可能认为单例对象如果在第一次初始化时同时被多个线程调用就会有问题，我觉得加锁带来的开销还不如像上面的代码一样，在整个程序初始化初期获取一下单例对象，让单例对象生成出来，后面即使多个线程获取这个单例对象也都是读操作，无需加锁。以GetCSKernelInstance();为例：
CCSKernel* GetCSKernelInstance(){ return &amp;CCSKernel::GetInstance(); } CCSKernel&amp; CCSKernel::GetInstance(){ if (NULL == pInstance){ pInstance = new CCSKernel; } return *pInstance; } GetCSKernelInstance()-&gt;Initialize()的初始化动作其实是加载各种配置信息和事先设置一系列的回调函数和定时器：
INT32 CCSKernel::Initialize() { //JJIAZ加载配置的时候 不要随便调整顺序 CCSCfgMgr::getInstance().Initalize(); INT32 n32Init = LoadCfg(); if (eNormal != n32Init) { ELOG(LOG_ERROR,&#34; loadCfg()............failed!&#34;); return n32Init; } if(m_sCSKernelCfg.un32MaxSSNum &gt; 0 ) { m_psSSNetInfoList = new SSSNetInfo[m_sCSKernelCfg."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "从零学习开源项目系列（三） CSBattleMgr服务源码研究",
      "item": "https://haokiu.com/86a8b9de9c914f8ab93a3d36b455838b/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从零学习开源项目系列（三） CSBattleMgr服务源码研究",
  "name": "从零学习开源项目系列（三） CSBattleMgr服务源码研究",
  "description": "从零学习开源项目系列（三） CSBattleMgr服务源码研究 服务器项目工程如下图所示：\n如上图所示，这篇文章我们将介绍CSBattleMgr的情况，但是我们不会去研究这个服务器的特别细节的东西（这些细节我们将在后面的文章中介绍）。阅读一个未知的项目源码如果我们开始就纠结于各种细节，那么我们最终会陷入“横看成岭侧成峰，远近高低各不同”的尴尬境界，浪费时间不说，可能收获也是事倍功半。所以，尽管我们不熟悉这套代码，我们还是尽量先从整体来把握，先大致了解各个服务的功能，细节部分回头再针对性地去研究。\n这个系列的第二篇文章《从零学习开源项目系列（二） 最后一战概况》中我们介绍了，这套游戏的服务需要使用redis和mysql，我们先看下mysql是否准备好了（mysql服务启动起来，数据库建表数据存在，具体细节请参考第二篇文章）。打开Windows的cmd程序，输入以下指令连接mysql：\nmysql -uroot -p123321 连接成功以后，如下图所示：\n然后我们输入以下指令，查看我们需要的数据库是否创建成功：\nshow databases; 这些都是基本的sql语句，如果您不熟悉的话，可能需要专门学习一下。\n数据库创建成功后如下图所示：\n至于数据库中的表是否创建成功，我们这里先不关注，后面我们实际用到哪张数据表，我们再去研究。\nmysql没问题了，接下来我们要启动一下redis，通过第二篇文章我们知道redis需要启动两次，也就是一共两个redis进程，我们游戏服务中分别称为redis-server和redis-login-server（它们的配置文件信息不一样），我们可以在Server\\Bin\\x64\\Release目录下手动cmd命令行执行下列语句：\nstart /min \u0026#34;redis-server\u0026#34; \u0026#34;redis-server.exe\u0026#34; redis.conf start /min \u0026#34;redis-Logicserver\u0026#34; \u0026#34;redis-server.exe\u0026#34; redis-logic.conf 但是这样比较麻烦，我将这两句拷贝出来，放入一个叫start-redis.bat文件中了，每次启动只要执行一下这个bat文件就可以：\nredis和redis-logic服务启动后如下图所示：\n我们常见的redis服务都是linux下的源码，微软公司对redis源码进行了改造，出了一个Windows版本，稍微有点不尽人意（例如：Windows下没有完全与linux的fork()相匹配的API，所以只能用CreateProcess()去替代）。关于windows版本的redis源码官方下载地址为：https://github.com/MicrosoftArchive/redis/releases。\n在启动好了mysql和redis后，我们现在正式来看一下CSBattleMgr这个服务。读者不禁可能要问，那么多服务，你怎么知道要先看这个服务呢？我们上一篇文章中也说过，我们再start.bat文件中发现除了redis以外，这是第三个需要启动的服务，所以我们先研究它（start.bat我们可以认为是源码作者为我们留下的部署步骤“文档”）：\n我们打开CSBattleMgr服务main.cpp文件，找到入口main函数，内容如下：\nint main(){ DbgLib::CDebugFx::SetExceptionHandler(true); DbgLib::CDebugFx::SetExceptionCallback(ExceptionCallback, NULL); GetCSKernelInstance(); GetCSUserMgrInstance(); GetBattleMgrInstance(); GetCSKernelInstance()-\u0026gt;Initialize(); GetBattleMgrInstance()-\u0026gt;Initialize(); GetCSUserMgrInstance()-\u0026gt;Initialize(); GetCSKernelInstance()-\u0026gt;Start(); mysql_library_init(0, NULL, NULL); GetCSKernelInstance()-\u0026gt;MainLoop(); } 通过调试，我们发下这个函数大致做了以下任务：\n//1. 设置程序异常处理函数 //2. 初始化一系列单例对象 //3. 初始化mysql //4. 进入一个被称作“主循环”的无限循环 步骤1设置程序异常处理函数没有好介绍的，我们看一下步骤2初始化一系列单例对象，总共初始化了三个类的对象CCSKernel、CCSUserMgr和CCSBattleMgr。单例模式本身没啥好介绍的，但是有人要提单例模式的线程安全性，所以出现很多通过加锁的单例模式代码，我个人觉得没必要；认为要加锁的朋友可能认为单例对象如果在第一次初始化时同时被多个线程调用就会有问题，我觉得加锁带来的开销还不如像上面的代码一样，在整个程序初始化初期获取一下单例对象，让单例对象生成出来，后面即使多个线程获取这个单例对象也都是读操作，无需加锁。以GetCSKernelInstance();为例：\nCCSKernel* GetCSKernelInstance(){ return \u0026amp;CCSKernel::GetInstance(); } CCSKernel\u0026amp; CCSKernel::GetInstance(){ if (NULL == pInstance){ pInstance = new CCSKernel; } return *pInstance; } GetCSKernelInstance()-\u0026gt;Initialize()的初始化动作其实是加载各种配置信息和事先设置一系列的回调函数和定时器：\nINT32 CCSKernel::Initialize() { //JJIAZ加载配置的时候 不要随便调整顺序 CCSCfgMgr::getInstance().Initalize(); INT32 n32Init = LoadCfg(); if (eNormal != n32Init) { ELOG(LOG_ERROR,\u0026#34; loadCfg()............failed!\u0026#34;); return n32Init; } if(m_sCSKernelCfg.un32MaxSSNum \u0026gt; 0 ) { m_psSSNetInfoList = new SSSNetInfo[m_sCSKernelCfg.",
  "keywords": [
    
  ],
  "articleBody": "从零学习开源项目系列（三） CSBattleMgr服务源码研究 服务器项目工程如下图所示：\n如上图所示，这篇文章我们将介绍CSBattleMgr的情况，但是我们不会去研究这个服务器的特别细节的东西（这些细节我们将在后面的文章中介绍）。阅读一个未知的项目源码如果我们开始就纠结于各种细节，那么我们最终会陷入“横看成岭侧成峰，远近高低各不同”的尴尬境界，浪费时间不说，可能收获也是事倍功半。所以，尽管我们不熟悉这套代码，我们还是尽量先从整体来把握，先大致了解各个服务的功能，细节部分回头再针对性地去研究。\n这个系列的第二篇文章《从零学习开源项目系列（二） 最后一战概况》中我们介绍了，这套游戏的服务需要使用redis和mysql，我们先看下mysql是否准备好了（mysql服务启动起来，数据库建表数据存在，具体细节请参考第二篇文章）。打开Windows的cmd程序，输入以下指令连接mysql：\nmysql -uroot -p123321 连接成功以后，如下图所示：\n然后我们输入以下指令，查看我们需要的数据库是否创建成功：\nshow databases; 这些都是基本的sql语句，如果您不熟悉的话，可能需要专门学习一下。\n数据库创建成功后如下图所示：\n至于数据库中的表是否创建成功，我们这里先不关注，后面我们实际用到哪张数据表，我们再去研究。\nmysql没问题了，接下来我们要启动一下redis，通过第二篇文章我们知道redis需要启动两次，也就是一共两个redis进程，我们游戏服务中分别称为redis-server和redis-login-server（它们的配置文件信息不一样），我们可以在Server\\Bin\\x64\\Release目录下手动cmd命令行执行下列语句：\nstart /min \"redis-server\" \"redis-server.exe\" redis.conf start /min \"redis-Logicserver\" \"redis-server.exe\" redis-logic.conf 但是这样比较麻烦，我将这两句拷贝出来，放入一个叫start-redis.bat文件中了，每次启动只要执行一下这个bat文件就可以：\nredis和redis-logic服务启动后如下图所示：\n我们常见的redis服务都是linux下的源码，微软公司对redis源码进行了改造，出了一个Windows版本，稍微有点不尽人意（例如：Windows下没有完全与linux的fork()相匹配的API，所以只能用CreateProcess()去替代）。关于windows版本的redis源码官方下载地址为：https://github.com/MicrosoftArchive/redis/releases。\n在启动好了mysql和redis后，我们现在正式来看一下CSBattleMgr这个服务。读者不禁可能要问，那么多服务，你怎么知道要先看这个服务呢？我们上一篇文章中也说过，我们再start.bat文件中发现除了redis以外，这是第三个需要启动的服务，所以我们先研究它（start.bat我们可以认为是源码作者为我们留下的部署步骤“文档”）：\n我们打开CSBattleMgr服务main.cpp文件，找到入口main函数，内容如下：\nint main(){ DbgLib::CDebugFx::SetExceptionHandler(true); DbgLib::CDebugFx::SetExceptionCallback(ExceptionCallback, NULL); GetCSKernelInstance(); GetCSUserMgrInstance(); GetBattleMgrInstance(); GetCSKernelInstance()-\u003eInitialize(); GetBattleMgrInstance()-\u003eInitialize(); GetCSUserMgrInstance()-\u003eInitialize(); GetCSKernelInstance()-\u003eStart(); mysql_library_init(0, NULL, NULL); GetCSKernelInstance()-\u003eMainLoop(); } 通过调试，我们发下这个函数大致做了以下任务：\n//1. 设置程序异常处理函数 //2. 初始化一系列单例对象 //3. 初始化mysql //4. 进入一个被称作“主循环”的无限循环 步骤1设置程序异常处理函数没有好介绍的，我们看一下步骤2初始化一系列单例对象，总共初始化了三个类的对象CCSKernel、CCSUserMgr和CCSBattleMgr。单例模式本身没啥好介绍的，但是有人要提单例模式的线程安全性，所以出现很多通过加锁的单例模式代码，我个人觉得没必要；认为要加锁的朋友可能认为单例对象如果在第一次初始化时同时被多个线程调用就会有问题，我觉得加锁带来的开销还不如像上面的代码一样，在整个程序初始化初期获取一下单例对象，让单例对象生成出来，后面即使多个线程获取这个单例对象也都是读操作，无需加锁。以GetCSKernelInstance();为例：\nCCSKernel* GetCSKernelInstance(){ return \u0026CCSKernel::GetInstance(); } CCSKernel\u0026 CCSKernel::GetInstance(){ if (NULL == pInstance){ pInstance = new CCSKernel; } return *pInstance; } GetCSKernelInstance()-\u003eInitialize()的初始化动作其实是加载各种配置信息和事先设置一系列的回调函数和定时器：\nINT32 CCSKernel::Initialize() { //JJIAZ加载配置的时候 不要随便调整顺序 CCSCfgMgr::getInstance().Initalize(); INT32 n32Init = LoadCfg(); if (eNormal != n32Init) { ELOG(LOG_ERROR,\" loadCfg()............failed!\"); return n32Init; } if(m_sCSKernelCfg.un32MaxSSNum \u003e 0 ) { m_psSSNetInfoList = new SSSNetInfo[m_sCSKernelCfg.un32MaxSSNum]; memset(m_psSSNetInfoList, 0, sizeof(SSSNetInfo) * m_sCSKernelCfg.un32MaxSSNum); m_psGSNetInfoList = new SGSNetInfo[m_sCSKernelCfg.un32MaxGSNum]; memset(m_psGSNetInfoList, 0, sizeof(SGSNetInfo) * m_sCSKernelCfg.un32MaxGSNum); m_psRCNetInfoList = new SRCNetInfo[10]; } m_GSMsgHandlerMap[GSToCS::eMsgToCSFromGS_AskRegiste] = std::bind(\u0026CCSKernel::OnMsgFromGS_AskRegiste, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); m_GSMsgHandlerMap[GSToCS::eMsgToCSFromGS_AskPing] = std::bind(\u0026CCSKernel::OnMsgFromGS_AskPing, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); m_GSMsgHandlerMap[GSToCS::eMsgToCSFromGS_ReportGCMsg] = std::bind(\u0026CCSKernel::OnMsgFromGS_ReportGCMsg, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); m_SSMsgHandlerMap[SSToCS::eMsgToCSFromSS_AskPing] = std::bind(\u0026CCSKernel::OnMsgFromSS_AskPing, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); AddTimer(std::bind(\u0026CCSKernel::ProfileReport, this, std::placeholders::_1, std::placeholders::_2), 5000, true); return eNormal; } 如上图所示，这些配置信息都是游戏术语，包括各种技能、英雄、模型等信息。\nGetBattleMgrInstance()-\u003eInitialize()其实是帮CSKernel对象启动一个定时器：\nINT32 CCSBattleMgr::Initialize(){ GetCSKernelInstance()-\u003eAddTimer(std::bind(\u0026CCSMatchMgr::Update, m_pMatchMgr, std::placeholders::_1, std::placeholders::_2), c_matcherDelay, true); return eNormal; } GetCSUserMgrInstance()-\u003eInitialize()是初始化mysql和redis的一些相关信息，由于redis是做服务的缓存的，所以我们一般在项目中看到cacheServer这样的字眼指的都是redis：\nvoid CCSUserMgr::Initialize(){ SDBCfg cfgGameDb = CCSCfgMgr::getInstance().GetDBCfg(eDB_GameDb); SDBCfg cfgCdkeyDb=CCSCfgMgr::getInstance().GetDBCfg(eDB_CdkeyDb); m_UserCacheDBActiveWrapper = new DBActiveWrapper( std::bind(\u0026CCSUserMgr::UserCacheDBAsynHandler, this, std::placeholders::_1), cfgGameDb, std::bind(\u0026CCSUserMgr::DBAsyn_QueryWhenThreadBegin, this) ); m_UserCacheDBActiveWrapper-\u003eStart(); m_CdkeyWrapper = new DBActiveWrapper( std::bind(\u0026CCSUserMgr::UserAskDBAsynHandler, this, std::placeholders::_1), cfgCdkeyDb, std::bind(\u0026CCSUserMgr::CDKThreadBeginCallback, this) ); m_CdkeyWrapper-\u003eStart(); for (int i = 0; i \u003c gThread ; i++) { DBActiveWrapper* pThreadDBWrapper(new DBActiveWrapper(std::bind(\u0026CCSUserMgr::UserAskDBAsynHandler, this, std::placeholders::_1), cfgGameDb)); pThreadDBWrapper-\u003eStart(); m_pUserAskDBActiveWrapperVec.push_back(pThreadDBWrapper); } } 注意一点：不知道大家有没有发现，我们代码中大量使用C++11中的std::bind()这样函数，注意由于我们使用的Visual Studio版本是2010，2010这个版本是不支持C++11的，所以这里的std::bind不是C++11的，而是C++11发布之前的草案tr1中的，所以全部的命名空间应该是tr1::std::bind，其他的类似C++11的功能也是一样，所以你在代码中可以看到这样引入命名空间的语句：\nGetCSKernelInstance()-\u003eStart();是初始化所有的网络连接的Session管理器，所谓Session，中文译为“会话”，其下层对应网络通信的连接，每一路连接对应一个Session，而管理这些Session的对象就是Session Manager，在我们的代码中是CSNetSessionMgr，它继承自接口类INetSessionMgr：\nclass CSNetSessionMgr : public INetSessionMgr { public: CSNetSessionMgr(); virtual ~CSNetSessionMgr(); public: virtual ISDSession* UCAPI CreateSession(ISDConnection* pConnection) { return NULL; /*重写*/} virtual ICliSession* UCAPI CreateConnectorSession(SESSION_TYPE type); virtual bool CreateConnector(SESSION_TYPE type, const char* ip, int port, int recvsize, int sendsize, int logicId); private: CSParser m_CSParser; }; 初始化CSNetSessionMgr的代码如下：\nINT32 CCSKernel::Start() { CSNetSessionMgr* pNetSession = new CSNetSessionMgr; GetBattleMgrInstance()-\u003eRegisterMsgHandle(m_SSMsgHandlerMap, m_GSMsgHandlerMap, m_GCMsgHandlerMap, m_RCMsgHandlerMap); GetCSUserMgrInstance()-\u003eRegisterMsgHandle(m_SSMsgHandlerMap, m_GSMsgHandlerMap, m_GCMsgHandlerMap, m_RCMsgHandlerMap); ELOG(LOG_INFO, \"success!\"); return 0; } 连接数据库成功以后，我们的CSBattleMgr程序的控制台会显示一行提示mysql连接成功：\n读者看上图会发现，这些日志信息有三个颜色，出错信息使用红色，重要的正常信息使用绿色，一般的输出信息使用灰色。这是如何实现的呢？我们将在下一篇文章《从零学习开源项目系列（三） LogServer服务源码研究》中介绍具体实现原理，这也是一种不错的日志级别提醒方式。\n介绍完了初始化流程，我们介绍一下这个服务的主体部分MainLoop()函数，先看一下整体代码：\nvoid CCSKernel::MainLoop(){ TIME_TICK tHeartBeatCDTick = 10; //侦听端口10002 INetSessionMgr::GetInstance()-\u003eCreateListener(m_sCSKernelCfg.n32GSNetListenerPort, 1024000, 10240000, 0, \u0026gGateSessionFactory); //侦听端口10001 INetSessionMgr::GetInstance()-\u003eCreateListener(m_sCSKernelCfg.n32SSNetListenerPort, 1024000, 10240000, 1, \u0026gSceneSessionFactory); //侦听端口10010 INetSessionMgr::GetInstance()-\u003eCreateListener(m_sCSKernelCfg.n32RCNetListenerPort, 1024000, 10240000, 2, \u0026gRemoteConsoleFactory); //连接LogServer 1234端口 INetSessionMgr::GetInstance()-\u003eCreateConnector(ST_CLIENT_C2Log, m_sCSKernelCfg.LogAddress.c_str(), m_sCSKernelCfg.LogPort, 102400, 102400, 0); //连接redis 6379 if (m_sCSKernelCfg.redisAddress != \"0\"){ INetSessionMgr::GetInstance()-\u003eCreateConnector(ST_CLIENT_C2R, m_sCSKernelCfg.redisAddress.c_str(), m_sCSKernelCfg.redisPort, 102400, 102400, 0); } //连接redis 6380，也是redis-logic if (m_sCSKernelCfg.redisLogicAddress != \"0\"){ INetSessionMgr::GetInstance()-\u003eCreateConnector(ST_CLIENT_C2LogicRedis, m_sCSKernelCfg.redisLogicAddress.c_str(), m_sCSKernelCfg.redisLogicPort, 102400, 102400, 0); } while (true) { if (kbhit()) { static char CmdArray[1024] = { 0 }; static int CmdPos = 0; char CmdOne = getche(); CmdArray[CmdPos++] = CmdOne; bool bRet = 0; if (CmdPos \u003e= 1024 || CmdOne == 13) { CmdArray[--CmdPos] = 0; bRet = DoUserCmd(CmdArray); CmdPos = 0; if (bRet) break; } } INetSessionMgr::GetInstance()-\u003eUpdate(); GetCSUserMgrInstance()-\u003eOnHeartBeatImmediately(); ++m_RunCounts; m_BattleTimer.Run(); Sleep(1); } } 这个函数虽然叫MainLoop()，但是实际MainLoop()只是后半部分，前半部分总共创建三个侦听端口和三个连接器，也就是所谓的Listener和Connector，这些对象都是由上文提到的CSNetSessionMgr管理，所谓Listener就是这个服务使用socket API bind()和listen()函数在某个地址+端口号的二元组上绑定，供其他程序连接（其他程序可能是其他服务程序也可能是客户端，具体是哪个，我们后面的文章再进一步挖掘），侦听端口统计如下：\n侦听端口10002 侦听端口10001 侦听端口10010 连接器（Connector）也有三个，分别连接的服务和端口号是：\n连接redis的6379号端口 连接redis-logic的6380端口 连接某服务的1234端口 这个1234端口到底是哪个服务的呢？通过代码我们可以看出是LogServer的，那么到底是不是LogServer的呢，我们后面具体求证一下。\nINetSessionMgr::GetInstance()-\u003eCreateConnector( ST_CLIENT_C2Log, m_sCSKernelCfg.LogAddress.c_str(), m_sCSKernelCfg.LogPort, 102400, 102400, 0); 接着我们就正式进入了一个while循环：\nwhile (true) { if (kbhit()) { static char CmdArray[1024] = { 0 }; static int CmdPos = 0; char CmdOne = getche(); CmdArray[CmdPos++] = CmdOne; bool bRet = 0; if (CmdPos \u003e= 1024 || CmdOne == 13) { CmdArray[--CmdPos] = 0; bRet = DoUserCmd(CmdArray); CmdPos = 0; if (bRet) break; } } INetSessionMgr::GetInstance()-\u003eUpdate(); GetCSUserMgrInstance()-\u003eOnHeartBeatImmediately(); ++m_RunCounts; m_BattleTimer.Run(); Sleep(1); } 循环具体做了啥，我们先看**INetSessionMgr::GetInstance()-\u003eUpdate();**代码：\nvoid INetSessionMgr::Update() { mNetModule-\u003eRun(); vector tempQueue; EnterCriticalSection(\u0026mNetworkCs); tempQueue.swap(m_SafeQueue); LeaveCriticalSection(\u0026mNetworkCs); for (auto it=tempQueue.begin();it!=tempQueue.end();++it){ char* pBuffer = (*it); int nType = *(((int*)pBuffer)+0); int nSessionID = *(((int*)pBuffer)+1); Send((SESSION_TYPE)nType,nSessionID,pBuffer+2*sizeof(int)); delete []pBuffer; } auto \u0026map = m_AllSessions.GetPointerMap(); for (auto it=map.begin();it!=map.end();++it) { (*it)-\u003eUpdate(); } } 通过这段代码我们看出，这个函数先是使用std::vector对象的swap()方法把一个公共队列中的数据倒换到一个临时队列中，这是一个很常用的技巧，目的是减小锁的粒度：由于公共的队列需要被生产者和消费者同时使用，我们为了减小加锁的粒度和时间，把当前队列中已有的数据一次性倒换到消费者本地的一个临时队列中来，这样消费者就可以使用这个临时队列了，从而避免了每次都要通过加锁从公共队列中取数据了，提高了效率。接着，我们发现这个队列中的数据是一个个的Session对象，遍历这些Session对象个每个Session对象的连接的对端发数据，同时执行Session对象的Update()方法。具体发了些什么数据，我们后面的文章再研究。\n我们再看一下循环中的第二个函数GetCSUserMgrInstance()-\u003eOnHeartBeatImmediately();，其代码如下：\nINT32 CCSUserMgr::OnHeartBeatImmediately() { OnTimeUpdate(); SynUserAskDBCallBack(); return eNormal; } 这些名字都是自解释的，先是同步时间，再同步数据库的一些操作：\nINT32 CCSUserMgr::SynUserAskDBCallBack(){ while (!m_DBCallbackQueue.empty()){ Buffer* pBuffer = NULL; m_DBCallbackQueue.try_pop(pBuffer); switch (pBuffer-\u003em_LogLevel) { case DBToCS::eQueryUser_DBCallBack: SynHandleQueryUserCallback(pBuffer); break; case DBToCS::eQueryAllAccount_CallBack: SynHandleAllAccountCallback(pBuffer); break; case DBToCS::eMail_CallBack: SynHandleMailCallback(pBuffer); break; case DBToCS::eQueryNotice_CallBack: DBCallBack_QueryNotice(pBuffer); break; default: ELOG(LOG_WARNNING, \"not hv handler:%d\", pBuffer-\u003em_LogLevel); break; } if (pBuffer){ m_DBCallbackQueuePool.ReleaseObejct(pBuffer); } } return 0; } 再看一下while循环中第三个函数m_BattleTimer.Run()；其代码如下：\nvoid CBattleTimer::Run(){ TimeKey nowTime = GetInternalTime(); while(!m_ThreadTimerQueue.empty()){ ThreadTimer\u0026 sThreadTimer = m_ThreadTimerQueue.top(); if (!m_InvalidTimerSet.empty()){ auto iter = m_InvalidTimerSet.find(sThreadTimer.sequence); if (iter != m_InvalidTimerSet.end()){ m_InvalidTimerSet.erase(iter); m_ThreadTimerQueue.pop(); continue; } } if (nowTime \u003e= sThreadTimer.nextexpiredTime){ m_PendingTimer.push_back(sThreadTimer); m_ThreadTimerQueue.pop(); } else{ break; } } if (!m_PendingTimer.empty()){ for (auto iter = m_PendingTimer.begin(); iter != m_PendingTimer.end(); ++iter){ ThreadTimer\u0026 sThreadTimer = *iter; nowTime = GetInternalTime(); int64_t tickSpan = nowTime - sThreadTimer.lastHandleTime; sThreadTimer.pHeartbeatCallback(nowTime, tickSpan); if (sThreadTimer.ifPersist){ TimeKey newTime = nowTime + sThreadTimer.interval; sThreadTimer.lastHandleTime = nowTime; sThreadTimer.nextexpiredTime = newTime; m_ThreadTimerQueue.push(sThreadTimer); } } m_PendingTimer.clear(); } if (!m_ToAddTimer.empty()){ for (auto iter = m_ToAddTimer.begin(); iter != m_ToAddTimer.end(); ++iter){ m_ThreadTimerQueue.push(*iter); } m_ToAddTimer.clear(); } } 这也是一个与时间有关的操作。具体细节我们也在后面文章中介绍。\nCSBattleMgr服务跑起来之后，cmd窗口显示如下：\n上图中我们看到Mysql和redis服务均已连上，但是程序会一直提示连接127.0.0.1:1234端口连不上。由此我们断定，这个使用1234端口的服务没有启动。这不是我们介绍的重点，重点是说明这个服务会定时自动重连这个1234端口，自动重连机制是我们做服务器开发必须熟练开发的一个功能。所以我建议大家好好看一看这一块的代码。这里我带着大家简单梳理一遍吧。\n首先，我们根据提示找到INetSessionMgr::LogText的42行，并在那里加一个断点：\n很快，由于重连机制，触发这个断点，我们看下此时的调用堆栈：\n我们切换到如图箭头所示的堆栈处代码：\n箭头所示说明是mNetModule-\u003eRun();调用产生的日志输出。我们看下这个的调用：\nbool CUCODENetWin::Run(INT32 nCount) { CConnDataMgr::Instance()-\u003eRunConection(); do { // #ifdef UCODENET_HAS_GATHER_SEND // #pragma message(\"[preconfig]sdnet collect buffer, has a internal timer\") // if (m_pTimerModule) // { // m_pTimerModule-\u003eRun(); // } // #endif #ifdef UCODENET_HAS_GATHER_SEND static INT32 sendCnt = 0; ++sendCnt; if (sendCnt == 10) { sendCnt = 0; UINT32 now = GetTickCount(); if (now \u003c m_dwLastTick) { /// 溢出了,发生了数据回绕 \\/// m_dwLastTick = now; } if ((now - m_dwLastTick) \u003e 50) { m_dwLastTick = now; FlushBufferedData(); } } #endif // //SNetEvent stEvent; SNetEvent *pstEvent = CEventMgr::Instance()-\u003ePopFrontNetEvt(); if (pstEvent == NULL) { return false; } SNetEvent \u0026 stEvent = *pstEvent; switch(stEvent.nType) { case NETEVT_RECV: _ProcRecvEvt(\u0026stEvent.stUn.stRecv); break; case NETEVT_SEND: _ProcSendEvt(\u0026stEvent.stUn.stSend); break; case NETEVT_ESTABLISH: _ProcEstablishEvt(\u0026stEvent.stUn.stEstablish); break; case NETEVT_ASSOCIATE: _ProcAssociateEvt(\u0026stEvent.stUn.stAssociate); break; case NETEVT_TERMINATE: _ProcTerminateEvt(\u0026stEvent.stUn.stTerminate); break; case NETEVT_CONN_ERR: _ProcConnErrEvt(\u0026stEvent.stUn.stConnErr); break; case NETEVT_ERROR: _ProcErrorEvt(\u0026stEvent.stUn.stError); break; case NETEVT_BIND_ERR: _ProcBindErrEvt(\u0026stEvent.stUn.stBindErr); break; default: SDASSERT(false); break; } CEventMgr::Instance()-\u003eReleaseNetEvt(pstEvent); }while(--nCount != 0); return true; } 我们看到**SNetEvent *pstEvent = CEventMgr::Instance()-\u003ePopFrontNetEvt();**时，看到这里我们大致可以看出这又是一个生产者消费者模型，只不过这里是消费者——从队列中取出数据，对应的switch-case分支是：\ncase NETEVT_CONN_ERR: _ProcConnErrEvt(\u0026stEvent.stUn.stConnErr); 即连接失败。那么在哪里连接的呢？我们只需要看看这个队列的生产者在哪里就能找到了，因为连接不成功，往队列中放入一条连接出错的数据，我们看一下**CEventMgr::Instance()-\u003ePopFrontNetEvt()**的实现，找到具体的队列名称：\n/** * @brief 获取一个未处理的网络事件(目前为最先插入的网络事件) * @return 返回一个未处理的网络事件.如果处理失败,返回NULL * @remark 由于此类只有在主线程中调用,所以,此函数内部并未保证线程安全 */ inline SNetEvent* PopFrontNetEvt() { return (SNetEvent*)m_oEvtQueue.PopFront(); } 通过这段代码我们发现队列的名字叫m_oEvtQueue，我们通过搜索这个队列的名字找到生产者，然后在生产者往队列中加入数据那里加上一个断点：\n等断点触发以后，我们看下此时的调用堆栈：\n我们切换到上图中箭头所指向的代码处：\n到这里我们基本上认识了，这里连接使用的异步connect()，即在线程A中将连接socket，然后使用WSAEventSelect绑定该socket并设置该socket为非阻塞模式，等连接有结果了（成功或失败）使用Windows API WSAEnumNetworkEvents去检测这个socket的连接事件（FD_CONNECT），然后将判断结果加入队列m_oEvtQueue中，另外一个线程B从队列中取出判断结果打印出日志。如果您不清楚这个流程，请学习一下异步connect的使用方法和WSAEventSelect、WSAEnumNetworkEvents的用法。那么这个异步connect在哪里呢？我们搜索一下socket API connect函数（其实我可以一开始就搜索connect函数的，但是我之所以不这么做是想让您了解一下我研究一个不熟悉的项目代码的思路），得到如下图：\n我们在上述标红的地方加个断点：\n通过上图中的端口信息1234，我们验证了的确是上文说的流程。然后我们观察一下这个调用堆栈：\n发现这里又是一个消费者，又存在一个队列！\n同样的道理，我们通过队列名称m_oReqQueue找到生产者：\n我们看下这个时候的生产者的调用堆栈：\n切换到如图所示的代码处：\nbool ICliSession::Reconnect() { if (IsHadRecon() \u0026\u0026 mReconnectTag) { UINT32 curTime = GetTickCount(); if (curTime\u003emReconTime) { mReconTime = curTime+10000; if (m_poConnector-\u003eReConnect()) { //printf(\"client reconnect server(%s)...\\n\",mRemoteEndPointer.c_str()); ResetRecon(); return true; } } } return false; } 在这里我们终于可以好好看一下重连的逻辑如何设计了。具体代码读者自己分析哈，限于篇幅这里就不介绍了。\n看到这里，可能很多读者在对照我提供的代码时，会产生一个困难：同样的代码为啥在我手中可以这样分析，但是到你们手中可能就磕磕绊绊了？只能说经验和自我学习这是相辅相成的过程，例如上文中说的生产者消费者模式、任务队列，我曾经也和你们一样，也不熟悉这些东西，但是当我知道这些东西时我就去学习这些我认为的“基础”知识，并且反复练习，这样也就慢慢积累经验了。所以，孔子说的没错：学而不思则罔，思而不学则殆。什么时候该去学习，什么时候该去思考，古人诚不欺我也。\n到这里我们也大致清楚了CSBattleMgr做了哪些事情。后面我们把所有的服务都过一遍之后再从整体来介绍。下一篇文章我们将继续研究这个侦听1234端口的LogServer，敬请期待。\n限于作者经验水平有限，文章中可能有错漏的地方，欢迎批评指正。\n欢迎阅读下一篇《从零学习开源项目系列（四） LogServer源码探究》。\n源码下载方法：\n微信搜索公众号 『高性能服务器开发』(中文名：高性能服务器开发)，关注公众号后，在公众号中回复**『英雄联盟』** ，即可得到下载链接。（喷子和代码贩子请远离！）\n",
  "wordCount" : "924",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/86a8b9de9c914f8ab93a3d36b455838b/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      从零学习开源项目系列（三） CSBattleMgr服务源码研究
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%bb%8e%e9%9b%b6%e5%ad%a6%e4%b9%a0%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae%e7%b3%bb%e5%88%97%e4%b8%89-csbattlemgr%e6%9c%8d%e5%8a%a1%e6%ba%90%e7%a0%81%e7%a0%94%e7%a9%b6" aria-label="从零学习开源项目系列（三） CSBattleMgr服务源码研究">从零学习开源项目系列（三） CSBattleMgr服务源码研究</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="从零学习开源项目系列三-csbattlemgr服务源码研究">从零学习开源项目系列（三） CSBattleMgr服务源码研究</h2>
<p>服务器项目工程如下图所示：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/ed8749bd8e5c93e8b536d7d8eb7f8faf.png" alt=""  />
</p>
<p>如上图所示，这篇文章我们将介绍CSBattleMgr的情况，但是我们不会去研究这个服务器的特别细节的东西（这些细节我们将在后面的文章中介绍）。阅读一个未知的项目源码如果我们开始就纠结于各种细节，那么我们最终会陷入“横看成岭侧成峰，远近高低各不同”的尴尬境界，浪费时间不说，可能收获也是事倍功半。所以，尽管我们不熟悉这套代码，我们还是尽量先从整体来把握，先大致了解各个服务的功能，细节部分回头再针对性地去研究。</p>
<p>这个系列的第二篇文章《<a href="http://mp.weixin.qq.com/s?__biz=MzU2MTQ1MzI3NQ==&amp;mid=2247484623&amp;idx=1&amp;sn=70998483d3a394db444bf2b7e76548a9&amp;chksm=fc79c57bcb0e4c6dfe15b6a62dfa8f083861a757dfcff2faa381dc56a9d4f2a3b2e190da6caa&amp;scene=21#wechat_redirect">从零学习开源项目系列（二） 最后一战概况</a>》中我们介绍了，这套游戏的服务需要使用redis和mysql，我们先看下mysql是否准备好了（mysql服务启动起来，数据库建表数据存在，具体细节请参考第二篇文章）。打开Windows的cmd程序，输入以下指令连接mysql：</p>
<pre tabindex="0"><code>mysql -uroot -p123321  
</code></pre><p>连接成功以后，如下图所示：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/a540bf689fd20e3d5dbc214d3972fa4e.png" alt=""  />
</p>
<p>然后我们输入以下指令，查看我们需要的数据库是否创建成功：</p>
<pre tabindex="0"><code>show databases;  
</code></pre><p>这些都是基本的sql语句，如果您不熟悉的话，可能需要专门学习一下。</p>
<p>数据库创建成功后如下图所示：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/a17cc0d6d3bac682042e172e08c7ef75.webp" alt=""  />
</p>
<p>至于数据库中的表是否创建成功，我们这里先不关注，后面我们实际用到哪张数据表，我们再去研究。</p>
<p>mysql没问题了，接下来我们要启动一下redis，通过第二篇文章我们知道redis需要启动两次，也就是一共两个redis进程，我们游戏服务中分别称为<strong>redis-server</strong>和<strong>redis-login-server</strong>（它们的配置文件信息不一样），我们可以在<strong>Server\Bin\x64\Release</strong>目录下手动cmd命令行执行下列语句：</p>
<pre tabindex="0"><code>start /min &#34;redis-server&#34; &#34;redis-server.exe&#34; redis.conf  
start /min &#34;redis-Logicserver&#34; &#34;redis-server.exe&#34; redis-logic.conf  
</code></pre><p>但是这样比较麻烦，我将这两句拷贝出来，放入一个叫start-redis.bat文件中了，每次启动只要执行一下这个bat文件就可以：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/db93f1241930c322a8633608d2358cda.webp" alt=""  />
</p>
<p>redis和redis-logic服务启动后如下图所示：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/370ec9d8491e1f8c964877e22a962419.webp" alt=""  />
</p>
<p>我们常见的redis服务都是linux下的源码，微软公司对redis源码进行了改造，出了一个Windows版本，稍微有点不尽人意（例如：Windows下没有完全与linux的fork()相匹配的API，所以只能用CreateProcess()去替代）。关于windows版本的redis源码官方下载地址为：https://github.com/MicrosoftArchive/redis/releases。</p>
<p>在启动好了mysql和redis后，我们现在正式来看一下CSBattleMgr这个服务。读者不禁可能要问，那么多服务，你怎么知道要先看这个服务呢？我们<a href="http://mp.weixin.qq.com/s?__biz=MzU2MTQ1MzI3NQ==&amp;mid=2247484623&amp;idx=1&amp;sn=70998483d3a394db444bf2b7e76548a9&amp;chksm=fc79c57bcb0e4c6dfe15b6a62dfa8f083861a757dfcff2faa381dc56a9d4f2a3b2e190da6caa&amp;scene=21#wechat_redirect">上一篇文章</a>中也说过，我们再start.bat文件中发现除了redis以外，这是第三个需要启动的服务，所以我们先研究它（start.bat我们可以认为是源码作者为我们留下的部署步骤“文档”）：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/54fc1bc091d3f364a3fe21eb0bfb6ae1.webp" alt=""  />
</p>
<p>我们打开CSBattleMgr服务main.cpp文件，找到入口main函数，内容如下：</p>
<pre tabindex="0"><code>int main(){  
    DbgLib::CDebugFx::SetExceptionHandler(true);  
    DbgLib::CDebugFx::SetExceptionCallback(ExceptionCallback, NULL);  
    GetCSKernelInstance();  
    GetCSUserMgrInstance();  
    GetBattleMgrInstance();  
    GetCSKernelInstance()-&gt;Initialize();  
    GetBattleMgrInstance()-&gt;Initialize();  
    GetCSUserMgrInstance()-&gt;Initialize();  
    GetCSKernelInstance()-&gt;Start();  
    mysql_library_init(0, NULL, NULL);  
    GetCSKernelInstance()-&gt;MainLoop();  
}  
</code></pre><p>通过调试，我们发下这个函数大致做了以下任务：</p>
<pre tabindex="0"><code>//1. 设置程序异常处理函数  
//2. 初始化一系列单例对象  
//3. 初始化mysql  
//4. 进入一个被称作“主循环”的无限循环  
</code></pre><p><strong>步骤1</strong>设置程序异常处理函数没有好介绍的，我们看一下<strong>步骤2</strong>初始化一系列单例对象，总共初始化了三个类的对象<strong>CCSKernel</strong>、<strong>CCSUserMgr</strong>和<strong>CCSBattleMgr</strong>。单例模式本身没啥好介绍的，但是有人要提单例模式的线程安全性，所以出现很多通过加锁的单例模式代码，我个人觉得没必要；认为要加锁的朋友可能认为单例对象如果在第一次初始化时同时被多个线程调用就会有问题，我觉得加锁带来的开销还不如像上面的代码一样，在整个程序初始化初期获取一下单例对象，让单例对象生成出来，后面即使多个线程获取这个单例对象也都是读操作，无需加锁。以GetCSKernelInstance();为例：</p>
<pre tabindex="0"><code>CCSKernel* GetCSKernelInstance(){  
    return &amp;CCSKernel::GetInstance();  
}  

CCSKernel&amp; CCSKernel::GetInstance(){  
    if (NULL == pInstance){  
        pInstance = new CCSKernel;  
    }  
    return *pInstance;  
}  
</code></pre><p>GetCSKernelInstance()-&gt;Initialize()的初始化动作其实是加载各种配置信息和事先设置一系列的回调函数和定时器：</p>
<pre tabindex="0"><code>INT32   CCSKernel::Initialize()  
{  
    //JJIAZ加载配置的时候 不要随便调整顺序  
    CCSCfgMgr::getInstance().Initalize();   
    INT32 n32Init = LoadCfg();     
    if (eNormal != n32Init)  
    {  
        ELOG(LOG_ERROR,&#34; loadCfg()............failed!&#34;);  
        return n32Init;  
    }  
    if(m_sCSKernelCfg.un32MaxSSNum &gt; 0 )  
    {  
        m_psSSNetInfoList = new SSSNetInfo[m_sCSKernelCfg.un32MaxSSNum];  
        memset(m_psSSNetInfoList, 0, sizeof(SSSNetInfo) * m_sCSKernelCfg.un32MaxSSNum);  
        m_psGSNetInfoList = new SGSNetInfo[m_sCSKernelCfg.un32MaxGSNum];  
        memset(m_psGSNetInfoList, 0, sizeof(SGSNetInfo) * m_sCSKernelCfg.un32MaxGSNum);  
        m_psRCNetInfoList = new SRCNetInfo[10];  
    }  
    m_GSMsgHandlerMap[GSToCS::eMsgToCSFromGS_AskRegiste] = std::bind(&amp;CCSKernel::OnMsgFromGS_AskRegiste, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);  
    m_GSMsgHandlerMap[GSToCS::eMsgToCSFromGS_AskPing] = std::bind(&amp;CCSKernel::OnMsgFromGS_AskPing, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);  
    m_GSMsgHandlerMap[GSToCS::eMsgToCSFromGS_ReportGCMsg] = std::bind(&amp;CCSKernel::OnMsgFromGS_ReportGCMsg, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);  
    m_SSMsgHandlerMap[SSToCS::eMsgToCSFromSS_AskPing] = std::bind(&amp;CCSKernel::OnMsgFromSS_AskPing, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);  
    AddTimer(std::bind(&amp;CCSKernel::ProfileReport, this, std::placeholders::_1, std::placeholders::_2), 5000, true);  
    return eNormal;  
}  
</code></pre><p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/6e46216a2dcaefc86710729eb92dbbfd.webp" alt=""  />
</p>
<p>如上图所示，这些配置信息都是游戏术语，包括各种技能、英雄、模型等信息。</p>
<p>GetBattleMgrInstance()-&gt;Initialize()其实是帮CSKernel对象启动一个定时器：</p>
<pre tabindex="0"><code>INT32   CCSBattleMgr::Initialize(){  
    GetCSKernelInstance()-&gt;AddTimer(std::bind(&amp;CCSMatchMgr::Update, m_pMatchMgr, std::placeholders::_1, std::placeholders::_2), c_matcherDelay, true);  
    return eNormal;  
}  
</code></pre><p>GetCSUserMgrInstance()-&gt;Initialize()是初始化mysql和redis的一些相关信息，由于redis是做服务的缓存的，所以我们一般在项目中看到cacheServer这样的字眼指的都是redis：</p>
<pre tabindex="0"><code>void CCSUserMgr::Initialize(){  
    SDBCfg cfgGameDb = CCSCfgMgr::getInstance().GetDBCfg(eDB_GameDb);  
    SDBCfg cfgCdkeyDb=CCSCfgMgr::getInstance().GetDBCfg(eDB_CdkeyDb);   
    m_UserCacheDBActiveWrapper = new DBActiveWrapper( std::bind(&amp;CCSUserMgr::UserCacheDBAsynHandler, this, std::placeholders::_1), cfgGameDb, std::bind(&amp;CCSUserMgr::DBAsyn_QueryWhenThreadBegin, this) );  
    m_UserCacheDBActiveWrapper-&gt;Start();  
    m_CdkeyWrapper = new DBActiveWrapper( std::bind(&amp;CCSUserMgr::UserAskDBAsynHandler, this, std::placeholders::_1), cfgCdkeyDb, std::bind(&amp;CCSUserMgr::CDKThreadBeginCallback, this) );  
    m_CdkeyWrapper-&gt;Start();  
    for (int i = 0; i &lt; gThread ; i++)  
    {  
        DBActiveWrapper* pThreadDBWrapper(new DBActiveWrapper(std::bind(&amp;CCSUserMgr::UserAskDBAsynHandler, this, std::placeholders::_1), cfgGameDb));  
        pThreadDBWrapper-&gt;Start();  
        m_pUserAskDBActiveWrapperVec.push_back(pThreadDBWrapper);  
    }   
}  
</code></pre><p>注意一点：不知道大家有没有发现，我们代码中大量使用C++11中的std::bind()这样函数，注意由于我们使用的Visual Studio版本是2010，2010这个版本是不支持C++11的，所以这里的std::bind不是C++11的，而是C++11发布之前的草案tr1中的，所以全部的命名空间应该是tr1::std::bind，其他的类似C++11的功能也是一样，所以你在代码中可以看到这样引入命名空间的语句：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/cf887608f86df22ba60428fe5a2dfbb4.webp" alt=""  />
</p>
<p>GetCSKernelInstance()-&gt;Start();是初始化所有的网络连接的Session管理器，所谓Session，中文译为“会话”，其下层对应网络通信的连接，每一路连接对应一个Session，而管理这些Session的对象就是Session Manager，在我们的代码中是<strong>CSNetSessionMgr</strong>，它继承自接口类<strong>INetSessionMgr</strong>：</p>
<pre tabindex="0"><code>class CSNetSessionMgr : public INetSessionMgr  
{  
public:  
    CSNetSessionMgr();  
    virtual ~CSNetSessionMgr();  
public:  
    virtual ISDSession* UCAPI CreateSession(ISDConnection* pConnection) { return NULL; /*重写*/}  
    virtual ICliSession* UCAPI CreateConnectorSession(SESSION_TYPE type);  
    virtual bool CreateConnector(SESSION_TYPE type, const char* ip, int port, int recvsize, int sendsize, int logicId);  
private:  
    CSParser m_CSParser;  
};  
</code></pre><p>初始化CSNetSessionMgr的代码如下：</p>
<pre tabindex="0"><code>INT32   CCSKernel::Start()  
{  
    CSNetSessionMgr* pNetSession = new CSNetSessionMgr;  
    GetBattleMgrInstance()-&gt;RegisterMsgHandle(m_SSMsgHandlerMap, m_GSMsgHandlerMap,  m_GCMsgHandlerMap, m_RCMsgHandlerMap);  
    GetCSUserMgrInstance()-&gt;RegisterMsgHandle(m_SSMsgHandlerMap, m_GSMsgHandlerMap,  m_GCMsgHandlerMap, m_RCMsgHandlerMap);  
    ELOG(LOG_INFO, &#34;success!&#34;);  
    return 0;  
}  
</code></pre><p>连接数据库成功以后，我们的CSBattleMgr程序的控制台会显示一行提示mysql连接成功：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/61df5fc518285e0b35bf146c7360a02a.webp" alt=""  />
</p>
<p>读者看上图会发现，这些日志信息有三个颜色，出错信息使用红色，重要的正常信息使用绿色，一般的输出信息使用灰色。这是如何实现的呢？我们将在下一篇文章《从零学习开源项目系列（三） LogServer服务源码研究》中介绍具体实现原理，这也是一种不错的日志级别提醒方式。</p>
<p>介绍完了初始化流程，我们介绍一下这个服务的主体部分MainLoop()函数，先看一下整体代码：</p>
<pre tabindex="0"><code> void CCSKernel::MainLoop(){
    TIME_TICK    tHeartBeatCDTick = 10;
    //侦听端口10002
    INetSessionMgr::GetInstance()-&gt;CreateListener(m_sCSKernelCfg.n32GSNetListenerPort, 1024000, 10240000, 0, &amp;gGateSessionFactory);
    //侦听端口10001
    INetSessionMgr::GetInstance()-&gt;CreateListener(m_sCSKernelCfg.n32SSNetListenerPort, 1024000, 10240000, 1, &amp;gSceneSessionFactory);
    //侦听端口10010
    INetSessionMgr::GetInstance()-&gt;CreateListener(m_sCSKernelCfg.n32RCNetListenerPort, 1024000, 10240000, 2, &amp;gRemoteConsoleFactory);
    //连接LogServer 1234端口
    INetSessionMgr::GetInstance()-&gt;CreateConnector(ST_CLIENT_C2Log, m_sCSKernelCfg.LogAddress.c_str(), m_sCSKernelCfg.LogPort, 102400, 102400, 0);
    //连接redis 6379
    if (m_sCSKernelCfg.redisAddress != &#34;0&#34;){
        INetSessionMgr::GetInstance()-&gt;CreateConnector(ST_CLIENT_C2R, m_sCSKernelCfg.redisAddress.c_str(), m_sCSKernelCfg.redisPort, 102400, 102400, 0);
    }
    //连接redis 6380，也是redis-logic
    if (m_sCSKernelCfg.redisLogicAddress != &#34;0&#34;){
        INetSessionMgr::GetInstance()-&gt;CreateConnector(ST_CLIENT_C2LogicRedis, m_sCSKernelCfg.redisLogicAddress.c_str(), m_sCSKernelCfg.redisLogicPort, 102400, 102400, 0);
    }
    while (true)
    {
        if (kbhit())
        {
            static char CmdArray[1024] = { 0 };
            static int CmdPos = 0;
            char CmdOne = getche();
            CmdArray[CmdPos++] = CmdOne;
            bool bRet = 0;
            if (CmdPos &gt;= 1024 || CmdOne == 13)
            { 
                CmdArray[--CmdPos] = 0; 
                bRet = DoUserCmd(CmdArray);
                CmdPos = 0; 
                if (bRet) 
                    break; 
            }
        }
        INetSessionMgr::GetInstance()-&gt;Update();
        GetCSUserMgrInstance()-&gt;OnHeartBeatImmediately();
        ++m_RunCounts;
        m_BattleTimer.Run();
        Sleep(1);
    }
}
</code></pre><p>这个函数虽然叫MainLoop()，但是实际MainLoop()只是后半部分，前半部分总共创建三个侦听端口和三个连接器，也就是所谓的Listener和Connector，这些对象都是由上文提到的CSNetSessionMgr管理，所谓Listener就是这个服务使用socket API bind()和listen()函数在某个地址+端口号的二元组上绑定，供其他程序连接（其他程序可能是其他服务程序也可能是客户端，具体是哪个，我们后面的文章再进一步挖掘），侦听端口统计如下：</p>
<ul>
<li>侦听端口10002</li>
<li>侦听端口10001</li>
<li>侦听端口10010</li>
</ul>
<p>连接器（Connector）也有三个，分别连接的服务和端口号是：</p>
<ul>
<li>连接redis的6379号端口</li>
<li>连接redis-logic的6380端口</li>
<li>连接某服务的1234端口</li>
</ul>
<p>这个1234端口到底是哪个服务的呢？通过代码我们可以看出是LogServer的，那么到底是不是LogServer的呢，我们后面具体求证一下。</p>
<pre tabindex="0"><code>INetSessionMgr::GetInstance()-&gt;CreateConnector( ST_CLIENT_C2Log, 
                                                m_sCSKernelCfg.LogAddress.c_str(), 
                                                m_sCSKernelCfg.LogPort, 
                                                102400, 
                                                102400, 
                                                0);
</code></pre><p>接着我们就正式进入了一个while循环：</p>
<pre tabindex="0"><code>while (true)
{
    if (kbhit())
    {
        static char CmdArray[1024] = { 0 };
        static int CmdPos = 0;
        char CmdOne = getche();
        CmdArray[CmdPos++] = CmdOne;
        bool bRet = 0;
        if (CmdPos &gt;= 1024 || CmdOne == 13) 
        { 
            CmdArray[--CmdPos] = 0; 
            bRet = DoUserCmd(CmdArray);
            CmdPos = 0; 
            if (bRet) 
                break;
        }
    }
    INetSessionMgr::GetInstance()-&gt;Update();
    GetCSUserMgrInstance()-&gt;OnHeartBeatImmediately();
    ++m_RunCounts;
    m_BattleTimer.Run();
    Sleep(1);
}
</code></pre><p>循环具体做了啥，我们先看**INetSessionMgr::GetInstance()-&gt;Update();**代码：</p>
<pre tabindex="0"><code>void INetSessionMgr::Update()  
{  
    mNetModule-&gt;Run();  
    vector&lt;char*&gt; tempQueue;  
    EnterCriticalSection(&amp;mNetworkCs);  
    tempQueue.swap(m_SafeQueue);  
    LeaveCriticalSection(&amp;mNetworkCs);  
    for (auto it=tempQueue.begin();it!=tempQueue.end();++it){  
        char* pBuffer = (*it);  
        int nType = *(((int*)pBuffer)+0);  
        int nSessionID = *(((int*)pBuffer)+1);  
        Send((SESSION_TYPE)nType,nSessionID,pBuffer+2*sizeof(int));  
        delete []pBuffer;  
    }  
    auto &amp;map = m_AllSessions.GetPointerMap();  
    for (auto it=map.begin();it!=map.end();++it)  
    {  
        (*it)-&gt;Update();  
    }  
}  
</code></pre><p>通过这段代码我们看出，这个函数先是使用std::vector对象的swap()方法把一个公共队列中的数据倒换到一个临时队列中，这是一个很常用的技巧，目的是减小锁的粒度：由于公共的队列需要被生产者和消费者同时使用，我们为了减小加锁的粒度和时间，把当前队列中已有的数据一次性倒换到消费者本地的一个临时队列中来，这样消费者就可以使用这个临时队列了，从而避免了每次都要通过加锁从公共队列中取数据了，提高了效率。接着，我们发现这个队列中的数据是一个个的Session对象，遍历这些Session对象个每个Session对象的连接的对端发数据，同时执行Session对象的Update()方法。具体发了些什么数据，我们后面的文章再研究。</p>
<p>我们再看一下循环中的第二个函数<strong>GetCSUserMgrInstance()-&gt;OnHeartBeatImmediately();</strong>，其代码如下：</p>
<pre tabindex="0"><code>INT32 CCSUserMgr::OnHeartBeatImmediately()  
{  
    OnTimeUpdate();  
    SynUserAskDBCallBack();  
    return eNormal;  
}  
</code></pre><p>这些名字都是自解释的，先是同步时间，再同步数据库的一些操作：</p>
<pre tabindex="0"><code>INT32 CCSUserMgr::SynUserAskDBCallBack(){  
    while (!m_DBCallbackQueue.empty()){  
        Buffer* pBuffer = NULL;  
        m_DBCallbackQueue.try_pop(pBuffer);  
        switch (pBuffer-&gt;m_LogLevel)  
        {  
        case DBToCS::eQueryUser_DBCallBack:  
            SynHandleQueryUserCallback(pBuffer);  
            break;  
        case DBToCS::eQueryAllAccount_CallBack:  
            SynHandleAllAccountCallback(pBuffer);  
            break;  
        case DBToCS::eMail_CallBack:  
            SynHandleMailCallback(pBuffer);  
            break;  
        case  DBToCS::eQueryNotice_CallBack:  
            DBCallBack_QueryNotice(pBuffer);  
            break;  
        default:  
            ELOG(LOG_WARNNING, &#34;not hv handler:%d&#34;, pBuffer-&gt;m_LogLevel);  
            break;  
        }  
        if (pBuffer){  
            m_DBCallbackQueuePool.ReleaseObejct(pBuffer);  
        }  
    }  
    return 0;  
}  
</code></pre><p>再看一下while循环中第三个函数m_BattleTimer.Run()；其代码如下：</p>
<pre tabindex="0"><code>void CBattleTimer::Run(){  
    TimeKey nowTime = GetInternalTime();  
    while(!m_ThreadTimerQueue.empty()){  
        ThreadTimer&amp; sThreadTimer = m_ThreadTimerQueue.top();  
        if (!m_InvalidTimerSet.empty()){  
            auto iter = m_InvalidTimerSet.find(sThreadTimer.sequence);  
            if (iter != m_InvalidTimerSet.end()){  
                m_InvalidTimerSet.erase(iter);  
                m_ThreadTimerQueue.pop();  
                continue;  
            }  
        }  
        if (nowTime &gt;=  sThreadTimer.nextexpiredTime){  
            m_PendingTimer.push_back(sThreadTimer);  
            m_ThreadTimerQueue.pop();  
        }  
        else{  
            break;  
        }  
    }  
    if (!m_PendingTimer.empty()){  
        for (auto iter = m_PendingTimer.begin(); iter != m_PendingTimer.end(); ++iter){  
            ThreadTimer&amp; sThreadTimer = *iter;  
            nowTime = GetInternalTime();  
            int64_t tickSpan = nowTime - sThreadTimer.lastHandleTime;  
            sThreadTimer.pHeartbeatCallback(nowTime, tickSpan);  
            if (sThreadTimer.ifPersist){  
                TimeKey newTime = nowTime + sThreadTimer.interval;  
                sThreadTimer.lastHandleTime = nowTime;  
                sThreadTimer.nextexpiredTime = newTime;  
                m_ThreadTimerQueue.push(sThreadTimer);  
            }  
        }  
        m_PendingTimer.clear();  
    }  
    if (!m_ToAddTimer.empty()){  
        for (auto iter = m_ToAddTimer.begin(); iter != m_ToAddTimer.end(); ++iter){  
            m_ThreadTimerQueue.push(*iter);  
        }  
        m_ToAddTimer.clear();  
    }  
}  
</code></pre><p>这也是一个与时间有关的操作。具体细节我们也在后面文章中介绍。</p>
<p>CSBattleMgr服务跑起来之后，cmd窗口显示如下：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/ad3a5cfcf5e98cd18f87c25469eb564f.webp" alt=""  />
</p>
<p>上图中我们看到Mysql和redis服务均已连上，但是程序会一直提示连接<strong>127.0.0.1:1234</strong>端口连不上。由此我们断定，这个使用1234端口的服务没有启动。这不是我们介绍的重点，重点是说明这个服务会定时自动重连这个1234端口，自动重连机制是我们做服务器开发必须熟练开发的一个功能。所以我建议大家好好看一看这一块的代码。这里我带着大家简单梳理一遍吧。</p>
<p>首先，我们根据提示找到INetSessionMgr::LogText的42行，并在那里加一个断点：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/ac3e79b294a431740782d35fe15449c2.webp" alt=""  />
</p>
<p>很快，由于重连机制，触发这个断点，我们看下此时的调用堆栈：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/9b36cdcea535061f29c69cf0f22e4e13.webp" alt=""  />
</p>
<p>我们切换到如图箭头所示的堆栈处代码：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/73757503b07440880908e39085c77aab.webp" alt=""  />
</p>
<p>箭头所示说明是mNetModule-&gt;Run();调用产生的日志输出。我们看下这个的调用：</p>
<pre tabindex="0"><code>bool CUCODENetWin::Run(INT32 nCount)  
{  
    CConnDataMgr::Instance()-&gt;RunConection();  
    do  
    {  
// #ifdef UCODENET_HAS_GATHER_SEND         
// #pragma message(&#34;[preconfig]sdnet collect buffer, has a internal timer&#34;)          
//         if (m_pTimerModule)          
//         {  
//             m_pTimerModule-&gt;Run();  
//         }          
// #endif  
#ifdef UCODENET_HAS_GATHER_SEND   
        static INT32 sendCnt = 0;  
        ++sendCnt;  
        if (sendCnt == 10)  
        {  
            sendCnt = 0;  
            UINT32 now = GetTickCount();  
            if (now &lt; m_dwLastTick)  
            {  
                /// 溢出了,发生了数据回绕 \///  
                m_dwLastTick = now;  
            }  
            if ((now - m_dwLastTick) &gt; 50)  
            {  
                m_dwLastTick = now;              
                FlushBufferedData();  
            }  
        }         
#endif //   
        //SNetEvent stEvent;   
        SNetEvent *pstEvent  = CEventMgr::Instance()-&gt;PopFrontNetEvt();  
        if (pstEvent == NULL)  
        {  
            return false;  
        }  
        SNetEvent &amp; stEvent = *pstEvent;   
        switch(stEvent.nType)  
        {  
        case NETEVT_RECV:  
            _ProcRecvEvt(&amp;stEvent.stUn.stRecv);  
            break;  
        case NETEVT_SEND:  
            _ProcSendEvt(&amp;stEvent.stUn.stSend);   
            break;   
        case NETEVT_ESTABLISH:  
            _ProcEstablishEvt(&amp;stEvent.stUn.stEstablish);  
            break;  
        case NETEVT_ASSOCIATE:  
            _ProcAssociateEvt(&amp;stEvent.stUn.stAssociate);  
            break;  
        case NETEVT_TERMINATE:  
            _ProcTerminateEvt(&amp;stEvent.stUn.stTerminate);  
            break;  
        case NETEVT_CONN_ERR:  
            _ProcConnErrEvt(&amp;stEvent.stUn.stConnErr);  
            break;  
        case NETEVT_ERROR:  
            _ProcErrorEvt(&amp;stEvent.stUn.stError);  
            break;  
        case NETEVT_BIND_ERR:  
            _ProcBindErrEvt(&amp;stEvent.stUn.stBindErr);  
            break;  
        default:  
            SDASSERT(false);  
            break;  
        }  
        CEventMgr::Instance()-&gt;ReleaseNetEvt(pstEvent);   
    }while(--nCount != 0);  
    return true;  
}  
</code></pre><p>我们看到**SNetEvent *pstEvent = CEventMgr::Instance()-&gt;PopFrontNetEvt();**时，看到这里我们大致可以看出这又是一个生产者消费者模型，只不过这里是消费者——从队列中取出数据，对应的switch-case分支是：</p>
<pre tabindex="0"><code>case NETEVT_CONN_ERR:  
    _ProcConnErrEvt(&amp;stEvent.stUn.stConnErr);  
</code></pre><p>即连接失败。那么在哪里连接的呢？我们只需要看看这个队列的生产者在哪里就能找到了，因为连接不成功，往队列中放入一条连接出错的数据，我们看一下**CEventMgr::Instance()-&gt;PopFrontNetEvt()**的实现，找到具体的队列名称：</p>
<pre tabindex="0"><code>/** 
 * @brief 获取一个未处理的网络事件(目前为最先插入的网络事件) 
 * @return 返回一个未处理的网络事件.如果处理失败,返回NULL 
 * @remark 由于此类只有在主线程中调用,所以,此函数内部并未保证线程安全 
 */  
inline SNetEvent*  PopFrontNetEvt()  
{  
    return  (SNetEvent*)m_oEvtQueue.PopFront();  
}  
</code></pre><p>通过这段代码我们发现队列的名字叫m_oEvtQueue，我们通过搜索这个队列的名字找到生产者，然后在生产者往队列中加入数据那里加上一个断点：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/6332febab5741cb51f65bb560d272472.webp" alt=""  />
</p>
<p>等断点触发以后，我们看下此时的调用堆栈：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/f50120b36e0ebbcf2bca0fc779bb7530.webp" alt=""  />
</p>
<p>我们切换到上图中箭头所指向的代码处：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/c91fb549d9c264b0da1fa8764c1ec6a8.webp" alt=""  />
</p>
<p>到这里我们基本上认识了，这里连接使用的<strong>异步connect()</strong>，即在线程A中将连接socket，然后使用<strong>WSAEventSelect</strong>绑定该socket并设置该socket为非阻塞模式，等连接有结果了（成功或失败）使用Windows API <strong>WSAEnumNetworkEvents</strong>去检测这个socket的连接事件（FD_CONNECT），然后将判断结果加入队列m_oEvtQueue中，另外一个线程B从队列中取出判断结果打印出日志。如果您不清楚这个流程，请学习一下异步connect的使用方法和WSAEventSelect、WSAEnumNetworkEvents的用法。那么这个异步connect在哪里呢？我们搜索一下socket API connect函数（其实我可以一开始就搜索connect函数的，但是我之所以不这么做是想让您了解一下我研究一个不熟悉的项目代码的思路），得到如下图：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/c5c7af02b9cc8c23cff1970655a7c27c.webp" alt=""  />
</p>
<p>我们在上述标红的地方加个断点：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/2fbe4fd1a6119706a62bc0045c01221e.webp" alt=""  />
</p>
<p>通过上图中的端口信息1234，我们验证了的确是上文说的流程。然后我们观察一下这个调用堆栈：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/540910639fc3ff0f1528522607884f52.webp" alt=""  />
</p>
<p>发现这里又是一个消费者，又存在一个队列！</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/540910639fc3ff0f1528522607884f52.webp" alt=""  />
</p>
<p>同样的道理，我们通过队列名称m_oReqQueue找到生产者：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/1a116fcbb17464c36748734f4b30190b.webp" alt=""  />
</p>
<p>我们看下这个时候的生产者的调用堆栈：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/09e1fff30e407609d2d82229c17d139f.webp" alt=""  />
</p>
<p>切换到如图所示的代码处：</p>
<pre tabindex="0"><code>bool ICliSession::Reconnect()  
{  
    if (IsHadRecon() &amp;&amp; mReconnectTag)  
    {  
        UINT32 curTime = GetTickCount();  
        if (curTime&gt;mReconTime)  
        {  
            mReconTime = curTime+10000;  
            if (m_poConnector-&gt;ReConnect())  
            {  
                //printf(&#34;client reconnect server(%s)...\n&#34;,mRemoteEndPointer.c_str());  
                ResetRecon();  
                return true;  
            }  
        }  
    }  
    return false;  
}  
</code></pre><p>在这里我们终于可以好好看一下重连的逻辑如何设计了。具体代码读者自己分析哈，限于篇幅这里就不介绍了。</p>
<p>看到这里，可能很多读者在对照我提供的代码时，会产生一个困难：同样的代码为啥在我手中可以这样分析，但是到你们手中可能就磕磕绊绊了？只能说经验和自我学习这是相辅相成的过程，例如上文中说的生产者消费者模式、任务队列，我曾经也和你们一样，也不熟悉这些东西，但是当我知道这些东西时我就去学习这些我认为的“基础”知识，并且反复练习，这样也就慢慢积累经验了。所以，孔子说的没错：<strong>学而不思则罔，思而不学则殆</strong>。什么时候该去学习，什么时候该去思考，古人诚不欺我也。</p>
<p>到这里我们也大致清楚了CSBattleMgr做了哪些事情。后面我们把所有的服务都过一遍之后再从整体来介绍。下一篇文章我们将继续研究这个侦听1234端口的LogServer，敬请期待。</p>
<p>限于作者经验水平有限，文章中可能有错漏的地方，欢迎批评指正。</p>
<p>欢迎阅读下一篇《从零学习开源项目系列（四） LogServer源码探究》。</p>
<blockquote>
<p>源码下载方法：</p>
<p>微信搜索公众号 <strong>『高性能服务器开发』</strong>(中文名：高性能服务器开发)，关注公众号后，在公众号中回复**『英雄联盟』** ，即可得到下载链接。（喷子和代码贩子请远离！）</p>
</blockquote>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/416ada8e33704bdcadd3202dd2413740/">
    <span class="title">« Prev</span>
    <br>
    <span>从零学习开源项目系列（一） 从一款多人联机实时对战游戏开始</span>
  </a>
  <a class="next" href="https://haokiu.com/92d9492b21aa444d81eb4f31c1bfabb1/">
    <span class="title">Next »</span>
    <br>
    <span>从零学习开源项目系列（二） 最后一战概况</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
