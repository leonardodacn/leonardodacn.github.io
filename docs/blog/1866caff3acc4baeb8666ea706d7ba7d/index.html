<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>06 服务器端login_server源码分析 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="06 服务器端login_server源码分析 login_server从严格意义上来说，是一个登录分流器，所以名字起的有点名不符实。该服务根据已知的msg_server上的在线用户数量来返回告诉一个即将登录的用户登录哪个msg_server比较合适。关于其程序框架的非业务代码我们已经在前面的两篇文章《服务器端db_proxy_server源码分析》和《服务器端msg_server源码分析》中介绍过了。这篇文章主要介绍下其业务代码。
首先，程序初始化的时候，会初始化如下功能：
//1. 在8008端口监听客户端连接 //2. 在8100端口上监听msg_server的连接 //3. 在8080端口上监听客户端http连接 其中连接对象CLoginConn代表着login_server与msg_server之间的连接；而CHttpConn代表着与客户端的http连接。我们先来看CLoginConn对象，上一篇文章中也介绍了其业务代码主要在其HandlePdu()函数中，可以看到这路连接主要处理哪些数据包：
void CLoginConn::HandlePdu(CImPdu* pPdu) { switch (pPdu-&gt;GetCommandId()) { case CID_OTHER_HEARTBEAT: break; case CID_OTHER_MSG_SERV_INFO: _HandleMsgServInfo(pPdu); break; case CID_OTHER_USER_CNT_UPDATE: _HandleUserCntUpdate(pPdu); break; case CID_LOGIN_REQ_MSGSERVER: _HandleMsgServRequest(pPdu); break; default: log(&#34;wrong msg, cmd id=%d &#34;, pPdu-&gt;GetCommandId()); break; } } 命令号CID_OTHER_HEARTBEAT是与msg_server的心跳包。上一篇文章《服务器端msg_server源码分析》中介绍过，msg_server连上login_server后会立刻给login_server发一个数据包，该数据包里面含有该msg_server上的用户数量、最大可容纳的用户数量、自己的ip地址和端口号。
list&lt;user_conn_t&gt; user_conn_list; CImUserManager::GetInstance()-&gt;GetUserConnCnt(&amp;user_conn_list, cur_conn_cnt); char hostname[256] = {0}; gethostname(hostname, 256); IM::Server::IMMsgServInfo msg; msg.set_ip1(g_msg_server_ip_addr1); msg.set_ip2(g_msg_server_ip_addr2); msg.set_port(g_msg_server_port); msg.set_max_conn_cnt(g_max_conn_cnt); msg.set_cur_conn_cnt(cur_conn_cnt); msg.set_host_name(hostname); CImPdu pdu; pdu.SetPBMsg(&amp;msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_MSG_SERV_INFO); SendPdu(&amp;pdu); 命令号是CID_OTHER_MSG_SERV_INFO。我们来看下login_server如何处理这个命令的：
void CLoginConn::_HandleMsgServInfo(CImPdu* pPdu) { msg_serv_info_t* pMsgServInfo = new msg_serv_info_t; IM::Server::IMMsgServInfo msg; msg.ParseFromArray(pPdu-&gt;GetBodyData(), pPdu-&gt;GetBodyLength()); pMsgServInfo-&gt;ip_addr1 = msg.ip1(); pMsgServInfo-&gt;ip_addr2 = msg.ip2(); pMsgServInfo-&gt;port = msg.port(); pMsgServInfo-&gt;max_conn_cnt = msg.max_conn_cnt(); pMsgServInfo-&gt;cur_conn_cnt = msg.cur_conn_cnt(); pMsgServInfo-&gt;hostname = msg.host_name(); g_msg_serv_info.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/blog/1866caff3acc4baeb8666ea706d7ba7d/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="06 服务器端login_server源码分析" />
<meta property="og:description" content="06 服务器端login_server源码分析 login_server从严格意义上来说，是一个登录分流器，所以名字起的有点名不符实。该服务根据已知的msg_server上的在线用户数量来返回告诉一个即将登录的用户登录哪个msg_server比较合适。关于其程序框架的非业务代码我们已经在前面的两篇文章《服务器端db_proxy_server源码分析》和《服务器端msg_server源码分析》中介绍过了。这篇文章主要介绍下其业务代码。
首先，程序初始化的时候，会初始化如下功能：
//1. 在8008端口监听客户端连接 //2. 在8100端口上监听msg_server的连接 //3. 在8080端口上监听客户端http连接 其中连接对象CLoginConn代表着login_server与msg_server之间的连接；而CHttpConn代表着与客户端的http连接。我们先来看CLoginConn对象，上一篇文章中也介绍了其业务代码主要在其HandlePdu()函数中，可以看到这路连接主要处理哪些数据包：
void CLoginConn::HandlePdu(CImPdu* pPdu) { switch (pPdu-&gt;GetCommandId()) { case CID_OTHER_HEARTBEAT: break; case CID_OTHER_MSG_SERV_INFO: _HandleMsgServInfo(pPdu); break; case CID_OTHER_USER_CNT_UPDATE: _HandleUserCntUpdate(pPdu); break; case CID_LOGIN_REQ_MSGSERVER: _HandleMsgServRequest(pPdu); break; default: log(&#34;wrong msg, cmd id=%d &#34;, pPdu-&gt;GetCommandId()); break; } } 命令号CID_OTHER_HEARTBEAT是与msg_server的心跳包。上一篇文章《服务器端msg_server源码分析》中介绍过，msg_server连上login_server后会立刻给login_server发一个数据包，该数据包里面含有该msg_server上的用户数量、最大可容纳的用户数量、自己的ip地址和端口号。
list&lt;user_conn_t&gt; user_conn_list; CImUserManager::GetInstance()-&gt;GetUserConnCnt(&amp;user_conn_list, cur_conn_cnt); char hostname[256] = {0}; gethostname(hostname, 256); IM::Server::IMMsgServInfo msg; msg.set_ip1(g_msg_server_ip_addr1); msg.set_ip2(g_msg_server_ip_addr2); msg.set_port(g_msg_server_port); msg.set_max_conn_cnt(g_max_conn_cnt); msg.set_cur_conn_cnt(cur_conn_cnt); msg.set_host_name(hostname); CImPdu pdu; pdu.SetPBMsg(&amp;msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_MSG_SERV_INFO); SendPdu(&amp;pdu); 命令号是CID_OTHER_MSG_SERV_INFO。我们来看下login_server如何处理这个命令的：
void CLoginConn::_HandleMsgServInfo(CImPdu* pPdu) { msg_serv_info_t* pMsgServInfo = new msg_serv_info_t; IM::Server::IMMsgServInfo msg; msg.ParseFromArray(pPdu-&gt;GetBodyData(), pPdu-&gt;GetBodyLength()); pMsgServInfo-&gt;ip_addr1 = msg.ip1(); pMsgServInfo-&gt;ip_addr2 = msg.ip2(); pMsgServInfo-&gt;port = msg.port(); pMsgServInfo-&gt;max_conn_cnt = msg.max_conn_cnt(); pMsgServInfo-&gt;cur_conn_cnt = msg.cur_conn_cnt(); pMsgServInfo-&gt;hostname = msg.host_name(); g_msg_serv_info." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/blog/1866caff3acc4baeb8666ea706d7ba7d/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="06 服务器端login_server源码分析"/>
<meta name="twitter:description" content="06 服务器端login_server源码分析 login_server从严格意义上来说，是一个登录分流器，所以名字起的有点名不符实。该服务根据已知的msg_server上的在线用户数量来返回告诉一个即将登录的用户登录哪个msg_server比较合适。关于其程序框架的非业务代码我们已经在前面的两篇文章《服务器端db_proxy_server源码分析》和《服务器端msg_server源码分析》中介绍过了。这篇文章主要介绍下其业务代码。
首先，程序初始化的时候，会初始化如下功能：
//1. 在8008端口监听客户端连接 //2. 在8100端口上监听msg_server的连接 //3. 在8080端口上监听客户端http连接 其中连接对象CLoginConn代表着login_server与msg_server之间的连接；而CHttpConn代表着与客户端的http连接。我们先来看CLoginConn对象，上一篇文章中也介绍了其业务代码主要在其HandlePdu()函数中，可以看到这路连接主要处理哪些数据包：
void CLoginConn::HandlePdu(CImPdu* pPdu) { switch (pPdu-&gt;GetCommandId()) { case CID_OTHER_HEARTBEAT: break; case CID_OTHER_MSG_SERV_INFO: _HandleMsgServInfo(pPdu); break; case CID_OTHER_USER_CNT_UPDATE: _HandleUserCntUpdate(pPdu); break; case CID_LOGIN_REQ_MSGSERVER: _HandleMsgServRequest(pPdu); break; default: log(&#34;wrong msg, cmd id=%d &#34;, pPdu-&gt;GetCommandId()); break; } } 命令号CID_OTHER_HEARTBEAT是与msg_server的心跳包。上一篇文章《服务器端msg_server源码分析》中介绍过，msg_server连上login_server后会立刻给login_server发一个数据包，该数据包里面含有该msg_server上的用户数量、最大可容纳的用户数量、自己的ip地址和端口号。
list&lt;user_conn_t&gt; user_conn_list; CImUserManager::GetInstance()-&gt;GetUserConnCnt(&amp;user_conn_list, cur_conn_cnt); char hostname[256] = {0}; gethostname(hostname, 256); IM::Server::IMMsgServInfo msg; msg.set_ip1(g_msg_server_ip_addr1); msg.set_ip2(g_msg_server_ip_addr2); msg.set_port(g_msg_server_port); msg.set_max_conn_cnt(g_max_conn_cnt); msg.set_cur_conn_cnt(cur_conn_cnt); msg.set_host_name(hostname); CImPdu pdu; pdu.SetPBMsg(&amp;msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_MSG_SERV_INFO); SendPdu(&amp;pdu); 命令号是CID_OTHER_MSG_SERV_INFO。我们来看下login_server如何处理这个命令的：
void CLoginConn::_HandleMsgServInfo(CImPdu* pPdu) { msg_serv_info_t* pMsgServInfo = new msg_serv_info_t; IM::Server::IMMsgServInfo msg; msg.ParseFromArray(pPdu-&gt;GetBodyData(), pPdu-&gt;GetBodyLength()); pMsgServInfo-&gt;ip_addr1 = msg.ip1(); pMsgServInfo-&gt;ip_addr2 = msg.ip2(); pMsgServInfo-&gt;port = msg.port(); pMsgServInfo-&gt;max_conn_cnt = msg.max_conn_cnt(); pMsgServInfo-&gt;cur_conn_cnt = msg.cur_conn_cnt(); pMsgServInfo-&gt;hostname = msg.host_name(); g_msg_serv_info."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "06 服务器端login_server源码分析",
      "item": "https://haokiu.com/blog/1866caff3acc4baeb8666ea706d7ba7d/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "06 服务器端login_server源码分析",
  "name": "06 服务器端login_server源码分析",
  "description": "06 服务器端login_server源码分析 login_server从严格意义上来说，是一个登录分流器，所以名字起的有点名不符实。该服务根据已知的msg_server上的在线用户数量来返回告诉一个即将登录的用户登录哪个msg_server比较合适。关于其程序框架的非业务代码我们已经在前面的两篇文章《服务器端db_proxy_server源码分析》和《服务器端msg_server源码分析》中介绍过了。这篇文章主要介绍下其业务代码。\n首先，程序初始化的时候，会初始化如下功能：\n//1. 在8008端口监听客户端连接 //2. 在8100端口上监听msg_server的连接 //3. 在8080端口上监听客户端http连接 其中连接对象CLoginConn代表着login_server与msg_server之间的连接；而CHttpConn代表着与客户端的http连接。我们先来看CLoginConn对象，上一篇文章中也介绍了其业务代码主要在其HandlePdu()函数中，可以看到这路连接主要处理哪些数据包：\nvoid CLoginConn::HandlePdu(CImPdu* pPdu) { switch (pPdu-\u0026gt;GetCommandId()) { case CID_OTHER_HEARTBEAT: break; case CID_OTHER_MSG_SERV_INFO: _HandleMsgServInfo(pPdu); break; case CID_OTHER_USER_CNT_UPDATE: _HandleUserCntUpdate(pPdu); break; case CID_LOGIN_REQ_MSGSERVER: _HandleMsgServRequest(pPdu); break; default: log(\u0026#34;wrong msg, cmd id=%d \u0026#34;, pPdu-\u0026gt;GetCommandId()); break; } } 命令号CID_OTHER_HEARTBEAT是与msg_server的心跳包。上一篇文章《服务器端msg_server源码分析》中介绍过，msg_server连上login_server后会立刻给login_server发一个数据包，该数据包里面含有该msg_server上的用户数量、最大可容纳的用户数量、自己的ip地址和端口号。\nlist\u0026lt;user_conn_t\u0026gt; user_conn_list; CImUserManager::GetInstance()-\u0026gt;GetUserConnCnt(\u0026amp;user_conn_list, cur_conn_cnt); char hostname[256] = {0}; gethostname(hostname, 256); IM::Server::IMMsgServInfo msg; msg.set_ip1(g_msg_server_ip_addr1); msg.set_ip2(g_msg_server_ip_addr2); msg.set_port(g_msg_server_port); msg.set_max_conn_cnt(g_max_conn_cnt); msg.set_cur_conn_cnt(cur_conn_cnt); msg.set_host_name(hostname); CImPdu pdu; pdu.SetPBMsg(\u0026amp;msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_MSG_SERV_INFO); SendPdu(\u0026amp;pdu); 命令号是CID_OTHER_MSG_SERV_INFO。我们来看下login_server如何处理这个命令的：\nvoid CLoginConn::_HandleMsgServInfo(CImPdu* pPdu) { msg_serv_info_t* pMsgServInfo = new msg_serv_info_t; IM::Server::IMMsgServInfo msg; msg.ParseFromArray(pPdu-\u0026gt;GetBodyData(), pPdu-\u0026gt;GetBodyLength()); pMsgServInfo-\u0026gt;ip_addr1 = msg.ip1(); pMsgServInfo-\u0026gt;ip_addr2 = msg.ip2(); pMsgServInfo-\u0026gt;port = msg.port(); pMsgServInfo-\u0026gt;max_conn_cnt = msg.max_conn_cnt(); pMsgServInfo-\u0026gt;cur_conn_cnt = msg.cur_conn_cnt(); pMsgServInfo-\u0026gt;hostname = msg.host_name(); g_msg_serv_info.",
  "keywords": [
    
  ],
  "articleBody": "06 服务器端login_server源码分析 login_server从严格意义上来说，是一个登录分流器，所以名字起的有点名不符实。该服务根据已知的msg_server上的在线用户数量来返回告诉一个即将登录的用户登录哪个msg_server比较合适。关于其程序框架的非业务代码我们已经在前面的两篇文章《服务器端db_proxy_server源码分析》和《服务器端msg_server源码分析》中介绍过了。这篇文章主要介绍下其业务代码。\n首先，程序初始化的时候，会初始化如下功能：\n//1. 在8008端口监听客户端连接 //2. 在8100端口上监听msg_server的连接 //3. 在8080端口上监听客户端http连接 其中连接对象CLoginConn代表着login_server与msg_server之间的连接；而CHttpConn代表着与客户端的http连接。我们先来看CLoginConn对象，上一篇文章中也介绍了其业务代码主要在其HandlePdu()函数中，可以看到这路连接主要处理哪些数据包：\nvoid CLoginConn::HandlePdu(CImPdu* pPdu) { switch (pPdu-\u003eGetCommandId()) { case CID_OTHER_HEARTBEAT: break; case CID_OTHER_MSG_SERV_INFO: _HandleMsgServInfo(pPdu); break; case CID_OTHER_USER_CNT_UPDATE: _HandleUserCntUpdate(pPdu); break; case CID_LOGIN_REQ_MSGSERVER: _HandleMsgServRequest(pPdu); break; default: log(\"wrong msg, cmd id=%d \", pPdu-\u003eGetCommandId()); break; } } 命令号CID_OTHER_HEARTBEAT是与msg_server的心跳包。上一篇文章《服务器端msg_server源码分析》中介绍过，msg_server连上login_server后会立刻给login_server发一个数据包，该数据包里面含有该msg_server上的用户数量、最大可容纳的用户数量、自己的ip地址和端口号。\nlist\u003cuser_conn_t\u003e user_conn_list; CImUserManager::GetInstance()-\u003eGetUserConnCnt(\u0026user_conn_list, cur_conn_cnt); char hostname[256] = {0}; gethostname(hostname, 256); IM::Server::IMMsgServInfo msg; msg.set_ip1(g_msg_server_ip_addr1); msg.set_ip2(g_msg_server_ip_addr2); msg.set_port(g_msg_server_port); msg.set_max_conn_cnt(g_max_conn_cnt); msg.set_cur_conn_cnt(cur_conn_cnt); msg.set_host_name(hostname); CImPdu pdu; pdu.SetPBMsg(\u0026msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_MSG_SERV_INFO); SendPdu(\u0026pdu); 命令号是CID_OTHER_MSG_SERV_INFO。我们来看下login_server如何处理这个命令的：\nvoid CLoginConn::_HandleMsgServInfo(CImPdu* pPdu) { msg_serv_info_t* pMsgServInfo = new msg_serv_info_t; IM::Server::IMMsgServInfo msg; msg.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength()); pMsgServInfo-\u003eip_addr1 = msg.ip1(); pMsgServInfo-\u003eip_addr2 = msg.ip2(); pMsgServInfo-\u003eport = msg.port(); pMsgServInfo-\u003emax_conn_cnt = msg.max_conn_cnt(); pMsgServInfo-\u003ecur_conn_cnt = msg.cur_conn_cnt(); pMsgServInfo-\u003ehostname = msg.host_name(); g_msg_serv_info.insert(make_pair(m_handle, pMsgServInfo)); g_total_online_user_cnt += pMsgServInfo-\u003ecur_conn_cnt; log(\"MsgServInfo, ip_addr1=%s, ip_addr2=%s, port=%d, max_conn_cnt=%d, cur_conn_cnt=%d, \"\\ \"hostname: %s. \", pMsgServInfo-\u003eip_addr1.c_str(), pMsgServInfo-\u003eip_addr2.c_str(), pMsgServInfo-\u003eport,pMsgServInfo-\u003emax_conn_cnt, pMsgServInfo-\u003ecur_conn_cnt, pMsgServInfo-\u003ehostname.c_str()); } 其实所做的工作无非就是记录下的该msg_server上的ip、端口号、在线用户数量和最大可容纳用户数量等信息而已。存在一个全局map里面：\nmap\u003cuint32_t, msg_serv_info_t*\u003e g_msg_serv_info; typedef struct { string\tip_addr1;\t// 电信IP string\tip_addr2;\t// 网通IP uint16_t\tport; uint32_t\tmax_conn_cnt; uint32_t\tcur_conn_cnt; string hostname;\t// 消息服务器的主机名 } msg_serv_info_t; 另外一个命令号CID_OTHER_USER_CNT_UPDATE，是当msg_server上的用户上线或下线时，msg_server给login_server发该类型的命令号，让login_server更新保存的msg_server的上的在线用户数量：\nvoid CLoginConn::_HandleUserCntUpdate(CImPdu* pPdu) { map\u003cuint32_t, msg_serv_info_t*\u003e::iterator it = g_msg_serv_info.find(m_handle); if (it != g_msg_serv_info.end()) { msg_serv_info_t* pMsgServInfo = it-\u003esecond; IM::Server::IMUserCntUpdate msg; msg.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength()); uint32_t action = msg.user_action(); if (action == USER_CNT_INC) { pMsgServInfo-\u003ecur_conn_cnt++; g_total_online_user_cnt++; } else { pMsgServInfo-\u003ecur_conn_cnt--; g_total_online_user_cnt--; } log(\"%s:%d, cur_cnt=%u, total_cnt=%u \", pMsgServInfo-\u003ehostname.c_str(), pMsgServInfo-\u003eport, pMsgServInfo-\u003ecur_conn_cnt, g_total_online_user_cnt); } } 命令号CID_LOGIN_REQ_MSGSERVER没用到。\n接着说login_server与客户端的http连接处理，这个连接收取数据和解包是直接在CHttpConn的OnRead函数里面处理的：\nvoid CHttpConn::OnRead() { for (;;) { uint32_t free_buf_len = m_in_buf.GetAllocSize() - m_in_buf.GetWriteOffset(); if (free_buf_len \u003c READ_BUF_SIZE + 1) m_in_buf.Extend(READ_BUF_SIZE + 1); int ret = netlib_recv(m_sock_handle, m_in_buf.GetBuffer() + m_in_buf.GetWriteOffset(), READ_BUF_SIZE); if (ret \u003c= 0) break; m_in_buf.IncWriteOffset(ret); m_last_recv_tick = get_tick_count(); } // 每次请求对应一个HTTP连接，所以读完数据后，不用在同一个连接里面准备读取下个请求 char* in_buf = (char*)m_in_buf.GetBuffer(); uint32_t buf_len = m_in_buf.GetWriteOffset(); in_buf[buf_len] = '\\0'; // 如果buf_len 过长可能是受到攻击，则断开连接 // 正常的url最大长度为2048，我们接受的所有数据长度不得大于1K if(buf_len \u003e 1024) { log(\"get too much data:%s \", in_buf); Close(); return; } //log(\"OnRead, buf_len=%u, conn_handle=%u\\n\", buf_len, m_conn_handle); // for debug m_cHttpParser.ParseHttpContent(in_buf, buf_len); if (m_cHttpParser.IsReadAll()) { string url = m_cHttpParser.GetUrl(); if (strncmp(url.c_str(), \"/msg_server\", 11) == 0) { string content = m_cHttpParser.GetBodyContent(); _HandleMsgServRequest(url, content); } else { log(\"url unknown, url=%s \", url.c_str()); Close(); } } } 如果用户发送的http请求的地址形式是http://192.168.226.128:8080/msg_server，即路径是/msg_server，则调用_HandleMsgServRequest()函数处理：\nvoid CHttpConn::_HandleMsgServRequest(string\u0026 url, string\u0026 post_data) { msg_serv_info_t* pMsgServInfo; uint32_t min_user_cnt = (uint32_t)-1; map\u003cuint32_t, msg_serv_info_t*\u003e::iterator it_min_conn = g_msg_serv_info.end(); map\u003cuint32_t, msg_serv_info_t*\u003e::iterator it; if(g_msg_serv_info.size() \u003c= 0) { Json::Value value; value[\"code\"] = 1; value[\"msg\"] = \"没有msg_server\"; string strContent = value.toStyledString(); char* szContent = new char[HTTP_RESPONSE_HTML_MAX]; snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, strContent.length(), strContent.c_str()); Send((void*)szContent, strlen(szContent)); delete [] szContent; return ; } for (it = g_msg_serv_info.begin() ; it != g_msg_serv_info.end(); it++) { pMsgServInfo = it-\u003esecond; if ( (pMsgServInfo-\u003ecur_conn_cnt \u003c pMsgServInfo-\u003emax_conn_cnt) \u0026\u0026 (pMsgServInfo-\u003ecur_conn_cnt \u003c min_user_cnt)) { it_min_conn = it; min_user_cnt = pMsgServInfo-\u003ecur_conn_cnt; } } if (it_min_conn == g_msg_serv_info.end()) { log(\"All TCP MsgServer are full \"); Json::Value value; value[\"code\"] = 2; value[\"msg\"] = \"负载过高\"; string strContent = value.toStyledString(); char* szContent = new char[HTTP_RESPONSE_HTML_MAX]; snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, strContent.length(), strContent.c_str()); Send((void*)szContent, strlen(szContent)); delete [] szContent; return; } else { Json::Value value; value[\"code\"] = 0; value[\"msg\"] = \"\"; if(pIpParser-\u003eisTelcome(GetPeerIP())) { value[\"priorIP\"] = string(it_min_conn-\u003esecond-\u003eip_addr1); value[\"backupIP\"] = string(it_min_conn-\u003esecond-\u003eip_addr2); value[\"msfsPrior\"] = strMsfsUrl; value[\"msfsBackup\"] = strMsfsUrl; } else { value[\"priorIP\"] = string(it_min_conn-\u003esecond-\u003eip_addr2); value[\"backupIP\"] = string(it_min_conn-\u003esecond-\u003eip_addr1); value[\"msfsPrior\"] = strMsfsUrl; value[\"msfsBackup\"] = strMsfsUrl; } value[\"discovery\"] = strDiscovery; value[\"port\"] = int2string(it_min_conn-\u003esecond-\u003eport); string strContent = value.toStyledString(); char* szContent = new char[HTTP_RESPONSE_HTML_MAX]; uint32_t nLen = strContent.length(); snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, nLen, strContent.c_str()); Send((void*)szContent, strlen(szContent)); delete [] szContent; return; } } 其实就是根据记录的msg_server的负载情况，返回一个可用的msg_server ip和端口给客户端，这是一个json格式：\n{ \"backupIP\" : \"localhost\", \"code\" : 0, \"discovery\" : \"http://192.168.226.128/api/discovery\", \"msfsBackup\" : \"http://127.0.0.1:8700/\", \"msfsPrior\" : \"http://127.0.0.1:8700/\", \"msg\" : \"\", \"port\" : \"8000\", \"priorIP\" : \"localhost\" } 里面含有msg_server和聊天图片存放的服务器地址（msfsPrior）字段。这样客户端可以拿着这个地址去登录msg_server和图片服务器了。\n发出去这个json之后会调用OnWriteComplete()函数，这个函数立刻关闭该http连接，也就是说这个与客户端的http连接是短连接：\nvoid CHttpConn::OnWriteComlete() { log(\"write complete \"); Close(); } login_server就这么多内容了。\n",
  "wordCount" : "549",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/blog/1866caff3acc4baeb8666ea706d7ba7d/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      06 服务器端login_server源码分析
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#06-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%aflogin_server%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" aria-label="06 服务器端login_server源码分析">06 服务器端login_server源码分析</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="06-服务器端login_server源码分析">06 服务器端login_server源码分析</h1>
<p>login_server从严格意义上来说，是一个登录分流器，所以名字起的有点名不符实。该服务根据已知的msg_server上的在线用户数量来返回告诉一个即将登录的用户登录哪个msg_server比较合适。关于其程序框架的非业务代码我们已经在前面的两篇文章《服务器端db_proxy_server源码分析》和《服务器端msg_server源码分析》中介绍过了。这篇文章主要介绍下其业务代码。</p>
<p>首先，程序初始化的时候，会初始化如下功能：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>//1. 在8008端口监听客户端连接
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//2. 在8100端口上监听msg_server的连接
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//3. 在8080端口上监听客户端http连接
</span></span></code></pre></div><p>其中连接对象CLoginConn代表着login_server与msg_server之间的连接；而CHttpConn代表着与客户端的http连接。我们先来看CLoginConn对象，上一篇文章中也介绍了其业务代码主要在其HandlePdu()函数中，可以看到这路连接主要处理哪些数据包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CLoginConn<span style="color:#f92672">::</span>HandlePdu(CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (pPdu<span style="color:#f92672">-&gt;</span>GetCommandId()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> CID_OTHER_HEARTBEAT:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> CID_OTHER_MSG_SERV_INFO:
</span></span><span style="display:flex;"><span>            _HandleMsgServInfo(pPdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> CID_OTHER_USER_CNT_UPDATE:
</span></span><span style="display:flex;"><span>            _HandleUserCntUpdate(pPdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> CID_LOGIN_REQ_MSGSERVER:
</span></span><span style="display:flex;"><span>            _HandleMsgServRequest(pPdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;wrong msg, cmd id=%d &#34;</span>, pPdu<span style="color:#f92672">-&gt;</span>GetCommandId());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>命令号CID_OTHER_HEARTBEAT是与msg_server的心跳包。上一篇文章《服务器端msg_server源码分析》中介绍过，msg_server连上login_server后会立刻给login_server发一个数据包，该数据包里面含有该msg_server上的用户数量、最大可容纳的用户数量、自己的ip地址和端口号。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>list<span style="color:#f92672">&lt;</span>user_conn_t<span style="color:#f92672">&gt;</span> user_conn_list;
</span></span><span style="display:flex;"><span>    CImUserManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>GetUserConnCnt(<span style="color:#f92672">&amp;</span>user_conn_list, cur_conn_cnt);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> hostname[<span style="color:#ae81ff">256</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>	gethostname(hostname, <span style="color:#ae81ff">256</span>);
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMMsgServInfo msg;
</span></span><span style="display:flex;"><span>    msg.set_ip1(g_msg_server_ip_addr1);
</span></span><span style="display:flex;"><span>    msg.set_ip2(g_msg_server_ip_addr2);
</span></span><span style="display:flex;"><span>    msg.set_port(g_msg_server_port);
</span></span><span style="display:flex;"><span>    msg.set_max_conn_cnt(g_max_conn_cnt);
</span></span><span style="display:flex;"><span>    msg.set_cur_conn_cnt(cur_conn_cnt);
</span></span><span style="display:flex;"><span>    msg.set_host_name(hostname);
</span></span><span style="display:flex;"><span>    CImPdu pdu;
</span></span><span style="display:flex;"><span>    pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>    pdu.SetServiceId(SID_OTHER);
</span></span><span style="display:flex;"><span>    pdu.SetCommandId(CID_OTHER_MSG_SERV_INFO);
</span></span><span style="display:flex;"><span>	SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span></code></pre></div><p>命令号是CID_OTHER_MSG_SERV_INFO。我们来看下login_server如何处理这个命令的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CLoginConn<span style="color:#f92672">::</span>_HandleMsgServInfo(CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	msg_serv_info_t<span style="color:#f92672">*</span> pMsgServInfo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> msg_serv_info_t;
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMMsgServInfo msg;
</span></span><span style="display:flex;"><span>    msg.ParseFromArray(pPdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pPdu<span style="color:#f92672">-&gt;</span>GetBodyLength());
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	pMsgServInfo<span style="color:#f92672">-&gt;</span>ip_addr1 <span style="color:#f92672">=</span> msg.ip1();
</span></span><span style="display:flex;"><span>	pMsgServInfo<span style="color:#f92672">-&gt;</span>ip_addr2 <span style="color:#f92672">=</span> msg.ip2();
</span></span><span style="display:flex;"><span>	pMsgServInfo<span style="color:#f92672">-&gt;</span>port <span style="color:#f92672">=</span> msg.port();
</span></span><span style="display:flex;"><span>	pMsgServInfo<span style="color:#f92672">-&gt;</span>max_conn_cnt <span style="color:#f92672">=</span> msg.max_conn_cnt();
</span></span><span style="display:flex;"><span>	pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt <span style="color:#f92672">=</span> msg.cur_conn_cnt();
</span></span><span style="display:flex;"><span>	pMsgServInfo<span style="color:#f92672">-&gt;</span>hostname <span style="color:#f92672">=</span> msg.host_name();
</span></span><span style="display:flex;"><span>	g_msg_serv_info.insert(make_pair(m_handle, pMsgServInfo));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	g_total_online_user_cnt <span style="color:#f92672">+=</span> pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;MsgServInfo, ip_addr1=%s, ip_addr2=%s, port=%d, max_conn_cnt=%d, cur_conn_cnt=%d, &#34;</span>\
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;hostname: %s. &#34;</span>,
</span></span><span style="display:flex;"><span>		pMsgServInfo<span style="color:#f92672">-&gt;</span>ip_addr1.c_str(), pMsgServInfo<span style="color:#f92672">-&gt;</span>ip_addr2.c_str(), pMsgServInfo<span style="color:#f92672">-&gt;</span>port,pMsgServInfo<span style="color:#f92672">-&gt;</span>max_conn_cnt,
</span></span><span style="display:flex;"><span>		pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt, pMsgServInfo<span style="color:#f92672">-&gt;</span>hostname.c_str());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其实所做的工作无非就是记录下的该msg_server上的ip、端口号、在线用户数量和最大可容纳用户数量等信息而已。存在一个全局map里面：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, msg_serv_info_t<span style="color:#f92672">*&gt;</span> g_msg_serv_info;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>  {
</span></span><span style="display:flex;"><span>    string		ip_addr1;	<span style="color:#75715e">// 电信IP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    string		ip_addr2;	<span style="color:#75715e">// 网通IP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span>	port;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span>	max_conn_cnt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span>	cur_conn_cnt;
</span></span><span style="display:flex;"><span>    string 		hostname;	<span style="color:#75715e">// 消息服务器的主机名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} msg_serv_info_t;
</span></span></code></pre></div><p>另外一个命令号CID_OTHER_USER_CNT_UPDATE，是当msg_server上的用户上线或下线时，msg_server给login_server发该类型的命令号，让login_server更新保存的msg_server的上的在线用户数量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CLoginConn<span style="color:#f92672">::</span>_HandleUserCntUpdate(CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, msg_serv_info_t<span style="color:#f92672">*&gt;::</span>iterator it <span style="color:#f92672">=</span> g_msg_serv_info.find(m_handle);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> g_msg_serv_info.end()) {
</span></span><span style="display:flex;"><span>		msg_serv_info_t<span style="color:#f92672">*</span> pMsgServInfo <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMUserCntUpdate msg;
</span></span><span style="display:flex;"><span>        msg.ParseFromArray(pPdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pPdu<span style="color:#f92672">-&gt;</span>GetBodyLength());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint32_t</span> action <span style="color:#f92672">=</span> msg.user_action();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (action <span style="color:#f92672">==</span> USER_CNT_INC) {
</span></span><span style="display:flex;"><span>			pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			g_total_online_user_cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>			g_total_online_user_cnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;%s:%d, cur_cnt=%u, total_cnt=%u &#34;</span>, pMsgServInfo<span style="color:#f92672">-&gt;</span>hostname.c_str(),
</span></span><span style="display:flex;"><span>            pMsgServInfo<span style="color:#f92672">-&gt;</span>port, pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt, g_total_online_user_cnt);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>命令号CID_LOGIN_REQ_MSGSERVER没用到。</p>
<p>接着说login_server与客户端的http连接处理，这个连接收取数据和解包是直接在CHttpConn的OnRead函数里面处理的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CHttpConn<span style="color:#f92672">::</span>OnRead()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (;;)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint32_t</span> free_buf_len <span style="color:#f92672">=</span> m_in_buf.GetAllocSize() <span style="color:#f92672">-</span> m_in_buf.GetWriteOffset();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (free_buf_len <span style="color:#f92672">&lt;</span> READ_BUF_SIZE <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			m_in_buf.Extend(READ_BUF_SIZE <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> netlib_recv(m_sock_handle, m_in_buf.GetBuffer() <span style="color:#f92672">+</span> m_in_buf.GetWriteOffset(), READ_BUF_SIZE);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_in_buf.IncWriteOffset(ret);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_last_recv_tick <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 每次请求对应一个HTTP连接，所以读完数据后，不用在同一个连接里面准备读取下个请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> in_buf <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)m_in_buf.GetBuffer();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> buf_len <span style="color:#f92672">=</span> m_in_buf.GetWriteOffset();
</span></span><span style="display:flex;"><span>	in_buf[buf_len] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果buf_len 过长可能是受到攻击，则断开连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 正常的url最大长度为2048，我们接受的所有数据长度不得大于1K
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(buf_len <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;get too much data:%s &#34;</span>, in_buf);
</span></span><span style="display:flex;"><span>        Close();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//log(&#34;OnRead, buf_len=%u, conn_handle=%u\n&#34;, buf_len, m_conn_handle); // for debug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	m_cHttpParser.ParseHttpContent(in_buf, buf_len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_cHttpParser.IsReadAll()) {
</span></span><span style="display:flex;"><span>		string url <span style="color:#f92672">=</span>  m_cHttpParser.GetUrl();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (strncmp(url.c_str(), <span style="color:#e6db74">&#34;/msg_server&#34;</span>, <span style="color:#ae81ff">11</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            string content <span style="color:#f92672">=</span> m_cHttpParser.GetBodyContent();
</span></span><span style="display:flex;"><span>            _HandleMsgServRequest(url, content);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;url unknown, url=%s &#34;</span>, url.c_str());
</span></span><span style="display:flex;"><span>			Close();
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果用户发送的http请求的地址形式是http://192.168.226.128:8080/msg_server，即路径是/msg_server，则调用_HandleMsgServRequest()函数处理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CHttpConn<span style="color:#f92672">::</span>_HandleMsgServRequest(string<span style="color:#f92672">&amp;</span> url, string<span style="color:#f92672">&amp;</span> post_data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    msg_serv_info_t<span style="color:#f92672">*</span> pMsgServInfo;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> min_user_cnt <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, msg_serv_info_t<span style="color:#f92672">*&gt;::</span>iterator it_min_conn <span style="color:#f92672">=</span> g_msg_serv_info.end();
</span></span><span style="display:flex;"><span>    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, msg_serv_info_t<span style="color:#f92672">*&gt;::</span>iterator it;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(g_msg_serv_info.size() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Json<span style="color:#f92672">::</span>Value value;
</span></span><span style="display:flex;"><span>        value[<span style="color:#e6db74">&#34;code&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        value[<span style="color:#e6db74">&#34;msg&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;没有msg_server&#34;</span>;
</span></span><span style="display:flex;"><span>        string strContent <span style="color:#f92672">=</span> value.toStyledString();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> szContent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[HTTP_RESPONSE_HTML_MAX];
</span></span><span style="display:flex;"><span>        snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, strContent.length(), strContent.c_str());
</span></span><span style="display:flex;"><span>        Send((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)szContent, strlen(szContent));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> [] szContent;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (it <span style="color:#f92672">=</span> g_msg_serv_info.begin() ; it <span style="color:#f92672">!=</span> g_msg_serv_info.end(); it<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        pMsgServInfo <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( (pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt <span style="color:#f92672">&lt;</span> pMsgServInfo<span style="color:#f92672">-&gt;</span>max_conn_cnt) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            (pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt <span style="color:#f92672">&lt;</span> min_user_cnt)) {
</span></span><span style="display:flex;"><span>            it_min_conn <span style="color:#f92672">=</span> it;
</span></span><span style="display:flex;"><span>            min_user_cnt <span style="color:#f92672">=</span> pMsgServInfo<span style="color:#f92672">-&gt;</span>cur_conn_cnt;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (it_min_conn <span style="color:#f92672">==</span> g_msg_serv_info.end()) {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;All TCP MsgServer are full &#34;</span>);
</span></span><span style="display:flex;"><span>        Json<span style="color:#f92672">::</span>Value value;
</span></span><span style="display:flex;"><span>        value[<span style="color:#e6db74">&#34;code&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        value[<span style="color:#e6db74">&#34;msg&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;负载过高&#34;</span>;
</span></span><span style="display:flex;"><span>        string strContent <span style="color:#f92672">=</span> value.toStyledString();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> szContent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[HTTP_RESPONSE_HTML_MAX];
</span></span><span style="display:flex;"><span>        snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, strContent.length(), strContent.c_str());
</span></span><span style="display:flex;"><span>        Send((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)szContent, strlen(szContent));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> [] szContent;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Json<span style="color:#f92672">::</span>Value value;
</span></span><span style="display:flex;"><span>        value[<span style="color:#e6db74">&#34;code&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        value[<span style="color:#e6db74">&#34;msg&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pIpParser<span style="color:#f92672">-&gt;</span>isTelcome(GetPeerIP()))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            value[<span style="color:#e6db74">&#34;priorIP&#34;</span>] <span style="color:#f92672">=</span> string(it_min_conn<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">-&gt;</span>ip_addr1);
</span></span><span style="display:flex;"><span>            value[<span style="color:#e6db74">&#34;backupIP&#34;</span>] <span style="color:#f92672">=</span> string(it_min_conn<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">-&gt;</span>ip_addr2);
</span></span><span style="display:flex;"><span>            value[<span style="color:#e6db74">&#34;msfsPrior&#34;</span>] <span style="color:#f92672">=</span> strMsfsUrl;
</span></span><span style="display:flex;"><span>            value[<span style="color:#e6db74">&#34;msfsBackup&#34;</span>] <span style="color:#f92672">=</span> strMsfsUrl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            value[<span style="color:#e6db74">&#34;priorIP&#34;</span>] <span style="color:#f92672">=</span> string(it_min_conn<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">-&gt;</span>ip_addr2);
</span></span><span style="display:flex;"><span>            value[<span style="color:#e6db74">&#34;backupIP&#34;</span>] <span style="color:#f92672">=</span> string(it_min_conn<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">-&gt;</span>ip_addr1);
</span></span><span style="display:flex;"><span>            value[<span style="color:#e6db74">&#34;msfsPrior&#34;</span>] <span style="color:#f92672">=</span> strMsfsUrl;
</span></span><span style="display:flex;"><span>            value[<span style="color:#e6db74">&#34;msfsBackup&#34;</span>] <span style="color:#f92672">=</span> strMsfsUrl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        value[<span style="color:#e6db74">&#34;discovery&#34;</span>] <span style="color:#f92672">=</span> strDiscovery;
</span></span><span style="display:flex;"><span>        value[<span style="color:#e6db74">&#34;port&#34;</span>] <span style="color:#f92672">=</span> int2string(it_min_conn<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">-&gt;</span>port);
</span></span><span style="display:flex;"><span>        string strContent <span style="color:#f92672">=</span> value.toStyledString();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> szContent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[HTTP_RESPONSE_HTML_MAX];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint32_t</span> nLen <span style="color:#f92672">=</span> strContent.length();
</span></span><span style="display:flex;"><span>        snprintf(szContent, HTTP_RESPONSE_HTML_MAX, HTTP_RESPONSE_HTML, nLen, strContent.c_str());
</span></span><span style="display:flex;"><span>        Send((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)szContent, strlen(szContent));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> [] szContent;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其实就是根据记录的msg_server的负载情况，返回一个可用的msg_server ip和端口给客户端，这是一个json格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;backupIP&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;localhost&#34;</span>,
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;code&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;discovery&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;http://192.168.226.128&lt;/span&gt;/api/discovery&#34;</span>,
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;msfsBackup&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;http://127.0.0.1:8700/&#34;</span>,
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;msfsPrior&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;http://127.0.0.1:8700/&#34;</span>,
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;msg&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;port&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;8000&#34;</span>,
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;priorIP&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;localhost&#34;</span>
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>里面含有msg_server和聊天图片存放的服务器地址（msfsPrior）字段。这样客户端可以拿着这个地址去登录msg_server和图片服务器了。</p>
<p>发出去这个json之后会调用OnWriteComplete()函数，这个函数立刻关闭该http连接，也就是说这个与客户端的http连接是短连接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CHttpConn<span style="color:#f92672">::</span>OnWriteComlete()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    log(<span style="color:#e6db74">&#34;write complete &#34;</span>);
</span></span><span style="display:flex;"><span>    Close();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>login_server就这么多内容了。</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/blog/27deab1b64f24c839058b60bd3826f79/">
    <span class="title">« Prev</span>
    <br>
    <span>05 服务器端msg_server源码分析</span>
  </a>
  <a class="next" href="https://haokiu.com/blog/0055f7fa607b4b2180cd0eb3924eff5c/">
    <span class="title">Next »</span>
    <br>
    <span>07 服务器端msfs源码分析</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
