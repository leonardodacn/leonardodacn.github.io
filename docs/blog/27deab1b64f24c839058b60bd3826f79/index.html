<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>05 服务器端msg_server源码分析 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="05 服务器端msg_server源码分析 在分析msg_server的源码之前，我们先简单地回顾一下msg_server在整个服务器系统中的位置和作用：
各个服务程序的作用描述如下：
LoginServer (C&#43;&#43;): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C&#43;&#43;): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C&#43;&#43;): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C&#43;&#43;): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C&#43;&#43;): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C&#43;&#43;): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C&#43;&#43;) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C&#43;&#43;): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 从上面的介绍中，我们可以看出TeamTalk是支持分布式部署的一套聊天服务器程序，通过分布式部署可以实现分流和支持高数量的用户同时在线。msg_server是整个服务体系的核心系统，可以部署多个，不同的用户可以登录不同的msg_server。这套体系有如下几大亮点：
login_server可以根据当前各个msg_server上在线用户数量，来决定一个新用户登录到哪个msg_server，从而实现了负载平衡；
route_server可以将登录在不同的msg_server上的用户的聊天消息发给目标用户；
通过单独的一个数据库操作服务器db_proxy_server，避免了msg_server直接操作数据库，将数据库操作的入口封装起来。
在前一篇文章《服务器端db_proxy_server源码分析》中，我介绍了每个服务如何接收连接、读取数据并解包、以及组装数据包发包的操作，这篇文章我将介绍作为客户端，一个服务如何连接另外一个服务。这里msg_server在启动时会同时连接db_proxy_server，login_server，file_server，route_server，push_server。在msg_server服务main函数里面有如下初始化调用：
//连接file_server init_file_serv_conn(file_server_list, file_server_count); //连接db_proxy_server init_db_serv_conn(db_server_list2, db_server_count2, concurrent_db_conn_cnt); //连接login_server init_login_serv_conn(login_server_list, login_server_count, ip_addr1, ip_addr2, listen_port, max_conn_cnt); //连接push_server init_route_serv_conn(route_server_list, route_server_count); //连接push_server init_push_serv_conn(push_server_list, push_server_count); 其中每个连接服务的流程都是一样的。我们这里以第一个连接file_server为例：
void init_file_serv_conn(serv_info_t* server_list, uint32_t server_count) { g_file_server_list = server_list; g_file_server_count = server_count; serv_init&lt;CFileServConn&gt;(g_file_server_list, g_file_server_count); netlib_register_timer(file_server_conn_timer_callback, NULL, 1000); s_file_handler = CFileHandler::getInstance(); } template &lt;class T&gt; void serv_init(serv_info_t* server_list, uint32_t server_count) { for (uint32_t i = 0; i &lt; server_count; i&#43;&#43;) { T* pConn = new T(); pConn-&gt;Connect(server_list[i].server_ip.c_str(), server_list[i].server_port, i); server_list[i].">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/blog/27deab1b64f24c839058b60bd3826f79/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="05 服务器端msg_server源码分析" />
<meta property="og:description" content="05 服务器端msg_server源码分析 在分析msg_server的源码之前，我们先简单地回顾一下msg_server在整个服务器系统中的位置和作用：
各个服务程序的作用描述如下：
LoginServer (C&#43;&#43;): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C&#43;&#43;): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C&#43;&#43;): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C&#43;&#43;): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C&#43;&#43;): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C&#43;&#43;): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C&#43;&#43;) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C&#43;&#43;): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 从上面的介绍中，我们可以看出TeamTalk是支持分布式部署的一套聊天服务器程序，通过分布式部署可以实现分流和支持高数量的用户同时在线。msg_server是整个服务体系的核心系统，可以部署多个，不同的用户可以登录不同的msg_server。这套体系有如下几大亮点：
login_server可以根据当前各个msg_server上在线用户数量，来决定一个新用户登录到哪个msg_server，从而实现了负载平衡；
route_server可以将登录在不同的msg_server上的用户的聊天消息发给目标用户；
通过单独的一个数据库操作服务器db_proxy_server，避免了msg_server直接操作数据库，将数据库操作的入口封装起来。
在前一篇文章《服务器端db_proxy_server源码分析》中，我介绍了每个服务如何接收连接、读取数据并解包、以及组装数据包发包的操作，这篇文章我将介绍作为客户端，一个服务如何连接另外一个服务。这里msg_server在启动时会同时连接db_proxy_server，login_server，file_server，route_server，push_server。在msg_server服务main函数里面有如下初始化调用：
//连接file_server init_file_serv_conn(file_server_list, file_server_count); //连接db_proxy_server init_db_serv_conn(db_server_list2, db_server_count2, concurrent_db_conn_cnt); //连接login_server init_login_serv_conn(login_server_list, login_server_count, ip_addr1, ip_addr2, listen_port, max_conn_cnt); //连接push_server init_route_serv_conn(route_server_list, route_server_count); //连接push_server init_push_serv_conn(push_server_list, push_server_count); 其中每个连接服务的流程都是一样的。我们这里以第一个连接file_server为例：
void init_file_serv_conn(serv_info_t* server_list, uint32_t server_count) { g_file_server_list = server_list; g_file_server_count = server_count; serv_init&lt;CFileServConn&gt;(g_file_server_list, g_file_server_count); netlib_register_timer(file_server_conn_timer_callback, NULL, 1000); s_file_handler = CFileHandler::getInstance(); } template &lt;class T&gt; void serv_init(serv_info_t* server_list, uint32_t server_count) { for (uint32_t i = 0; i &lt; server_count; i&#43;&#43;) { T* pConn = new T(); pConn-&gt;Connect(server_list[i].server_ip.c_str(), server_list[i].server_port, i); server_list[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/blog/27deab1b64f24c839058b60bd3826f79/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="05 服务器端msg_server源码分析"/>
<meta name="twitter:description" content="05 服务器端msg_server源码分析 在分析msg_server的源码之前，我们先简单地回顾一下msg_server在整个服务器系统中的位置和作用：
各个服务程序的作用描述如下：
LoginServer (C&#43;&#43;): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C&#43;&#43;): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C&#43;&#43;): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C&#43;&#43;): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C&#43;&#43;): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C&#43;&#43;): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C&#43;&#43;) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C&#43;&#43;): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 从上面的介绍中，我们可以看出TeamTalk是支持分布式部署的一套聊天服务器程序，通过分布式部署可以实现分流和支持高数量的用户同时在线。msg_server是整个服务体系的核心系统，可以部署多个，不同的用户可以登录不同的msg_server。这套体系有如下几大亮点：
login_server可以根据当前各个msg_server上在线用户数量，来决定一个新用户登录到哪个msg_server，从而实现了负载平衡；
route_server可以将登录在不同的msg_server上的用户的聊天消息发给目标用户；
通过单独的一个数据库操作服务器db_proxy_server，避免了msg_server直接操作数据库，将数据库操作的入口封装起来。
在前一篇文章《服务器端db_proxy_server源码分析》中，我介绍了每个服务如何接收连接、读取数据并解包、以及组装数据包发包的操作，这篇文章我将介绍作为客户端，一个服务如何连接另外一个服务。这里msg_server在启动时会同时连接db_proxy_server，login_server，file_server，route_server，push_server。在msg_server服务main函数里面有如下初始化调用：
//连接file_server init_file_serv_conn(file_server_list, file_server_count); //连接db_proxy_server init_db_serv_conn(db_server_list2, db_server_count2, concurrent_db_conn_cnt); //连接login_server init_login_serv_conn(login_server_list, login_server_count, ip_addr1, ip_addr2, listen_port, max_conn_cnt); //连接push_server init_route_serv_conn(route_server_list, route_server_count); //连接push_server init_push_serv_conn(push_server_list, push_server_count); 其中每个连接服务的流程都是一样的。我们这里以第一个连接file_server为例：
void init_file_serv_conn(serv_info_t* server_list, uint32_t server_count) { g_file_server_list = server_list; g_file_server_count = server_count; serv_init&lt;CFileServConn&gt;(g_file_server_list, g_file_server_count); netlib_register_timer(file_server_conn_timer_callback, NULL, 1000); s_file_handler = CFileHandler::getInstance(); } template &lt;class T&gt; void serv_init(serv_info_t* server_list, uint32_t server_count) { for (uint32_t i = 0; i &lt; server_count; i&#43;&#43;) { T* pConn = new T(); pConn-&gt;Connect(server_list[i].server_ip.c_str(), server_list[i].server_port, i); server_list[i]."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "05 服务器端msg_server源码分析",
      "item": "https://haokiu.com/blog/27deab1b64f24c839058b60bd3826f79/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "05 服务器端msg_server源码分析",
  "name": "05 服务器端msg_server源码分析",
  "description": "05 服务器端msg_server源码分析 在分析msg_server的源码之前，我们先简单地回顾一下msg_server在整个服务器系统中的位置和作用：\n各个服务程序的作用描述如下：\nLoginServer (C++): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C++): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C++): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C++): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C++): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C++): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C++) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C++): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 从上面的介绍中，我们可以看出TeamTalk是支持分布式部署的一套聊天服务器程序，通过分布式部署可以实现分流和支持高数量的用户同时在线。msg_server是整个服务体系的核心系统，可以部署多个，不同的用户可以登录不同的msg_server。这套体系有如下几大亮点：\nlogin_server可以根据当前各个msg_server上在线用户数量，来决定一个新用户登录到哪个msg_server，从而实现了负载平衡；\nroute_server可以将登录在不同的msg_server上的用户的聊天消息发给目标用户；\n通过单独的一个数据库操作服务器db_proxy_server，避免了msg_server直接操作数据库，将数据库操作的入口封装起来。\n在前一篇文章《服务器端db_proxy_server源码分析》中，我介绍了每个服务如何接收连接、读取数据并解包、以及组装数据包发包的操作，这篇文章我将介绍作为客户端，一个服务如何连接另外一个服务。这里msg_server在启动时会同时连接db_proxy_server，login_server，file_server，route_server，push_server。在msg_server服务main函数里面有如下初始化调用：\n//连接file_server init_file_serv_conn(file_server_list, file_server_count); //连接db_proxy_server init_db_serv_conn(db_server_list2, db_server_count2, concurrent_db_conn_cnt); //连接login_server init_login_serv_conn(login_server_list, login_server_count, ip_addr1, ip_addr2, listen_port, max_conn_cnt); //连接push_server init_route_serv_conn(route_server_list, route_server_count); //连接push_server init_push_serv_conn(push_server_list, push_server_count); 其中每个连接服务的流程都是一样的。我们这里以第一个连接file_server为例：\nvoid init_file_serv_conn(serv_info_t* server_list, uint32_t server_count) { g_file_server_list = server_list; g_file_server_count = server_count; serv_init\u0026lt;CFileServConn\u0026gt;(g_file_server_list, g_file_server_count); netlib_register_timer(file_server_conn_timer_callback, NULL, 1000); s_file_handler = CFileHandler::getInstance(); } template \u0026lt;class T\u0026gt; void serv_init(serv_info_t* server_list, uint32_t server_count) { for (uint32_t i = 0; i \u0026lt; server_count; i++) { T* pConn = new T(); pConn-\u0026gt;Connect(server_list[i].server_ip.c_str(), server_list[i].server_port, i); server_list[i].",
  "keywords": [
    
  ],
  "articleBody": "05 服务器端msg_server源码分析 在分析msg_server的源码之前，我们先简单地回顾一下msg_server在整个服务器系统中的位置和作用：\n各个服务程序的作用描述如下：\nLoginServer (C++): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用 MsgServer (C++): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等 RouteServer (C++): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能 FileServer (C++): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输 MsfsServer (C++): 图片存储服务器，提供头像，图片传输中的图片存储服务 DBProxy (C++): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互 HttpMsgServer(C++) :对外接口服务器，提供对外接口功能。（目前只是框架） PushServer(C++): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns） 从上面的介绍中，我们可以看出TeamTalk是支持分布式部署的一套聊天服务器程序，通过分布式部署可以实现分流和支持高数量的用户同时在线。msg_server是整个服务体系的核心系统，可以部署多个，不同的用户可以登录不同的msg_server。这套体系有如下几大亮点：\nlogin_server可以根据当前各个msg_server上在线用户数量，来决定一个新用户登录到哪个msg_server，从而实现了负载平衡；\nroute_server可以将登录在不同的msg_server上的用户的聊天消息发给目标用户；\n通过单独的一个数据库操作服务器db_proxy_server，避免了msg_server直接操作数据库，将数据库操作的入口封装起来。\n在前一篇文章《服务器端db_proxy_server源码分析》中，我介绍了每个服务如何接收连接、读取数据并解包、以及组装数据包发包的操作，这篇文章我将介绍作为客户端，一个服务如何连接另外一个服务。这里msg_server在启动时会同时连接db_proxy_server，login_server，file_server，route_server，push_server。在msg_server服务main函数里面有如下初始化调用：\n//连接file_server init_file_serv_conn(file_server_list, file_server_count); //连接db_proxy_server init_db_serv_conn(db_server_list2, db_server_count2, concurrent_db_conn_cnt); //连接login_server init_login_serv_conn(login_server_list, login_server_count, ip_addr1, ip_addr2, listen_port, max_conn_cnt); //连接push_server init_route_serv_conn(route_server_list, route_server_count); //连接push_server init_push_serv_conn(push_server_list, push_server_count); 其中每个连接服务的流程都是一样的。我们这里以第一个连接file_server为例：\nvoid init_file_serv_conn(serv_info_t* server_list, uint32_t server_count) { g_file_server_list = server_list; g_file_server_count = server_count; serv_init\u003cCFileServConn\u003e(g_file_server_list, g_file_server_count); netlib_register_timer(file_server_conn_timer_callback, NULL, 1000); s_file_handler = CFileHandler::getInstance(); } template \u003cclass T\u003e void serv_init(serv_info_t* server_list, uint32_t server_count) { for (uint32_t i = 0; i \u003c server_count; i++) { T* pConn = new T(); pConn-\u003eConnect(server_list[i].server_ip.c_str(), server_list[i].server_port, i); server_list[i].serv_conn = pConn; server_list[i].idle_cnt = 0; server_list[i].reconnect_cnt = MIN_RECONNECT_CNT / 2; } } 模板函数serv_init展开参数后实际上是调用CFileServConn-\u003eConnect()，我们看这个函数的调用：\nvoid CFileServConn::Connect(const char* server_ip, uint16_t server_port, uint32_t idx) { log(\"Connecting to FileServer %s:%d \", server_ip, server_port); m_serv_idx = idx; m_handle = netlib_connect(server_ip, server_port, imconn_callback, (void*)\u0026g_file_server_conn_map); if (m_handle != NETLIB_INVALID_HANDLE) { g_file_server_conn_map.insert(make_pair(m_handle, this)); } } 在这个函数里面创建连接socket，将该socket加入全局map g_file_server_conn_map中保存，map的key是socket句柄值，值是当前连接对象CFileServConn的指针。注意这里设置了回调函数imconn_callback。我们来看netlib_connect()实际连接的代码：\nnet_handle_t netlib_connect( const char* server_ip, uint16_t\tport, callback_t\tcallback, void*\tcallback_data) { CBaseSocket* pSocket = new CBaseSocket(); if (!pSocket) return NETLIB_INVALID_HANDLE; net_handle_t handle = pSocket-\u003eConnect(server_ip, port, callback, callback_data); if (handle == NETLIB_INVALID_HANDLE) delete pSocket; return handle; } net_handle_t CBaseSocket::Connect(const char* server_ip, uint16_t port, callback_t callback, void* callback_data) { log(\"CBaseSocket::Connect, server_ip=%s, port=%d\", server_ip, port); m_remote_ip = server_ip; m_remote_port = port; m_callback = callback; m_callback_data = callback_data; m_socket = socket(AF_INET, SOCK_STREAM, 0); if (m_socket == INVALID_SOCKET) { log(\"socket failed, err_code=%d\", _GetErrorCode()); return NETLIB_INVALID_HANDLE; } _SetNonblock(m_socket); _SetNoDelay(m_socket); sockaddr_in serv_addr; _SetAddr(server_ip, port, \u0026serv_addr); int ret = connect(m_socket, (sockaddr*)\u0026serv_addr, sizeof(serv_addr)); if ( (ret == SOCKET_ERROR) \u0026\u0026 (!_IsBlock(_GetErrorCode())) ) {\tlog(\"connect failed, err_code=%d\", _GetErrorCode()); closesocket(m_socket); return NETLIB_INVALID_HANDLE; } m_state = SOCKET_STATE_CONNECTING; AddBaseSocket(this); CEventDispatch::Instance()-\u003eAddEvent(m_socket, SOCKET_ALL); return (net_handle_t)m_socket; } 注意这里有以下几点：\n将socket设置成非阻塞的。这样如果底层连接函数connect()不能立马完成，connect会立刻返回。\n将socket的状态设置成SOCKET_STATE_CONNECTING。\nAddBaseSocket(this)将该socket加入一个全局map中。\n关注该socket的所有事件（SOCKET_ALL）。\nenum { SOCKET_READ\t= 0x1, SOCKET_WRITE\t= 0x2, SOCKET_EXCEP\t= 0x4, SOCKET_ALL\t= 0x7 }; 因为socket是非阻塞，所以connect可能没连接成功，也会立即返回。那连接成功以后，我们如何得知呢？还记得上一篇文章中介绍的主线程的消息泵吗？TeamTalk每个服务的主线程都有一个这样的消息泵：\nwhile(退出条件) { //1. 遍历定时器队列，检测是否有定时器事件到期，有则执行定时器的回调函数 //2. 遍历其他任务队列，检测是否有其他任务需要执行，有，执行之 //3. 检测socket集合，分离可读、可写和异常事件 //4. 处理socket可读事件 //5. 处理socket可写事件 //6. 处理socket异常事件 } 当socket连接成功以后，该socket立马会变的可写。此时会触发第5步中的可写事件：\nvoid CBaseSocket::OnWrite() { #if ((defined _WIN32) || (defined __APPLE__)) CEventDispatch::Instance()-\u003eRemoveEvent(m_socket, SOCKET_WRITE); #endif if (m_state == SOCKET_STATE_CONNECTING) { int error = 0; socklen_t len = sizeof(error); #ifdef _WIN32 getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (char*)\u0026error, \u0026len); #else getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (void*)\u0026error, \u0026len); #endif if (error) { m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } else { m_state = SOCKET_STATE_CONNECTED; m_callback(m_callback_data, NETLIB_MSG_CONFIRM, (net_handle_t)m_socket, NULL); } } else { m_callback(m_callback_data, NETLIB_MSG_WRITE, (net_handle_t)m_socket, NULL); } } 由于该socket的状态是SOCKET_STATE_CONNECTING，会走第一个if分支。在不出错的情况下，以参数NETLIB_MSG_CONFIRM调用之前设置的回调函数imconn_callback。\nvoid imconn_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { NOTUSED_ARG(handle); NOTUSED_ARG(pParam); if (!callback_data) return; ConnMap_t* conn_map = (ConnMap_t*)callback_data; CImConn* pConn = FindImConn(conn_map, handle); if (!pConn) return; //log(\"msg=%d, handle=%d \", msg, handle); switch (msg) { case NETLIB_MSG_CONFIRM: pConn-\u003eOnConfirm(); break; case NETLIB_MSG_READ: pConn-\u003eOnRead(); break; case NETLIB_MSG_WRITE: pConn-\u003eOnWrite(); break; case NETLIB_MSG_CLOSE: pConn-\u003eOnClose(); break; default: log(\"!!!imconn_callback error msg: %d \", msg); break; } pConn-\u003eReleaseRef(); } 这次走pConn-\u003eOnConfirm();分支，由于pConn实际是CImConn的子类对象，根据C++多态性，会调用CFileServConn的OnConfirm()函数：\nvoid CFileServConn::OnConfirm() { log(\"connect to file server success \"); m_bOpen = true; m_connect_time = get_tick_count(); g_file_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2; //连上file_server以后，给file_server发送获取ip地址的数据包 IM::Server::IMFileServerIPReq msg; CImPdu pdu; pdu.SetPBMsg(\u0026msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ); SendPdu(\u0026pdu); } 连接上file_server后，msg_server会立即给file_server发一个数据包，以获得file_server的ip地址等信息。\n这就是msg_server作为客户端连接其他服务的流程。与这些服务之间的连接都对应一个连接对象：\nfile_server CFileServConn db_proxy_server CDBServConn login_server CLoginServConn route_server CRouteServConn push_server CPushServConn 而且，和连接file_server一样，msg_server在连接这些服务成功以后，可能会需要将自己的一些状态信息告诉对方：\n连接file_server成功后，给对方发包获取对方的ip地址等信息 连接login_server成功以后,告诉login_server自己的ip地址、端口号和当前登录的用户数量和可容纳的最大用户数量，这样login_server将来对于一个需要登录的用户，会根据不同的msg_server的负载状态来决定用户到底登录哪个msg_server。 void CLoginServConn::OnConfirm() { log(\"connect to login server success \"); m_bOpen = true; g_login_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2; uint32_t cur_conn_cnt = 0; uint32_t shop_user_cnt = 0; //连接login_server成功以后,告诉login_server自己的ip地址、端口号 //和当前登录的用户数量和可容纳的最大用户数量 list\u003cuser_conn_t\u003e user_conn_list; CImUserManager::GetInstance()-\u003eGetUserConnCnt(\u0026user_conn_list, cur_conn_cnt); char hostname[256] = {0}; gethostname(hostname, 256); IM::Server::IMMsgServInfo msg; msg.set_ip1(g_msg_server_ip_addr1); msg.set_ip2(g_msg_server_ip_addr2); msg.set_port(g_msg_server_port); msg.set_max_conn_cnt(g_max_conn_cnt); msg.set_cur_conn_cnt(cur_conn_cnt); msg.set_host_name(hostname); CImPdu pdu; pdu.SetPBMsg(\u0026msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_MSG_SERV_INFO); SendPdu(\u0026pdu); } 连接route_server成功以后，给route_server发包告诉当前登录在本msg_server上有哪些用户（用户id、用户状态、用户客户端类型）。这样将来A用户给B发聊天消息，msg_server将该聊天消息转给route_server，route_server就知道用户B在哪个msg_server上了，以便将该聊天消息发给B所在的msg_server。 void CRouteServConn::OnConfirm() { log(\"connect to route server success \"); m_bOpen = true; m_connect_time = get_tick_count(); g_route_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2; if (g_master_rs_conn == NULL) { update_master_route_serv_conn(); } //连接route_server成功以后，给route_server发包告诉当前登录在本msg_server上有哪些 //用户（用户id、用户状态、用户客户端类型） list\u003cuser_stat_t\u003e online_user_list; CImUserManager::GetInstance()-\u003eGetOnlineUserInfo(\u0026online_user_list); IM::Server::IMOnlineUserInfo msg; for (list\u003cuser_stat_t\u003e::iterator it = online_user_list.begin(); it != online_user_list.end(); it++) { user_stat_t user_stat = *it; IM::BaseDefine::ServerUserStat* server_user_stat = msg.add_user_stat_list(); server_user_stat-\u003eset_user_id(user_stat.user_id); server_user_stat-\u003eset_status((::IM::BaseDefine::UserStatType)user_stat.status); server_user_stat-\u003eset_client_type((::IM::BaseDefine::ClientType)user_stat.client_type); } CImPdu pdu; pdu.SetPBMsg(\u0026msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_ONLINE_USER_INFO); SendPdu(\u0026pdu); } 再来提一下，心跳包机制，和上一篇文章中介绍个与db_proxy_server一样，都是在定时器里面做的，这里不再赘述了，简单地贴出与file_server的心跳包代码吧：\nvoid init_file_serv_conn(serv_info_t* server_list, uint32_t server_count) { g_file_server_list = server_list; g_file_server_count = server_count; serv_init\u003cCFileServConn\u003e(g_file_server_list, g_file_server_count); netlib_register_timer(file_server_conn_timer_callback, NULL, 1000); s_file_handler = CFileHandler::getInstance(); } void file_server_conn_timer_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { ConnMap_t::iterator it_old; CFileServConn* pConn = NULL; uint64_t cur_time = get_tick_count(); for (ConnMap_t::iterator it = g_file_server_conn_map.begin(); it != g_file_server_conn_map.end(); ) { it_old = it; it++; pConn = (CFileServConn*)it_old-\u003esecond; pConn-\u003eOnTimer(cur_time); } // reconnect FileServer serv_check_reconnect\u003cCFileServConn\u003e(g_file_server_list, g_file_server_count); } 在注册的定时器回调函数里面调用CFileServConn::OnTimer函数：\nvoid CFileServConn::OnTimer(uint64_t curr_tick) { if (curr_tick \u003e m_last_send_tick + SERVER_HEARTBEAT_INTERVAL) { IM::Other::IMHeartBeat msg; CImPdu pdu; pdu.SetPBMsg(\u0026msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_HEARTBEAT); SendPdu(\u0026pdu); } if (curr_tick \u003e m_last_recv_tick + SERVER_TIMEOUT) { log(\"conn to file server timeout \"); Close(); } } 接下来的就是每个连接上的业务处理代码了，主消息泵收到数据后触发OnRead函数，然后收取数据解包，然后根据包的命令号处理包，所以每个连接对象根据自己的业务都有一个HandlePdu()函数，例如CFileServConn的：\nvoid CFileServConn::HandlePdu(CImPdu* pPdu) { switch (pPdu-\u003eGetCommandId()) { case CID_OTHER_HEARTBEAT: break; case CID_OTHER_FILE_TRANSFER_RSP: _HandleFileMsgTransRsp(pPdu); break; case CID_OTHER_FILE_SERVER_IP_RSP: _HandleFileServerIPRsp(pPdu); break; default: log(\"unknown cmd id=%d \", pPdu-\u003eGetCommandId()); break; } } 当然有些数据包，msg_server直接自己装包应答就可以了。有些必须发到其他服务进行进一步处理，比如登录请求，发给db_proxy_server拿到mysql中校验用户名和密码，db_proxy_server校验完成后，再应答msg_server，msg_server再应答客户端。\n这大概就是msg_server服务的结构和源码了吧。具体业务代码你可以查看每个连接对象的HandlePdu()函数来看具体的流程细节。\n需要指出的是：连接服务器、接受连接、收取数据解包、发送数据这四个模块是一个完整的网路库必须具有的东西。这篇文章和上一篇文章完整地介绍了这四个模块，而TeamTalk的实现手法也是目前主流网络库的通用做法。如果从事服务器开发，必须熟练掌握这里面的具体每个细节。而teamtalk服务器这种分布式架构设计的思想也是非常值得学习和借鉴的。\n",
  "wordCount" : "734",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/blog/27deab1b64f24c839058b60bd3826f79/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      05 服务器端msg_server源码分析
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#05-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%afmsg_server%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" aria-label="05 服务器端msg_server源码分析">05 服务器端msg_server源码分析</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="05-服务器端msg_server源码分析">05 服务器端msg_server源码分析</h1>
<p>在分析msg_server的源码之前，我们先简单地回顾一下msg_server在整个服务器系统中的位置和作用：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/b5176e5e61fbb5a73c357b73fa8cdece.jpg" alt=""  />
</p>
<p>各个服务程序的作用描述如下：</p>
<ul>
<li>LoginServer (C++): 负载均衡服务器，分配一个负载小的MsgServer给客户端使用</li>
<li>MsgServer (C++): 消息服务器，提供客户端大部分信令处理功能，包括私人聊天、群组聊天等</li>
<li>RouteServer (C++): 路由服务器，为登录在不同MsgServer的用户提供消息转发功能</li>
<li>FileServer (C++): 文件服务器，提供客户端之间得文件传输服务，支持在线以及离线文件传输</li>
<li>MsfsServer (C++): 图片存储服务器，提供头像，图片传输中的图片存储服务</li>
<li>DBProxy (C++): 数据库代理服务器，提供mysql以及redis的访问服务，屏蔽其他服务器与mysql与redis的直接交互</li>
<li>HttpMsgServer(C++) :对外接口服务器，提供对外接口功能。（目前只是框架）</li>
<li>PushServer(C++): 消息推送服务器，提供IOS系统消息推送。（IOS消息推送必须走apns）</li>
</ul>
<p>从上面的介绍中，我们可以看出TeamTalk是支持分布式部署的一套聊天服务器程序，通过分布式部署可以实现分流和支持高数量的用户同时在线。msg_server是整个服务体系的核心系统，可以部署多个，不同的用户可以登录不同的msg_server。这套体系有如下几大亮点：</p>
<ol>
<li>
<p>login_server可以根据当前各个msg_server上在线用户数量，来决定一个新用户登录到哪个msg_server，从而实现了负载平衡；</p>
</li>
<li>
<p>route_server可以将登录在不同的msg_server上的用户的聊天消息发给目标用户；</p>
</li>
<li>
<p>通过单独的一个数据库操作服务器db_proxy_server，避免了msg_server直接操作数据库，将数据库操作的入口封装起来。</p>
</li>
</ol>
<p>在前一篇文章《服务器端db_proxy_server源码分析》中，我介绍了每个服务如何接收连接、读取数据并解包、以及组装数据包发包的操作，这篇文章我将介绍作为客户端，一个服务如何连接另外一个服务。这里msg_server在启动时会同时连接db_proxy_server，login_server，file_server，route_server，push_server。在msg_server服务main函数里面有如下初始化调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//连接file_server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>init_file_serv_conn(file_server_list, file_server_count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//连接db_proxy_server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>init_db_serv_conn(db_server_list2, db_server_count2, concurrent_db_conn_cnt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//连接login_server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>init_login_serv_conn(login_server_list, login_server_count, ip_addr1, ip_addr2, listen_port, max_conn_cnt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//连接push_server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>init_route_serv_conn(route_server_list, route_server_count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//连接push_server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>init_push_serv_conn(push_server_list, push_server_count);
</span></span></code></pre></div><p>其中每个连接服务的流程都是一样的。我们这里以第一个连接file_server为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_file_serv_conn</span>(serv_info_t<span style="color:#f92672">*</span> server_list, <span style="color:#66d9ef">uint32_t</span> server_count)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	g_file_server_list <span style="color:#f92672">=</span> server_list;
</span></span><span style="display:flex;"><span>	g_file_server_count <span style="color:#f92672">=</span> server_count;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	serv_init<span style="color:#f92672">&lt;</span>CFileServConn<span style="color:#f92672">&gt;</span>(g_file_server_list, g_file_server_count);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	netlib_register_timer(file_server_conn_timer_callback, NULL, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>	s_file_handler <span style="color:#f92672">=</span> CFileHandler<span style="color:#f92672">::</span>getInstance();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> serv_init(serv_info_t<span style="color:#f92672">*</span> server_list, <span style="color:#66d9ef">uint32_t</span> server_count)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> server_count; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		T<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T();
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>Connect(server_list[i].server_ip.c_str(), server_list[i].server_port, i);
</span></span><span style="display:flex;"><span>		server_list[i].serv_conn <span style="color:#f92672">=</span> pConn;
</span></span><span style="display:flex;"><span>		server_list[i].idle_cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		server_list[i].reconnect_cnt <span style="color:#f92672">=</span> MIN_RECONNECT_CNT <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>模板函数serv_init展开参数后实际上是调用CFileServConn-&gt;Connect()，我们看这个函数的调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CFileServConn<span style="color:#f92672">::</span>Connect(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> server_ip, <span style="color:#66d9ef">uint16_t</span> server_port, <span style="color:#66d9ef">uint32_t</span> idx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;Connecting to FileServer %s:%d &#34;</span>, server_ip, server_port);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	m_serv_idx <span style="color:#f92672">=</span> idx;
</span></span><span style="display:flex;"><span>	m_handle <span style="color:#f92672">=</span> netlib_connect(server_ip, server_port, imconn_callback, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>g_file_server_conn_map);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_handle <span style="color:#f92672">!=</span> NETLIB_INVALID_HANDLE) {
</span></span><span style="display:flex;"><span>		g_file_server_conn_map.insert(make_pair(m_handle, <span style="color:#66d9ef">this</span>));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这个函数里面创建连接socket，将该socket加入全局map g_file_server_conn_map中保存，map的key是socket句柄值，值是当前连接对象CFileServConn的指针。注意这里设置了回调函数imconn_callback。我们来看netlib_connect()实际连接的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>net_handle_t <span style="color:#a6e22e">netlib_connect</span>(
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> server_ip, 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint16_t</span>	port, 
</span></span><span style="display:flex;"><span>		callback_t	callback, 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>		callback_data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CBaseSocket();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pSocket)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_INVALID_HANDLE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	net_handle_t handle <span style="color:#f92672">=</span> pSocket<span style="color:#f92672">-&gt;</span>Connect(server_ip, port, callback, callback_data);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (handle <span style="color:#f92672">==</span> NETLIB_INVALID_HANDLE)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">delete</span> pSocket;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> handle;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>net_handle_t CBaseSocket<span style="color:#f92672">::</span>Connect(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> server_ip, <span style="color:#66d9ef">uint16_t</span> port, callback_t callback, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;CBaseSocket::Connect, server_ip=%s, port=%d&#34;</span>, server_ip, port);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_remote_ip <span style="color:#f92672">=</span> server_ip;
</span></span><span style="display:flex;"><span>	m_remote_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>	m_callback <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>	m_callback_data <span style="color:#f92672">=</span> callback_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_socket <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_socket <span style="color:#f92672">==</span> INVALID_SOCKET)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;socket failed, err_code=%d&#34;</span>, _GetErrorCode());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_INVALID_HANDLE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_SetNonblock(m_socket);
</span></span><span style="display:flex;"><span>	_SetNoDelay(m_socket);
</span></span><span style="display:flex;"><span>	sockaddr_in serv_addr;
</span></span><span style="display:flex;"><span>	_SetAddr(server_ip, port, <span style="color:#f92672">&amp;</span>serv_addr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> connect(m_socket, (sockaddr<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_addr, <span style="color:#66d9ef">sizeof</span>(serv_addr));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( (ret <span style="color:#f92672">==</span> SOCKET_ERROR) <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>_IsBlock(_GetErrorCode())) )
</span></span><span style="display:flex;"><span>	{	
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;connect failed, err_code=%d&#34;</span>, _GetErrorCode());
</span></span><span style="display:flex;"><span>		closesocket(m_socket);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_INVALID_HANDLE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	m_state <span style="color:#f92672">=</span> SOCKET_STATE_CONNECTING;
</span></span><span style="display:flex;"><span>	AddBaseSocket(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>	CEventDispatch<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>AddEvent(m_socket, SOCKET_ALL);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (net_handle_t)m_socket;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意这里有以下几点：</p>
<ol>
<li>
<p>将socket设置成非阻塞的。这样如果底层连接函数connect()不能立马完成，connect会立刻返回。</p>
</li>
<li>
<p>将socket的状态设置成SOCKET_STATE_CONNECTING。</p>
</li>
<li>
<p>AddBaseSocket(this)将该socket加入一个全局map中。</p>
</li>
<li>
<p>关注该socket的所有事件（SOCKET_ALL）。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> {
</span></span><span style="display:flex;"><span>	SOCKET_READ	<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1</span>,
</span></span><span style="display:flex;"><span>	SOCKET_WRITE	<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2</span>,
</span></span><span style="display:flex;"><span>	SOCKET_EXCEP	<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4</span>,
</span></span><span style="display:flex;"><span>	SOCKET_ALL	<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>因为socket是非阻塞，所以connect可能没连接成功，也会立即返回。那连接成功以后，我们如何得知呢？还记得上一篇文章中介绍的主线程的消息泵吗？TeamTalk每个服务的主线程都有一个这样的消息泵：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#960050;background-color:#1e0010">退出条件</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//1. 遍历定时器队列，检测是否有定时器事件到期，有则执行定时器的回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//2. 遍历其他任务队列，检测是否有其他任务需要执行，有，执行之
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//3. 检测socket集合，分离可读、可写和异常事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//4. 处理socket可读事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//5. 处理socket可写事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//6. 处理socket异常事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>当socket连接成功以后，该socket立马会变的可写。此时会触发第5步中的可写事件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CBaseSocket<span style="color:#f92672">::</span>OnWrite()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if ((defined _WIN32) || (defined __APPLE__))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	CEventDispatch<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>RemoveEvent(m_socket, SOCKET_WRITE);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_state <span style="color:#f92672">==</span> SOCKET_STATE_CONNECTING)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		socklen_t len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(error);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>error, <span style="color:#f92672">&amp;</span>len);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>error, <span style="color:#f92672">&amp;</span>len);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (error) {
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			m_state <span style="color:#f92672">=</span> SOCKET_STATE_CONNECTED;
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_CONFIRM, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		m_callback(m_callback_data, NETLIB_MSG_WRITE, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于该socket的状态是SOCKET_STATE_CONNECTING，会走第一个if分支。在不出错的情况下，以参数NETLIB_MSG_CONFIRM调用之前设置的回调函数imconn_callback。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">imconn_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	NOTUSED_ARG(handle);
</span></span><span style="display:flex;"><span>	NOTUSED_ARG(pParam);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>callback_data)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ConnMap_t<span style="color:#f92672">*</span> conn_map <span style="color:#f92672">=</span> (ConnMap_t<span style="color:#f92672">*</span>)callback_data;
</span></span><span style="display:flex;"><span>	CImConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> FindImConn(conn_map, handle);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pConn)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//log(&#34;msg=%d, handle=%d &#34;, msg, handle);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (msg)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_CONFIRM:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnConfirm();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_READ:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnRead();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_WRITE:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnWrite();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_CLOSE:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnClose();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;!!!imconn_callback error msg: %d &#34;</span>, msg);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pConn<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这次走pConn-&gt;OnConfirm();分支，由于pConn实际是CImConn的子类对象，根据C++多态性，会调用CFileServConn的OnConfirm()函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CFileServConn<span style="color:#f92672">::</span>OnConfirm()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;connect to file server success &#34;</span>);
</span></span><span style="display:flex;"><span>	m_bOpen <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	m_connect_time <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>	g_file_server_list[m_serv_idx].reconnect_cnt <span style="color:#f92672">=</span> MIN_RECONNECT_CNT <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//连上file_server以后，给file_server发送获取ip地址的数据包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMFileServerIPReq msg;
</span></span><span style="display:flex;"><span>    CImPdu pdu;
</span></span><span style="display:flex;"><span>    pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>    pdu.SetServiceId(SID_OTHER);
</span></span><span style="display:flex;"><span>    pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ);
</span></span><span style="display:flex;"><span>    SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>连接上file_server后，msg_server会立即给file_server发一个数据包，以获得file_server的ip地址等信息。</p>
<p>这就是msg_server作为客户端连接其他服务的流程。与这些服务之间的连接都对应一个连接对象：</p>
<pre tabindex="0"><code>file_server    CFileServConn
db_proxy_server  CDBServConn
login_server     CLoginServConn
route_server     CRouteServConn
push_server     CPushServConn
</code></pre><p>而且，和连接file_server一样，msg_server在连接这些服务成功以后，可能会需要将自己的一些状态信息告诉对方：</p>
<ul>
<li>连接file_server成功后，给对方发包获取对方的ip地址等信息</li>
<li>连接login_server成功以后,告诉login_server自己的ip地址、端口号和当前登录的用户数量和可容纳的最大用户数量，这样login_server将来对于一个需要登录的用户，会根据不同的msg_server的负载状态来决定用户到底登录哪个msg_server。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CLoginServConn<span style="color:#f92672">::</span>OnConfirm()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;connect to login server success &#34;</span>);
</span></span><span style="display:flex;"><span>	m_bOpen <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	g_login_server_list[m_serv_idx].reconnect_cnt <span style="color:#f92672">=</span> MIN_RECONNECT_CNT <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> cur_conn_cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> shop_user_cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//连接login_server成功以后,告诉login_server自己的ip地址、端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//和当前登录的用户数量和可容纳的最大用户数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    list<span style="color:#f92672">&lt;</span>user_conn_t<span style="color:#f92672">&gt;</span> user_conn_list;
</span></span><span style="display:flex;"><span>    CImUserManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>GetUserConnCnt(<span style="color:#f92672">&amp;</span>user_conn_list, cur_conn_cnt);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> hostname[<span style="color:#ae81ff">256</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>	gethostname(hostname, <span style="color:#ae81ff">256</span>);
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMMsgServInfo msg;
</span></span><span style="display:flex;"><span>    msg.set_ip1(g_msg_server_ip_addr1);
</span></span><span style="display:flex;"><span>    msg.set_ip2(g_msg_server_ip_addr2);
</span></span><span style="display:flex;"><span>    msg.set_port(g_msg_server_port);
</span></span><span style="display:flex;"><span>    msg.set_max_conn_cnt(g_max_conn_cnt);
</span></span><span style="display:flex;"><span>    msg.set_cur_conn_cnt(cur_conn_cnt);
</span></span><span style="display:flex;"><span>    msg.set_host_name(hostname);
</span></span><span style="display:flex;"><span>    CImPdu pdu;
</span></span><span style="display:flex;"><span>    pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>    pdu.SetServiceId(SID_OTHER);
</span></span><span style="display:flex;"><span>    pdu.SetCommandId(CID_OTHER_MSG_SERV_INFO);
</span></span><span style="display:flex;"><span>	SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>连接route_server成功以后，给route_server发包告诉当前登录在本msg_server上有哪些用户（用户id、用户状态、用户客户端类型）。这样将来A用户给B发聊天消息，msg_server将该聊天消息转给route_server，route_server就知道用户B在哪个msg_server上了，以便将该聊天消息发给B所在的msg_server。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CRouteServConn<span style="color:#f92672">::</span>OnConfirm()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;connect to route server success &#34;</span>);
</span></span><span style="display:flex;"><span>	m_bOpen <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	m_connect_time <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>	g_route_server_list[m_serv_idx].reconnect_cnt <span style="color:#f92672">=</span> MIN_RECONNECT_CNT <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (g_master_rs_conn <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		update_master_route_serv_conn();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//连接route_server成功以后，给route_server发包告诉当前登录在本msg_server上有哪些
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//用户（用户id、用户状态、用户客户端类型）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	list<span style="color:#f92672">&lt;</span>user_stat_t<span style="color:#f92672">&gt;</span> online_user_list;
</span></span><span style="display:flex;"><span>    CImUserManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>GetOnlineUserInfo(<span style="color:#f92672">&amp;</span>online_user_list);
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMOnlineUserInfo msg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span>user_stat_t<span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> online_user_list.begin(); it <span style="color:#f92672">!=</span> online_user_list.end(); it<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        user_stat_t user_stat <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it;
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ServerUserStat<span style="color:#f92672">*</span> server_user_stat <span style="color:#f92672">=</span> msg.add_user_stat_list();
</span></span><span style="display:flex;"><span>        server_user_stat<span style="color:#f92672">-&gt;</span>set_user_id(user_stat.user_id);
</span></span><span style="display:flex;"><span>        server_user_stat<span style="color:#f92672">-&gt;</span>set_status((<span style="color:#f92672">::</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>UserStatType)user_stat.status);
</span></span><span style="display:flex;"><span>        server_user_stat<span style="color:#f92672">-&gt;</span>set_client_type((<span style="color:#f92672">::</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientType)user_stat.client_type);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    CImPdu pdu;
</span></span><span style="display:flex;"><span>    pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>    pdu.SetServiceId(SID_OTHER);
</span></span><span style="display:flex;"><span>    pdu.SetCommandId(CID_OTHER_ONLINE_USER_INFO);
</span></span><span style="display:flex;"><span>	SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再来提一下，心跳包机制，和上一篇文章中介绍个与db_proxy_server一样，都是在定时器里面做的，这里不再赘述了，简单地贴出与file_server的心跳包代码吧：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_file_serv_conn</span>(serv_info_t<span style="color:#f92672">*</span> server_list, <span style="color:#66d9ef">uint32_t</span> server_count)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	g_file_server_list <span style="color:#f92672">=</span> server_list;
</span></span><span style="display:flex;"><span>	g_file_server_count <span style="color:#f92672">=</span> server_count;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	serv_init<span style="color:#f92672">&lt;</span>CFileServConn<span style="color:#f92672">&gt;</span>(g_file_server_list, g_file_server_count);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	netlib_register_timer(file_server_conn_timer_callback, NULL, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>	s_file_handler <span style="color:#f92672">=</span> CFileHandler<span style="color:#f92672">::</span>getInstance();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">file_server_conn_timer_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	ConnMap_t<span style="color:#f92672">::</span>iterator it_old;
</span></span><span style="display:flex;"><span>	CFileServConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> cur_time <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (ConnMap_t<span style="color:#f92672">::</span>iterator it <span style="color:#f92672">=</span> g_file_server_conn_map.begin(); it <span style="color:#f92672">!=</span> g_file_server_conn_map.end();
</span></span><span style="display:flex;"><span>         )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        it_old <span style="color:#f92672">=</span> it;
</span></span><span style="display:flex;"><span>        it<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		pConn <span style="color:#f92672">=</span> (CFileServConn<span style="color:#f92672">*</span>)it_old<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnTimer(cur_time);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// reconnect FileServer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	serv_check_reconnect<span style="color:#f92672">&lt;</span>CFileServConn<span style="color:#f92672">&gt;</span>(g_file_server_list, g_file_server_count);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在注册的定时器回调函数里面调用CFileServConn::OnTimer函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CFileServConn<span style="color:#f92672">::</span>OnTimer(<span style="color:#66d9ef">uint64_t</span> curr_tick)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (curr_tick <span style="color:#f92672">&gt;</span> m_last_send_tick <span style="color:#f92672">+</span> SERVER_HEARTBEAT_INTERVAL) {
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>Other<span style="color:#f92672">::</span>IMHeartBeat msg;
</span></span><span style="display:flex;"><span>        CImPdu pdu;
</span></span><span style="display:flex;"><span>        pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>        pdu.SetServiceId(SID_OTHER);
</span></span><span style="display:flex;"><span>        pdu.SetCommandId(CID_OTHER_HEARTBEAT);
</span></span><span style="display:flex;"><span>		SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (curr_tick <span style="color:#f92672">&gt;</span> m_last_recv_tick <span style="color:#f92672">+</span> SERVER_TIMEOUT) {
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;conn to file server timeout &#34;</span>);
</span></span><span style="display:flex;"><span>		Close();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来的就是每个连接上的业务处理代码了，主消息泵收到数据后触发OnRead函数，然后收取数据解包，然后根据包的命令号处理包，所以每个连接对象根据自己的业务都有一个HandlePdu()函数，例如CFileServConn的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CFileServConn<span style="color:#f92672">::</span>HandlePdu(CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (pPdu<span style="color:#f92672">-&gt;</span>GetCommandId()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> CID_OTHER_HEARTBEAT:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> CID_OTHER_FILE_TRANSFER_RSP:
</span></span><span style="display:flex;"><span>            _HandleFileMsgTransRsp(pPdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> CID_OTHER_FILE_SERVER_IP_RSP:
</span></span><span style="display:flex;"><span>            _HandleFileServerIPRsp(pPdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;unknown cmd id=%d &#34;</span>, pPdu<span style="color:#f92672">-&gt;</span>GetCommandId());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当然有些数据包，msg_server直接自己装包应答就可以了。有些必须发到其他服务进行进一步处理，比如登录请求，发给db_proxy_server拿到mysql中校验用户名和密码，db_proxy_server校验完成后，再应答msg_server，msg_server再应答客户端。</p>
<p>这大概就是msg_server服务的结构和源码了吧。具体业务代码你可以查看每个连接对象的HandlePdu()函数来看具体的流程细节。</p>
<p>需要指出的是：连接服务器、接受连接、收取数据解包、发送数据这四个模块是一个完整的网路库必须具有的东西。这篇文章和上一篇文章完整地介绍了这四个模块，而TeamTalk的实现手法也是目前主流网络库的通用做法。如果从事服务器开发，必须熟练掌握这里面的具体每个细节。而teamtalk服务器这种分布式架构设计的思想也是非常值得学习和借鉴的。</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/blog/5481b95ce7c64f8c99c98e3c59d74314/">
    <span class="title">« Prev</span>
    <br>
    <span>04 服务器端db_proxy_server源码分析</span>
  </a>
  <a class="next" href="https://haokiu.com/blog/1866caff3acc4baeb8666ea706d7ba7d/">
    <span class="title">Next »</span>
    <br>
    <span>06 服务器端login_server源码分析</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
