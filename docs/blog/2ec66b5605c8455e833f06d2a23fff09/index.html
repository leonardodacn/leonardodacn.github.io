<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>从零实现一个http服务器 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="从零实现一个http服务器 我始终觉得，天生的出身很重要，但后天的努力更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”；你和别人同时搞，你比别人搞的好，就是“专家”。
说到http协议和http请求，很多人都知道，但是他们真的“知道”吗？我面试过很多求职者，一说到http协议，他们能滔滔不绝，然后我问他http协议的具体格式是啥样子的？很多人不清楚，不清楚就不清楚吧，他甚至能将http协议的头扯到html文档头部。当我问http GET和POST请求的时候，GET请求是什么形式一般人都可以答出来，但是POST请求的数据放在哪里，服务器如何识别和解析这些POST数据，很多人又说不清道不明了。当说到http服务器时，很多人离开了apache、Nginx这样现成的http server之外，自己实现一个http服务器无从下手，如果实际应用场景有需要使用到一些简单http请求时，使用apache、Nginx这样重量级的http服务器程序实在劳师动众，你可以尝试自己实现一个简单的。
上面提到的问题，如果您不能清晰地回答出来，可以阅读一下这篇文章，这篇文章在不仅介绍http的格式，同时带领大家从零实现一个简单的http服务器程序。
一、项目背景 最近很多朋友希望我的flamingo服务器支持http协议，我自己也想做一个微信小程序，小程序通过http协议连接通过我的flamingo服务器进行聊天。flamingo是一个开源的即时通讯软件，目前除了服务器端，还有pc端、android端，后面会支持更多的终端。关于flamingo的介绍您可以参考这里: https://github.com/baloonwj/flamingo，更新日志：https://github.com/baloonwj/flamingo/issues/1。下面是flamingo的部分截图：
二、http协议介绍 1. http协议是应用层协议，一般建立在tcp协议的基础之上（当然你的实现非要基于udp也是可以的），也就是说http协议的数据收发是通过tcp协议的。
2. http协议也分为head和body两部分，但是我们一般说的html中的和标记不是http协议的头和身体，它们都是http协议的body部分。
那么http协议的头到底长啥样子呢？我们来介绍一下http协议吧。
http协议的格式如下：
GET或POST 请求的url路径（一般是去掉域名的路径） HTTP协议版本号\r\n字段1名: 字段1值\r\n字段2名: 字段2值\r\n…字段n名 : 字段n值\r\n\r\nhttp协议包体内容 也就是说http协议由两部分组成：包头和包体，包头与包体之间使用一个\r\n分割，由于http协议包头的每一行都是以**\r\n结束，所以http协议包头一般以\r\n\r\n**结束。
举个例子，比如我们在浏览器中请求http://www.hootina.org/index_2013.php这个网址，这是一个典型的GET方法，浏览器组装的http数据包格式如下：
GET /index_2013.php HTTP/1.1\r\nHost: www.hootina.org\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\nAccept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n\r\n 上面这个请求只有包头没有包体，http协议的包体不是必须的，也就是说GET请求一般没有包体。
如果GET请求带参数，那么一般是附加在请求的url后面，参数与参数之间使用&amp;分割，例如请求http://www.hootina.org/index_2013.php?param1=value1&amp;param2=value2&amp;param3=value3，我们看下这个请求组装的的http协议包格式：
GET /index_2013.php?param1=value1&amp;param2=value2&amp;param3=value3 HTTP/1.1\r\nHost: www.hootina.org\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\nAccept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n\r\n 对比一下，你现在知道http协议的GET参数放在协议包的什么位置了吧。
那么POST的数据放在什么位置呢？我们再12306网站https://kyfw.12306.cn/otn/login/init中登陆输入用户名和密码：
然后发现浏览器以POST方式组装了http协议包发送了我们的用户名、密码和其他一些信息，组装的包格式如下：
POST /passport/web/login HTTP/1.1\r\nHost: kyfw.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/blog/2ec66b5605c8455e833f06d2a23fff09/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="从零实现一个http服务器" />
<meta property="og:description" content="从零实现一个http服务器 我始终觉得，天生的出身很重要，但后天的努力更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”；你和别人同时搞，你比别人搞的好，就是“专家”。
说到http协议和http请求，很多人都知道，但是他们真的“知道”吗？我面试过很多求职者，一说到http协议，他们能滔滔不绝，然后我问他http协议的具体格式是啥样子的？很多人不清楚，不清楚就不清楚吧，他甚至能将http协议的头扯到html文档头部。当我问http GET和POST请求的时候，GET请求是什么形式一般人都可以答出来，但是POST请求的数据放在哪里，服务器如何识别和解析这些POST数据，很多人又说不清道不明了。当说到http服务器时，很多人离开了apache、Nginx这样现成的http server之外，自己实现一个http服务器无从下手，如果实际应用场景有需要使用到一些简单http请求时，使用apache、Nginx这样重量级的http服务器程序实在劳师动众，你可以尝试自己实现一个简单的。
上面提到的问题，如果您不能清晰地回答出来，可以阅读一下这篇文章，这篇文章在不仅介绍http的格式，同时带领大家从零实现一个简单的http服务器程序。
一、项目背景 最近很多朋友希望我的flamingo服务器支持http协议，我自己也想做一个微信小程序，小程序通过http协议连接通过我的flamingo服务器进行聊天。flamingo是一个开源的即时通讯软件，目前除了服务器端，还有pc端、android端，后面会支持更多的终端。关于flamingo的介绍您可以参考这里: https://github.com/baloonwj/flamingo，更新日志：https://github.com/baloonwj/flamingo/issues/1。下面是flamingo的部分截图：
二、http协议介绍 1. http协议是应用层协议，一般建立在tcp协议的基础之上（当然你的实现非要基于udp也是可以的），也就是说http协议的数据收发是通过tcp协议的。
2. http协议也分为head和body两部分，但是我们一般说的html中的和标记不是http协议的头和身体，它们都是http协议的body部分。
那么http协议的头到底长啥样子呢？我们来介绍一下http协议吧。
http协议的格式如下：
GET或POST 请求的url路径（一般是去掉域名的路径） HTTP协议版本号\r\n字段1名: 字段1值\r\n字段2名: 字段2值\r\n…字段n名 : 字段n值\r\n\r\nhttp协议包体内容 也就是说http协议由两部分组成：包头和包体，包头与包体之间使用一个\r\n分割，由于http协议包头的每一行都是以**\r\n结束，所以http协议包头一般以\r\n\r\n**结束。
举个例子，比如我们在浏览器中请求http://www.hootina.org/index_2013.php这个网址，这是一个典型的GET方法，浏览器组装的http数据包格式如下：
GET /index_2013.php HTTP/1.1\r\nHost: www.hootina.org\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\nAccept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n\r\n 上面这个请求只有包头没有包体，http协议的包体不是必须的，也就是说GET请求一般没有包体。
如果GET请求带参数，那么一般是附加在请求的url后面，参数与参数之间使用&amp;分割，例如请求http://www.hootina.org/index_2013.php?param1=value1&amp;param2=value2&amp;param3=value3，我们看下这个请求组装的的http协议包格式：
GET /index_2013.php?param1=value1&amp;param2=value2&amp;param3=value3 HTTP/1.1\r\nHost: www.hootina.org\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\nAccept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n\r\n 对比一下，你现在知道http协议的GET参数放在协议包的什么位置了吧。
那么POST的数据放在什么位置呢？我们再12306网站https://kyfw.12306.cn/otn/login/init中登陆输入用户名和密码：
然后发现浏览器以POST方式组装了http协议包发送了我们的用户名、密码和其他一些信息，组装的包格式如下：
POST /passport/web/login HTTP/1.1\r\nHost: kyfw." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/blog/2ec66b5605c8455e833f06d2a23fff09/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="从零实现一个http服务器"/>
<meta name="twitter:description" content="从零实现一个http服务器 我始终觉得，天生的出身很重要，但后天的努力更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”；你和别人同时搞，你比别人搞的好，就是“专家”。
说到http协议和http请求，很多人都知道，但是他们真的“知道”吗？我面试过很多求职者，一说到http协议，他们能滔滔不绝，然后我问他http协议的具体格式是啥样子的？很多人不清楚，不清楚就不清楚吧，他甚至能将http协议的头扯到html文档头部。当我问http GET和POST请求的时候，GET请求是什么形式一般人都可以答出来，但是POST请求的数据放在哪里，服务器如何识别和解析这些POST数据，很多人又说不清道不明了。当说到http服务器时，很多人离开了apache、Nginx这样现成的http server之外，自己实现一个http服务器无从下手，如果实际应用场景有需要使用到一些简单http请求时，使用apache、Nginx这样重量级的http服务器程序实在劳师动众，你可以尝试自己实现一个简单的。
上面提到的问题，如果您不能清晰地回答出来，可以阅读一下这篇文章，这篇文章在不仅介绍http的格式，同时带领大家从零实现一个简单的http服务器程序。
一、项目背景 最近很多朋友希望我的flamingo服务器支持http协议，我自己也想做一个微信小程序，小程序通过http协议连接通过我的flamingo服务器进行聊天。flamingo是一个开源的即时通讯软件，目前除了服务器端，还有pc端、android端，后面会支持更多的终端。关于flamingo的介绍您可以参考这里: https://github.com/baloonwj/flamingo，更新日志：https://github.com/baloonwj/flamingo/issues/1。下面是flamingo的部分截图：
二、http协议介绍 1. http协议是应用层协议，一般建立在tcp协议的基础之上（当然你的实现非要基于udp也是可以的），也就是说http协议的数据收发是通过tcp协议的。
2. http协议也分为head和body两部分，但是我们一般说的html中的和标记不是http协议的头和身体，它们都是http协议的body部分。
那么http协议的头到底长啥样子呢？我们来介绍一下http协议吧。
http协议的格式如下：
GET或POST 请求的url路径（一般是去掉域名的路径） HTTP协议版本号\r\n字段1名: 字段1值\r\n字段2名: 字段2值\r\n…字段n名 : 字段n值\r\n\r\nhttp协议包体内容 也就是说http协议由两部分组成：包头和包体，包头与包体之间使用一个\r\n分割，由于http协议包头的每一行都是以**\r\n结束，所以http协议包头一般以\r\n\r\n**结束。
举个例子，比如我们在浏览器中请求http://www.hootina.org/index_2013.php这个网址，这是一个典型的GET方法，浏览器组装的http数据包格式如下：
GET /index_2013.php HTTP/1.1\r\nHost: www.hootina.org\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\nAccept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n\r\n 上面这个请求只有包头没有包体，http协议的包体不是必须的，也就是说GET请求一般没有包体。
如果GET请求带参数，那么一般是附加在请求的url后面，参数与参数之间使用&amp;分割，例如请求http://www.hootina.org/index_2013.php?param1=value1&amp;param2=value2&amp;param3=value3，我们看下这个请求组装的的http协议包格式：
GET /index_2013.php?param1=value1&amp;param2=value2&amp;param3=value3 HTTP/1.1\r\nHost: www.hootina.org\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\nAccept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n\r\n 对比一下，你现在知道http协议的GET参数放在协议包的什么位置了吧。
那么POST的数据放在什么位置呢？我们再12306网站https://kyfw.12306.cn/otn/login/init中登陆输入用户名和密码：
然后发现浏览器以POST方式组装了http协议包发送了我们的用户名、密码和其他一些信息，组装的包格式如下：
POST /passport/web/login HTTP/1.1\r\nHost: kyfw."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "从零实现一个http服务器",
      "item": "https://haokiu.com/blog/2ec66b5605c8455e833f06d2a23fff09/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从零实现一个http服务器",
  "name": "从零实现一个http服务器",
  "description": "从零实现一个http服务器 我始终觉得，天生的出身很重要，但后天的努力更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”；你和别人同时搞，你比别人搞的好，就是“专家”。\n说到http协议和http请求，很多人都知道，但是他们真的“知道”吗？我面试过很多求职者，一说到http协议，他们能滔滔不绝，然后我问他http协议的具体格式是啥样子的？很多人不清楚，不清楚就不清楚吧，他甚至能将http协议的头扯到html文档头部。当我问http GET和POST请求的时候，GET请求是什么形式一般人都可以答出来，但是POST请求的数据放在哪里，服务器如何识别和解析这些POST数据，很多人又说不清道不明了。当说到http服务器时，很多人离开了apache、Nginx这样现成的http server之外，自己实现一个http服务器无从下手，如果实际应用场景有需要使用到一些简单http请求时，使用apache、Nginx这样重量级的http服务器程序实在劳师动众，你可以尝试自己实现一个简单的。\n上面提到的问题，如果您不能清晰地回答出来，可以阅读一下这篇文章，这篇文章在不仅介绍http的格式，同时带领大家从零实现一个简单的http服务器程序。\n一、项目背景 最近很多朋友希望我的flamingo服务器支持http协议，我自己也想做一个微信小程序，小程序通过http协议连接通过我的flamingo服务器进行聊天。flamingo是一个开源的即时通讯软件，目前除了服务器端，还有pc端、android端，后面会支持更多的终端。关于flamingo的介绍您可以参考这里: https://github.com/baloonwj/flamingo，更新日志：https://github.com/baloonwj/flamingo/issues/1。下面是flamingo的部分截图：\n二、http协议介绍 1. http协议是应用层协议，一般建立在tcp协议的基础之上（当然你的实现非要基于udp也是可以的），也就是说http协议的数据收发是通过tcp协议的。\n2. http协议也分为head和body两部分，但是我们一般说的html中的和标记不是http协议的头和身体，它们都是http协议的body部分。\n那么http协议的头到底长啥样子呢？我们来介绍一下http协议吧。\nhttp协议的格式如下：\nGET或POST 请求的url路径（一般是去掉域名的路径） HTTP协议版本号\\r\\n\r字段1名: 字段1值\\r\\n\r字段2名: 字段2值\\r\\n\r…\r字段n名 : 字段n值\\r\\n\r\\r\\n\rhttp协议包体内容 也就是说http协议由两部分组成：包头和包体，包头与包体之间使用一个\\r\\n分割，由于http协议包头的每一行都是以**\\r\\n结束，所以http协议包头一般以\\r\\n\\r\\n**结束。\n举个例子，比如我们在浏览器中请求http://www.hootina.org/index_2013.php这个网址，这是一个典型的GET方法，浏览器组装的http数据包格式如下：\nGET /index_2013.php HTTP/1.1\\r\\n\rHost: www.hootina.org\\r\\n\rConnection: keep-alive\\r\\n\rUpgrade-Insecure-Requests: 1\\r\\n\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\\r\\n\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\rAccept-Encoding: gzip, deflate\\r\\n\rAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\r\\r\\n 上面这个请求只有包头没有包体，http协议的包体不是必须的，也就是说GET请求一般没有包体。\n如果GET请求带参数，那么一般是附加在请求的url后面，参数与参数之间使用\u0026amp;分割，例如请求http://www.hootina.org/index_2013.php?param1=value1\u0026amp;param2=value2\u0026amp;param3=value3，我们看下这个请求组装的的http协议包格式：\nGET /index_2013.php?param1=value1\u0026amp;param2=value2\u0026amp;param3=value3 HTTP/1.1\\r\\n\rHost: www.hootina.org\\r\\n\rConnection: keep-alive\\r\\n\rUpgrade-Insecure-Requests: 1\\r\\n\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\\r\\n\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\rAccept-Encoding: gzip, deflate\\r\\n\rAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\r\\r\\n 对比一下，你现在知道http协议的GET参数放在协议包的什么位置了吧。\n那么POST的数据放在什么位置呢？我们再12306网站https://kyfw.12306.cn/otn/login/init中登陆输入用户名和密码：\n然后发现浏览器以POST方式组装了http协议包发送了我们的用户名、密码和其他一些信息，组装的包格式如下：\nPOST /passport/web/login HTTP/1.1\\r\\n\rHost: kyfw.",
  "keywords": [
    
  ],
  "articleBody": "从零实现一个http服务器 我始终觉得，天生的出身很重要，但后天的努力更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”；你和别人同时搞，你比别人搞的好，就是“专家”。\n说到http协议和http请求，很多人都知道，但是他们真的“知道”吗？我面试过很多求职者，一说到http协议，他们能滔滔不绝，然后我问他http协议的具体格式是啥样子的？很多人不清楚，不清楚就不清楚吧，他甚至能将http协议的头扯到html文档头部。当我问http GET和POST请求的时候，GET请求是什么形式一般人都可以答出来，但是POST请求的数据放在哪里，服务器如何识别和解析这些POST数据，很多人又说不清道不明了。当说到http服务器时，很多人离开了apache、Nginx这样现成的http server之外，自己实现一个http服务器无从下手，如果实际应用场景有需要使用到一些简单http请求时，使用apache、Nginx这样重量级的http服务器程序实在劳师动众，你可以尝试自己实现一个简单的。\n上面提到的问题，如果您不能清晰地回答出来，可以阅读一下这篇文章，这篇文章在不仅介绍http的格式，同时带领大家从零实现一个简单的http服务器程序。\n一、项目背景 最近很多朋友希望我的flamingo服务器支持http协议，我自己也想做一个微信小程序，小程序通过http协议连接通过我的flamingo服务器进行聊天。flamingo是一个开源的即时通讯软件，目前除了服务器端，还有pc端、android端，后面会支持更多的终端。关于flamingo的介绍您可以参考这里: https://github.com/baloonwj/flamingo，更新日志：https://github.com/baloonwj/flamingo/issues/1。下面是flamingo的部分截图：\n二、http协议介绍 1. http协议是应用层协议，一般建立在tcp协议的基础之上（当然你的实现非要基于udp也是可以的），也就是说http协议的数据收发是通过tcp协议的。\n2. http协议也分为head和body两部分，但是我们一般说的html中的和标记不是http协议的头和身体，它们都是http协议的body部分。\n那么http协议的头到底长啥样子呢？我们来介绍一下http协议吧。\nhttp协议的格式如下：\nGET或POST 请求的url路径（一般是去掉域名的路径） HTTP协议版本号\\r\\n\r字段1名: 字段1值\\r\\n\r字段2名: 字段2值\\r\\n\r…\r字段n名 : 字段n值\\r\\n\r\\r\\n\rhttp协议包体内容 也就是说http协议由两部分组成：包头和包体，包头与包体之间使用一个\\r\\n分割，由于http协议包头的每一行都是以**\\r\\n结束，所以http协议包头一般以\\r\\n\\r\\n**结束。\n举个例子，比如我们在浏览器中请求http://www.hootina.org/index_2013.php这个网址，这是一个典型的GET方法，浏览器组装的http数据包格式如下：\nGET /index_2013.php HTTP/1.1\\r\\n\rHost: www.hootina.org\\r\\n\rConnection: keep-alive\\r\\n\rUpgrade-Insecure-Requests: 1\\r\\n\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\\r\\n\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\rAccept-Encoding: gzip, deflate\\r\\n\rAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\r\\r\\n 上面这个请求只有包头没有包体，http协议的包体不是必须的，也就是说GET请求一般没有包体。\n如果GET请求带参数，那么一般是附加在请求的url后面，参数与参数之间使用\u0026分割，例如请求http://www.hootina.org/index_2013.php?param1=value1\u0026param2=value2\u0026param3=value3，我们看下这个请求组装的的http协议包格式：\nGET /index_2013.php?param1=value1\u0026param2=value2\u0026param3=value3 HTTP/1.1\\r\\n\rHost: www.hootina.org\\r\\n\rConnection: keep-alive\\r\\n\rUpgrade-Insecure-Requests: 1\\r\\n\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\\r\\n\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\rAccept-Encoding: gzip, deflate\\r\\n\rAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\r\\r\\n 对比一下，你现在知道http协议的GET参数放在协议包的什么位置了吧。\n那么POST的数据放在什么位置呢？我们再12306网站https://kyfw.12306.cn/otn/login/init中登陆输入用户名和密码：\n然后发现浏览器以POST方式组装了http协议包发送了我们的用户名、密码和其他一些信息，组装的包格式如下：\nPOST /passport/web/login HTTP/1.1\\r\\n\rHost: kyfw.12306.cn\\r\\n\rConnection: keep-alive\\r\\n\rContent-Length: 55\\r\\n\rAccept: application/json, text/javascript, */*; q=0.01\\r\\n\rOrigin: https://kyfw.12306.cn\\r\\n\rX-Requested-With: XMLHttpRequest\\r\\n\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\\r\\n\rContent-Type: application/x-www-form-urlencoded; charset=UTF-8\\r\\n\rReferer: https://kyfw.12306.cn/otn/login/init\\r\\n\rAccept-Encoding: gzip, deflate, br\\r\\n\rAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\rCookie: _passport_session=0b2cc5b86eb74bcc976bfa9dfef3e8a20712; _passport_ct=18d19b0930954d76b8057c732ce4cdcat8137; route=6f50b51faa11b987e576cdb301e545c4; RAIL_EXPIRATION=1526718782244; RAIL_DEVICEID=QuRAhOyIWv9lwWEhkq03x5Yl_livKZxx7gW6_-52oTZQda1c4zmVWxdw5Zk79xSDFHe9LJ57F8luYOFp_yahxDXQAOmEV8U1VgXavacuM2UPCFy3knfn42yTsJM3EYOy-hwpsP-jTb2OXevJj5acf40XsvsPDcM7; BIGipServerpool_passport=300745226.50215.0000; BIGipServerotn=1257243146.38945.0000; BIGipServerpassport=1005060362.50215.0000\\r\\n\r\\r\\n\rusername=balloonwj%40qq.com\u0026password=iloveyou\u0026appid=otn 其中username=balloonwj%40qq.com\u0026password=iloveyou\u0026appid=otn就是我们的POST数据，但是大家需要注意的以下几种，不要搞错： **1. 我的用户名是balloonwj@qq.com，到POST里面变成balloonwj%40qq.com，其中%40是@符号的16进制转码形式。这个码表可以参考这里：**http://www.w3school.com.cn/tags/html_ref_urlencode.html\n2.这里有三个变量，分别是username、password和appid，他们之间使用\u0026符号分割，但是请注意的是，这不意味着传递多个POST变量时必须使用\u0026符号分割，只不过这里是浏览器html表单（输入用户名和密码的文本框是html表单的一种）分割多个变量采用的默认方式而已。你可以根据你的需求，来自由定制，只要让服务器知道你的解析方式即可。比如可以这么分割：\n方法一\n1username=balloonwj%40qq.com|password=iloveyou|appid=otn 方法二\nusername:balloonwj%40qq.com\\r\\n\rpassword:iloveyou\\r\\n\rappid:otn\\r\\n 方法三\n1username,password,appid=balloonwj%40qq.com,iloveyou,otn 不管怎么分割，只要你能自己按一定的规则解析出来就可以了。\n不知道你注意到没有，上面的POST数据放在http包体中，服务器如何解析呢？可能你没明白我的意思，看下图：\n如上图所示，由于http协议是基于tcp协议的，tcp协议是流式协议，包头部分可以通过多出的\\r\\n来分界，包体部分如何分界呢？这是协议本身要解决的问题。目前一般有两种方式，第一种方式就是在包头中有个content-Length字段，这个字段的值的大小标识了POST数据的长度，上图中55就是数据username=balloonwj%40qq.com\u0026password=iloveyou\u0026appid=otn的长度，服务器收到一个数据包后，先从包头解析出这个字段的值，再根据这个值去读取相应长度的作为http协议的包体数据。还有一个格式叫做http chunked技术（分块），大致意思是将大包分成小包，具体的详情有兴趣的读者可以自行搜索学习。\n三、http客户端实现 如果您能掌握以上说的http协议，你就可以自己通过代码组装http协议发送http请求了（也是各种开源http库的做法）。我们先简单地介绍一下如何模拟发送http。举个例子，我们要请求http://www.hootina.org/index_2013.php，那么我们可以先通过域名得到ip地址，即通过socket API gethostbyname()得到www.hootina.org的ip地址，由于http服务器默认的端口号是80，有了域名和ip地址之后，我们使用socket API connect()去连接服务器，然后根据上面介绍的格式组装成http协议包，利用socket API send()函数发出去，如果服务器有应答，我们可以使用socket API recv()去接受数据，接下来就是解析数据（先解析包头和包体）。\n四、http服务器实现 我们这里简化一些问题，假设客户端发送的请求都是GET请求，当客户端发来http请求之后，我们拿到http包后就做相应的处理。我们以为我们的flamingo服务器实现一个支持http格式的注册请求为例。假设用户在浏览器里面输入以下网址，就可以实现一个注册功能：\nhttp://120.55.94.78:12345/register.do?p={“username”: “13917043329”, “nickname”: “balloon”, “password”: “123”}\n这里我们的http协议使用的是12345端口号而不是默认的80端口。如何侦听12345端口，这个是非常基础的知识了，这里就不介绍了。当我们收到数据以后：\nvoid HttpSession::OnRead(const std::shared_ptr\u0026 conn, Buffer* pBuffer, Timestamp receivTime)\r{\r//LOG_INFO \u003c\u003c \"Recv a http request from \" \u003c\u003c conn-\u003epeerAddress().toIpPort();\rstring inbuf;\r//先把所有数据都取出来\rinbuf.append(pBuffer-\u003epeek(), pBuffer-\u003ereadableBytes());\r//因为一个http包头的数据至少\\r\\n\\r\\n，所以大于4个字符\r//小于等于4个字符，说明数据未收完，退出，等待网络底层接着收取\rif (inbuf.length() \u003c= 4)\rreturn;\r//我们收到的GET请求数据包一般格式如下：\r/*\rGET /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22} HTTP/1.1\\r\\n\rHost: 120.55.94.78:12345\\r\\n\rConnection: keep-alive\\r\\n\rUpgrade-Insecure-Requests: 1\\r\\n\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\\r\\n\rAccept-Encoding: gzip, deflate\\r\\n\rAccept-Language: zh-CN, zh; q=0.9, en; q=0.8\\r\\n\r\\r\\n\r*/\r//检查是否以\\r\\n\\r\\n结束，如果不是说明包头不完整，退出\rstring end = inbuf.substr(inbuf.length() - 4);\rif (end != \"\\r\\n\\r\\n\")\rreturn;\r//以\\r\\n分割每一行\rstd::vector lines;\rStringUtil::Split(inbuf, lines, \"\\r\\n\");\rif (lines.size() \u003c 1 || lines[0].empty())\r{\rconn-\u003eforceClose();\rreturn;\r}\rstd::vector chunk;\rStringUtil::Split(lines[0], chunk, \" \");\r//chunk中至少有三个字符串：GET+url+HTTP版本号\rif (chunk.size() \u003c 3)\r{\rconn-\u003eforceClose();\rreturn;\r}\rLOG_INFO \u003c\u003c \"url: \" \u003c\u003c chunk[1] \u003c\u003c \" from \" \u003c\u003c conn-\u003epeerAddress().toIpPort();\r//inbuf = /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22}\rstd::vector part;\r//通过?分割成前后两端，前面是url，后面是参数\rStringUtil::Split(chunk[1], part, \"?\");\r//chunk中至少有三个字符串：GET+url+HTTP版本号\rif (part.size() \u003c 2)\r{\rconn-\u003eforceClose();\rreturn;\r}\rstring url = part[0];\rstring param = part[1].substr(2);\rif (!Process(conn, url, param))\r{\rLOG_ERROR \u003c\u003c \"handle http request error, from:\" \u003c\u003c conn-\u003epeerAddress().toIpPort() \u003c\u003c \", request: \" \u003c\u003c pBuffer-\u003eretrieveAllAsString();\r}\r//短连接，处理完关闭连接\rconn-\u003eforceClose();\r} 代码注释都写的很清楚，我们先利用\\r\\n分割得到每一行，其中第一行的数据是：\nGET /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22} HTTP/1.1 其中%22是双引号的url转码形式，%20是空格的url转码形式，然后我们根据空格分成三段，其中第二段就是我们的网址和参数：\n/register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22} 然后我们根据网址与参数之间的问号将这个分成两段：第一段是网址，第二段是参数：\nbool HttpSession::Process(const std::shared_ptr\u0026 conn, const std::string\u0026 url, const std::string\u0026 param)\r{\rif (url.empty())\rreturn false;\rif (url == \"/register.do\")\r{\rOnRegisterResponse(param, conn);\r}\relse if (url == \"/login.do\")\r{\rOnLoginResponse(param, conn);\r}\relse if (url == \"/getfriendlist.do\")\r{\r}\relse if (url == \"/getgroupmembers.do\")\r{\r}\relse\rreturn false;\rreturn true;\r} 然后我们根据url匹配网址，如果是注册请求，会走注册处理逻辑：\nvoid HttpSession::OnRegisterResponse(const std::string\u0026 data, const std::shared_ptr\u0026 conn)\r{\rstring retData;\rstring decodeData;\rURLEncodeUtil::Decode(data, decodeData);\rBussinessLogic::RegisterUser(decodeData, conn, false, retData);\rif (!retData.empty())\r{\rstd::string response;\rURLEncodeUtil::Encode(retData, response);\rMakeupResponse(retData, response);\rconn-\u003esend(response);\rLOG_INFO \u003c\u003c \"Response to client: cmd=msg_type_register\" \u003c\u003c \", data=\" \u003c\u003c retData \u003c\u003c conn-\u003epeerAddress().toIpPort();;\r}\r} 注册结果放在retData中，为了发给客户端，我们将结果中的特殊字符如双引号转码，如返回结果是：\n{\"code\":0, \"msg\":\"ok\"} 会被转码成：\n{%22code%22:0,%20%22msg%22:%22ok%22} 然后，将数据组装成http协议发给客户端，给客户端的应答协议与http请求协议有一点点差别，就是将请求的url路径换成所谓的http响应码，如200表示应答正常返回、404页面不存在。应答协议格式如下：\nGET或POST 响应码 HTTP协议版本号\\r\\n\r字段1名: 字段1值\\r\\n\r字段2名: 字段2值\\r\\n\r…\r字段n名 : 字段n值\\r\\n\r\\r\\n\rhttp协议包体内容 举个例子如：\nHTTP/1.1 200 OK\\r\\n\rContent-Type: text/html\\r\\n\rContent-Length:42\\r\\n\r\\r\\n\r{%22code%22:%200,%20%22msg%22:%20%22ok%22} 注意，包头中的Content-Length长度必须正好是包体{%22code%22:%200,%20%22msg%22:%20%22ok%22}的长度，这里是42。这也符合我们浏览器的返回结果：\n当然，需要注意的是，我们一般说http连接一般是短连接，这里我们也实现了这个功能（看上面的代码：conn-\u003eforceClose();），不管一个http请求是否成功，服务器处理后立马就关闭连接。\n当然，这里还有一些没处理好的地方，如果你仔细观察上面的代码就会发现这个问题，就是不满足一个http包头时的处理，如果某个客户端（不是使用浏览器）通过程序模拟了一个连接请求，但是迟迟不发含有\\r\\n\\r\\n的数据，这路连接将会一直占用。我们可以判断收到的数据长度，防止别有用心的客户端给我们的服务器乱发数据。我们假定，我们能处理的最大url长度是2048，如果用户发送的数据累积不含\\r\\n\\r\\n，且超过2048个，我们认为连接非法，将连接断开。代码修改成如下形式：\nvoid HttpSession::OnRead(const std::shared_ptr\u0026 conn, Buffer* pBuffer, Timestamp receivTime)\r{\r//LOG_INFO \u003c\u003c \"Recv a http request from \" \u003c\u003c conn-\u003epeerAddress().toIpPort();\rstring inbuf;\r//先把所有数据都取出来\rinbuf.append(pBuffer-\u003epeek(), pBuffer-\u003ereadableBytes());\r//因为一个http包头的数据至少\\r\\n\\r\\n，所以大于4个字符\r//小于等于4个字符，说明数据未收完，退出，等待网络底层接着收取\rif (inbuf.length() \u003c= 4)\rreturn;\r//我们收到的GET请求数据包一般格式如下：\r/*\rGET /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22} HTTP/1.1\\r\\n\rHost: 120.55.94.78:12345\\r\\n\rConnection: keep-alive\\r\\n\rUpgrade-Insecure-Requests: 1\\r\\n\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\\r\\n\rAccept-Encoding: gzip, deflate\\r\\n\rAccept-Language: zh-CN, zh; q=0.9, en; q=0.8\\r\\n\r\\r\\n\r*/\r//检查是否以\\r\\n\\r\\n结束，如果不是说明包头不完整，退出\rstring end = inbuf.substr(inbuf.length() - 4);\rif (end != \"\\r\\n\\r\\n\")\rreturn;\r//超过2048个字符，且不含\\r\\n\\r\\n，我们认为是非法请求\relse if (inbuf.length() \u003e= MAX_URL_LENGTH)\r{\rconn-\u003eforceClose();\rreturn;\r}\r//以\\r\\n分割每一行\rstd::vector lines;\rStringUtil::Split(inbuf, lines, \"\\r\\n\");\rif (lines.size() \u003c 1 || lines[0].empty())\r{\rconn-\u003eforceClose();\rreturn;\r}\rstd::vector chunk;\rStringUtil::Split(lines[0], chunk, \" \");\r//chunk中至少有三个字符串：GET+url+HTTP版本号\rif (chunk.size() \u003c 3)\r{\rconn-\u003eforceClose();\rreturn;\r}\rLOG_INFO \u003c\u003c \"url: \" \u003c\u003c chunk[1] \u003c\u003c \" from \" \u003c\u003c conn-\u003epeerAddress().toIpPort();\r//inbuf = /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22}\rstd::vector part;\r//通过?分割成前后两端，前面是url，后面是参数\rStringUtil::Split(chunk[1], part, \"?\");\r//chunk中至少有三个字符串：GET+url+HTTP版本号\rif (part.size() \u003c 2)\r{\rconn-\u003eforceClose();\rreturn;\r}\rstring url = part[0];\rstring param = part[1].substr(2);\rif (!Process(conn, url, param))\r{\rLOG_ERROR \u003c\u003c \"handle http request error, from:\" \u003c\u003c conn-\u003epeerAddress().toIpPort() \u003c\u003c \", request: \" \u003c\u003c pBuffer-\u003eretrieveAllAsString();\r}\r//短连接，处理完关闭连接\rconn-\u003eforceClose();\r} 但这只能解决发送非法数据的情况，如果一个客户端连上来不给我们发任何数据，这段逻辑就无能为力了。如果不断有客户端这么做，会浪费我们大量的连接资源，所以我们还需要一个定时器去定时检测哪些http连接超过一定时间内没给我们发数据，找到后将连接断开。这又涉及到服务器定时器如何设计了，关于这部分请参考我写的其他文章。\n限于作者经验水平有限，文中难免有错乱之处，欢迎拍砖。另外，关于上面的代码，可以去github上下载，地址是：\nhttps://github.com/baloonwj/flamingo\n",
  "wordCount" : "673",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/blog/2ec66b5605c8455e833f06d2a23fff09/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      从零实现一个http服务器
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%bb%8e%e9%9b%b6%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aahttp%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="从零实现一个http服务器">从零实现一个http服务器</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e9%a1%b9%e7%9b%ae%e8%83%8c%e6%99%af" aria-label="一、项目背景">一、项目背景</a></li>
                <li>
                    <a href="#%e4%ba%8chttp%e5%8d%8f%e8%ae%ae%e4%bb%8b%e7%bb%8d" aria-label="二、http协议介绍">二、http协议介绍</a></li>
                <li>
                    <a href="#%e4%b8%89http%e5%ae%a2%e6%88%b7%e7%ab%af%e5%ae%9e%e7%8e%b0" aria-label="三、http客户端实现">三、http客户端实现</a></li>
                <li>
                    <a href="#%e5%9b%9bhttp%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%ae%9e%e7%8e%b0" aria-label="四、http服务器实现">四、http服务器实现</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="从零实现一个http服务器">从零实现一个http服务器</h2>
<p>我始终觉得，天生的出身很重要，但<strong>后天的努力</strong>更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”；你和别人同时搞，你比别人搞的好，就是“专家”。</p>
<p>说到<strong>http协议</strong>和<strong>http请求</strong>，很多人都知道，但是他们真的“知道”吗？我面试过很多求职者，一说到http协议，他们能滔滔不绝，然后我问他http协议的具体格式是啥样子的？很多人不清楚，不清楚就不清楚吧，他甚至能将http协议的头扯到html文档头部。当我问http GET和POST请求的时候，GET请求是什么形式一般人都可以答出来，但是POST请求的数据放在哪里，服务器如何识别和解析这些POST数据，很多人又说不清道不明了。当说到http服务器时，很多人离开了apache、Nginx这样现成的http server之外，自己实现一个http服务器无从下手，如果实际应用场景有需要使用到一些简单http请求时，使用apache、Nginx这样重量级的http服务器程序实在劳师动众，你可以尝试自己实现一个简单的。</p>
<p>上面提到的问题，如果您不能清晰地回答出来，可以阅读一下这篇文章，这篇文章在不仅介绍http的格式，同时带领大家从零实现一个简单的http服务器程序。</p>
<h3 id="一项目背景">一、项目背景</h3>
<p>最近很多朋友希望我的flamingo服务器支持http协议，我自己也想做一个微信小程序，小程序通过http协议连接通过我的flamingo服务器进行聊天。flamingo是一个开源的即时通讯软件，目前除了服务器端，还有pc端、android端，后面会支持更多的终端。关于flamingo的介绍您可以参考这里: <a href="https://github.com/baloonwj/flamingo">https://github.com/baloonwj/flamingo</a>，更新日志：https://github.com/baloonwj/flamingo/issues/1。下面是flamingo的部分截图：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/5b508fa1294d99b29a0d6427deb73c4f.webp" alt=""  />
</p>
<h3 id="二http协议介绍">二、http协议介绍</h3>
<p><strong>1. http协议是应用层协议，一般建立在tcp协议的基础之上（当然你的实现非要基于udp也是可以的），也就是说http协议的数据收发是通过tcp协议的。</strong></p>
<p><strong>2. http协议也分为head和body两部分，但是我们一般说的html中的和标记不是http协议的头和身体，它们都是http协议的body部分。</strong></p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/1bbd8f93cfbbbff100f88eef85d6e57d.webp" alt=""  />
</p>
<p>那么http协议的头到底长啥样子呢？我们来介绍一下http协议吧。</p>
<p>http协议的格式如下：</p>
<pre tabindex="0"><code>GET或POST 请求的url路径（一般是去掉域名的路径） HTTP协议版本号\r\n
字段1名: 字段1值\r\n
字段2名: 字段2值\r\n
     …
字段n名 : 字段n值\r\n
\r\n
http协议包体内容
</code></pre><p>也就是说http协议由两部分组成：包头和包体，包头与包体之间使用一个\r\n分割，由于http协议包头的每一行都是以**\r\n<strong>结束，所以http协议包头一般以</strong>\r\n\r\n**结束。</p>
<p>举个例子，比如我们在浏览器中请求http://www.hootina.org/index_2013.php这个网址，这是一个典型的GET方法，浏览器组装的http数据包格式如下：</p>
<pre tabindex="0"><code>GET /index_2013.php HTTP/1.1\r\n
Host: www.hootina.org\r\n
Connection: keep-alive\r\n
Upgrade-Insecure-Requests: 1\r\n
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n
Accept-Encoding: gzip, deflate\r\n
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n
\r\n
</code></pre><p>上面这个请求只有包头没有包体，http协议的包体不是必须的，也就是说GET请求一般没有包体。</p>
<p>如果GET请求带参数，那么一般是附加在请求的url后面，参数与参数之间使用&amp;分割，例如请求http://www.hootina.org/index_2013.php?param1=value1&amp;param2=value2&amp;param3=value3，我们看下这个请求组装的的http协议包格式：</p>
<pre tabindex="0"><code>GET /index_2013.php?param1=value1&amp;param2=value2&amp;param3=value3 HTTP/1.1\r\n
Host: www.hootina.org\r\n
Connection: keep-alive\r\n
Upgrade-Insecure-Requests: 1\r\n
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n
Accept-Encoding: gzip, deflate\r\n
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n
\r\n
</code></pre><p>对比一下，你现在知道http协议的GET参数放在协议包的什么位置了吧。</p>
<p>那么POST的数据放在什么位置呢？我们再12306网站https://kyfw.12306.cn/otn/login/init中登陆输入用户名和密码：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/462ac62806eb2d4d2e8dc88fdf74bb11.webp" alt=""  />
</p>
<p>然后发现浏览器以POST方式组装了http协议包发送了我们的用户名、密码和其他一些信息，组装的包格式如下：</p>
<pre tabindex="0"><code>POST /passport/web/login HTTP/1.1\r\n
Host: kyfw.12306.cn\r\n
Connection: keep-alive\r\n
Content-Length: 55\r\n
Accept: application/json, text/javascript, */*; q=0.01\r\n
Origin: https://kyfw.12306.cn\r\n
X-Requested-With: XMLHttpRequest\r\n
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\n
Content-Type: application/x-www-form-urlencoded; charset=UTF-8\r\n
Referer: https://kyfw.12306.cn/otn/login/init\r\n
Accept-Encoding: gzip, deflate, br\r\n
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n
Cookie: _passport_session=0b2cc5b86eb74bcc976bfa9dfef3e8a20712; _passport_ct=18d19b0930954d76b8057c732ce4cdcat8137; route=6f50b51faa11b987e576cdb301e545c4; RAIL_EXPIRATION=1526718782244; RAIL_DEVICEID=QuRAhOyIWv9lwWEhkq03x5Yl_livKZxx7gW6_-52oTZQda1c4zmVWxdw5Zk79xSDFHe9LJ57F8luYOFp_yahxDXQAOmEV8U1VgXavacuM2UPCFy3knfn42yTsJM3EYOy-hwpsP-jTb2OXevJj5acf40XsvsPDcM7; BIGipServerpool_passport=300745226.50215.0000; BIGipServerotn=1257243146.38945.0000; BIGipServerpassport=1005060362.50215.0000\r\n
\r\n
username=balloonwj%40qq.com&amp;password=iloveyou&amp;appid=otn
</code></pre><p>其中<code>username=balloonwj%40qq.com&amp;password=iloveyou&amp;appid=otn</code>就是我们的POST数据，但是大家需要注意的以下几种，不要搞错：
**1. 我的用户名是balloonwj@qq.com，到POST里面变成balloonwj%40qq.com，其中%40是@符号的16进制转码形式。这个码表可以参考这里：**<strong><a href="http://www.w3school.com.cn/tags/html_ref_urlencode.html">http://www.w3school.com.cn/tags/html_ref_urlencode.html</a></strong></p>
<p><strong>2.这里有三个变量，分别是username、password和appid，他们之间使用&amp;符号分割，但是请注意的是，这不意味着传递多个POST变量时必须使用&amp;符号分割，只不过这里是浏览器html表单（输入用户名和密码的文本框是html表单的一种）分割多个变量采用的默认方式而已。你可以根据你的需求，来自由定制，只要让服务器知道你的解析方式即可。比如可以这么分割：</strong></p>
<p><strong>方法一</strong></p>
<pre tabindex="0"><code>1username=balloonwj%40qq.com|password=iloveyou|appid=otn
</code></pre><p><strong>方法二</strong></p>
<pre tabindex="0"><code>username:balloonwj%40qq.com\r\n
password:iloveyou\r\n
appid:otn\r\n
</code></pre><p><strong>方法三</strong></p>
<pre tabindex="0"><code>1username,password,appid=balloonwj%40qq.com,iloveyou,otn
</code></pre><p>不管怎么分割，只要你能自己按一定的规则解析出来就可以了。</p>
<p>不知道你注意到没有，上面的POST数据放在http包体中，服务器如何解析呢？可能你没明白我的意思，看下图：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/9670076e1f4f46a79737b844beb02096.webp" alt=""  />
</p>
<p>如上图所示，由于http协议是基于tcp协议的，tcp协议是流式协议，包头部分可以通过多出的\r\n来分界，包体部分如何分界呢？这是协议本身要解决的问题。目前一般有两种方式，第一种方式就是在包头中有个<code>content-Length</code>字段，这个字段的值的大小标识了POST数据的长度，上图中55就是数据<code>username=balloonwj%40qq.com&amp;password=iloveyou&amp;appid=otn</code>的长度，服务器收到一个数据包后，先从包头解析出这个字段的值，再根据这个值去读取相应长度的作为http协议的包体数据。还有一个格式叫做<strong>http chunked技术</strong>（分块），大致意思是将大包分成小包，具体的详情有兴趣的读者可以自行搜索学习。</p>
<h3 id="三http客户端实现">三、http客户端实现</h3>
<p>如果您能掌握以上说的http协议，你就可以自己通过代码组装http协议发送http请求了（也是各种开源http库的做法）。我们先简单地介绍一下如何模拟发送http。举个例子，我们要请求http://www.hootina.org/index_2013.php，那么我们可以先通过域名得到ip地址，即通过socket API <code>gethostbyname()</code>得到www.hootina.org的ip地址，由于http服务器默认的端口号是80，有了域名和ip地址之后，我们使用socket API <code>connect()</code>去连接服务器，然后根据上面介绍的格式组装成http协议包，利用socket API <code>send()</code>函数发出去，如果服务器有应答，我们可以使用socket API <code>recv()</code>去接受数据，接下来就是解析数据（先解析包头和包体）。</p>
<h3 id="四http服务器实现">四、http服务器实现</h3>
<p>我们这里简化一些问题，假设客户端发送的请求都是GET请求，当客户端发来http请求之后，我们拿到http包后就做相应的处理。我们以为我们的flamingo服务器实现一个支持http格式的注册请求为例。假设用户在浏览器里面输入以下网址，就可以实现一个注册功能：</p>
<p>http://120.55.94.78:12345/register.do?p={&ldquo;username&rdquo;: &ldquo;13917043329&rdquo;, &ldquo;nickname&rdquo;: &ldquo;balloon&rdquo;, &ldquo;password&rdquo;: &ldquo;123&rdquo;}</p>
<p>这里我们的http协议使用的是12345端口号而不是默认的80端口。如何侦听12345端口，这个是非常基础的知识了，这里就不介绍了。当我们收到数据以后：</p>
<pre tabindex="0"><code>void HttpSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)
{
    //LOG_INFO &lt;&lt; &#34;Recv a http request from &#34; &lt;&lt; conn-&gt;peerAddress().toIpPort();

    string inbuf;
    //先把所有数据都取出来
    inbuf.append(pBuffer-&gt;peek(), pBuffer-&gt;readableBytes());
    //因为一个http包头的数据至少\r\n\r\n，所以大于4个字符
    //小于等于4个字符，说明数据未收完，退出，等待网络底层接着收取
    if (inbuf.length() &lt;= 4)
        return;

    //我们收到的GET请求数据包一般格式如下：
    /*
    GET /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22} HTTP/1.1\r\n
    Host: 120.55.94.78:12345\r\n
    Connection: keep-alive\r\n
    Upgrade-Insecure-Requests: 1\r\n
    User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\n
    Accept-Encoding: gzip, deflate\r\n
    Accept-Language: zh-CN, zh; q=0.9, en; q=0.8\r\n
    \r\n
     */
    //检查是否以\r\n\r\n结束，如果不是说明包头不完整，退出
    string end = inbuf.substr(inbuf.length() - 4);
    if (end != &#34;\r\n\r\n&#34;)
        return;

    //以\r\n分割每一行
    std::vector&lt;string&gt; lines;
    StringUtil::Split(inbuf, lines, &#34;\r\n&#34;);
    if (lines.size() &lt; 1 || lines[0].empty())
    {
        conn-&gt;forceClose();
        return;
    }

    std::vector&lt;string&gt; chunk;
    StringUtil::Split(lines[0], chunk, &#34; &#34;);
    //chunk中至少有三个字符串：GET+url+HTTP版本号
    if (chunk.size() &lt; 3)
    {
        conn-&gt;forceClose();
        return;
    }

    LOG_INFO &lt;&lt; &#34;url: &#34; &lt;&lt; chunk[1] &lt;&lt; &#34; from &#34; &lt;&lt; conn-&gt;peerAddress().toIpPort();
    //inbuf = /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22}
    std::vector&lt;string&gt; part;
    //通过?分割成前后两端，前面是url，后面是参数
    StringUtil::Split(chunk[1], part, &#34;?&#34;);
    //chunk中至少有三个字符串：GET+url+HTTP版本号
    if (part.size() &lt; 2)
    {
        conn-&gt;forceClose();
        return;
    }

    string url = part[0];
    string param = part[1].substr(2);

    if (!Process(conn, url, param))
    {
        LOG_ERROR &lt;&lt; &#34;handle http request error, from:&#34; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &#34;, request: &#34; &lt;&lt; pBuffer-&gt;retrieveAllAsString();
    }

    //短连接，处理完关闭连接
    conn-&gt;forceClose();
}
</code></pre><p>代码注释都写的很清楚，我们先利用\r\n分割得到每一行，其中第一行的数据是：</p>
<pre tabindex="0"><code>GET /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22} HTTP/1.1
</code></pre><p>其中%22是双引号的url转码形式，%20是空格的url转码形式，然后我们根据空格分成三段，其中第二段就是我们的网址和参数：</p>
<pre tabindex="0"><code>/register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22}
</code></pre><p>然后我们根据网址与参数之间的问号将这个分成两段：第一段是网址，第二段是参数：</p>
<pre tabindex="0"><code>bool HttpSession::Process(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, const std::string&amp; url, const std::string&amp; param)
{
    if (url.empty())
        return false;

    if (url == &#34;/register.do&#34;)
    {
        OnRegisterResponse(param, conn);
    }
    else if (url == &#34;/login.do&#34;)
    {
        OnLoginResponse(param, conn);
    }
    else if (url == &#34;/getfriendlist.do&#34;)
    {

    }
    else if (url == &#34;/getgroupmembers.do&#34;)
    {

    }
    else
        return false;


    return true;
}
</code></pre><p>然后我们根据url匹配网址，如果是注册请求，会走注册处理逻辑：</p>
<pre tabindex="0"><code>void HttpSession::OnRegisterResponse(const std::string&amp; data, const std::shared_ptr&lt;TcpConnection&gt;&amp; conn)
{
    string retData;
    string decodeData;
    URLEncodeUtil::Decode(data, decodeData);
    BussinessLogic::RegisterUser(decodeData, conn, false, retData);
    if (!retData.empty())
    {
        std::string response;
        URLEncodeUtil::Encode(retData, response);
        MakeupResponse(retData, response);
        conn-&gt;send(response);

        LOG_INFO &lt;&lt; &#34;Response to client: cmd=msg_type_register&#34; &lt;&lt; &#34;, data=&#34; &lt;&lt; retData &lt;&lt; conn-&gt;peerAddress().toIpPort();;
    }
}
</code></pre><p>注册结果放在retData中，为了发给客户端，我们将结果中的特殊字符如双引号转码，如返回结果是：</p>
<pre tabindex="0"><code>{&#34;code&#34;:0, &#34;msg&#34;:&#34;ok&#34;}
</code></pre><p>会被转码成：</p>
<pre tabindex="0"><code>{%22code%22:0,%20%22msg%22:%22ok%22}
</code></pre><p>然后，将数据组装成http协议发给客户端，给客户端的应答协议与http请求协议有一点点差别，就是将请求的url路径换成所谓的http响应码，如200表示应答正常返回、404页面不存在。应答协议格式如下：</p>
<pre tabindex="0"><code>GET或POST 响应码 HTTP协议版本号\r\n
字段1名: 字段1值\r\n
字段2名: 字段2值\r\n
     …
字段n名 : 字段n值\r\n
\r\n
http协议包体内容
</code></pre><p>举个例子如：</p>
<pre tabindex="0"><code>HTTP/1.1 200 OK\r\n
Content-Type: text/html\r\n
Content-Length:42\r\n
\r\n
{%22code%22:%200,%20%22msg%22:%20%22ok%22}
</code></pre><p>注意，包头中的<strong>Content-Length长度</strong>必须正好是包体<code>{%22code%22:%200,%20%22msg%22:%20%22ok%22}</code>的长度，这里是42。这也符合我们浏览器的返回结果：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/481cf507bc8e82e60be30533086f36ed.webp" alt=""  />
</p>
<p>当然，需要注意的是，我们一般说http连接一般是短连接，这里我们也实现了这个功能（看上面的代码：<code>conn-&gt;forceClose();</code>），不管一个http请求是否成功，服务器处理后立马就关闭连接。</p>
<p>当然，这里还有一些没处理好的地方，如果你仔细观察上面的代码就会发现这个问题，就是不满足一个http包头时的处理，如果某个客户端（不是使用浏览器）通过程序模拟了一个连接请求，但是迟迟不发含有\r\n\r\n的数据，这路连接将会一直占用。我们可以判断收到的数据长度，防止别有用心的客户端给我们的服务器乱发数据。我们假定，我们能处理的最大url长度是2048，如果用户发送的数据累积不含\r\n\r\n，且超过2048个，我们认为连接非法，将连接断开。代码修改成如下形式：</p>
<pre tabindex="0"><code>void HttpSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)
{
    //LOG_INFO &lt;&lt; &#34;Recv a http request from &#34; &lt;&lt; conn-&gt;peerAddress().toIpPort();

    string inbuf;
    //先把所有数据都取出来
    inbuf.append(pBuffer-&gt;peek(), pBuffer-&gt;readableBytes());
    //因为一个http包头的数据至少\r\n\r\n，所以大于4个字符
    //小于等于4个字符，说明数据未收完，退出，等待网络底层接着收取
    if (inbuf.length() &lt;= 4)
        return;

    //我们收到的GET请求数据包一般格式如下：
    /*
    GET /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22} HTTP/1.1\r\n
    Host: 120.55.94.78:12345\r\n
    Connection: keep-alive\r\n
    Upgrade-Insecure-Requests: 1\r\n
    User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\r\n
    Accept-Encoding: gzip, deflate\r\n
    Accept-Language: zh-CN, zh; q=0.9, en; q=0.8\r\n
    \r\n
     */
    //检查是否以\r\n\r\n结束，如果不是说明包头不完整，退出
    string end = inbuf.substr(inbuf.length() - 4);
    if (end != &#34;\r\n\r\n&#34;)
        return;
    //超过2048个字符，且不含\r\n\r\n，我们认为是非法请求
    else if (inbuf.length() &gt;= MAX_URL_LENGTH)
    {
        conn-&gt;forceClose();
        return;
    }

    //以\r\n分割每一行
    std::vector&lt;string&gt; lines;
    StringUtil::Split(inbuf, lines, &#34;\r\n&#34;);
    if (lines.size() &lt; 1 || lines[0].empty())
    {
        conn-&gt;forceClose();
        return;
    }

    std::vector&lt;string&gt; chunk;
    StringUtil::Split(lines[0], chunk, &#34; &#34;);
    //chunk中至少有三个字符串：GET+url+HTTP版本号
    if (chunk.size() &lt; 3)
    {
        conn-&gt;forceClose();
        return;
    }

    LOG_INFO &lt;&lt; &#34;url: &#34; &lt;&lt; chunk[1] &lt;&lt; &#34; from &#34; &lt;&lt; conn-&gt;peerAddress().toIpPort();
    //inbuf = /register.do?p={%22username%22:%20%2213917043329%22,%20%22nickname%22:%20%22balloon%22,%20%22password%22:%20%22123%22}
    std::vector&lt;string&gt; part;
    //通过?分割成前后两端，前面是url，后面是参数
    StringUtil::Split(chunk[1], part, &#34;?&#34;);
    //chunk中至少有三个字符串：GET+url+HTTP版本号
    if (part.size() &lt; 2)
    {
        conn-&gt;forceClose();
        return;
    }

    string url = part[0];
    string param = part[1].substr(2);

    if (!Process(conn, url, param))
    {
        LOG_ERROR &lt;&lt; &#34;handle http request error, from:&#34; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &#34;, request: &#34; &lt;&lt; pBuffer-&gt;retrieveAllAsString();
    }

    //短连接，处理完关闭连接
    conn-&gt;forceClose();
}
</code></pre><p>但这只能解决发送非法数据的情况，如果一个客户端连上来不给我们发任何数据，这段逻辑就无能为力了。如果不断有客户端这么做，会浪费我们大量的连接资源，所以我们还需要一个定时器去定时检测哪些http连接超过一定时间内没给我们发数据，找到后将连接断开。这又涉及到服务器定时器如何设计了，关于这部分请参考我写的其他文章。</p>
<p>限于作者经验水平有限，文中难免有错乱之处，欢迎拍砖。另外，关于上面的代码，可以去github上下载，地址是：</p>
<p><a href="https://github.com/baloonwj/flamingo">https://github.com/baloonwj/flamingo</a></p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/blog/fea618d6d104410cb5df6bc54d9529f2/">
    <span class="title">« Prev</span>
    <br>
    <span>从零学习开源项目系列（四）LogServer源码探究</span>
  </a>
  <a class="next" href="https://haokiu.com/blog/e1e38f7ff0e941c8ad6e51923070551d/">
    <span class="title">Next »</span>
    <br>
    <span>从零实现一个邮件收发客户端</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
