<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>04 服务器端db_proxy_server源码分析 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="04 服务器端db_proxy_server源码分析 从这篇文章开始，我将详细地分析TeamTalk服务器端每一个服务的源码和架构设计。
这篇从db_proxy_server开始。db_proxy_server是TeamTalk服务器端最后端的程序，它连接着关系型数据库mysql和nosql内存数据库redis。其位置在整个服务架构中如图所示：
我们从db_proxy_server的main()函数开始，main()函数其实就是做了以下初始化工作，我整理成如下伪码：
int main() { //1. 初始化redis连接 //2. 初始化mysql连接 //3. 启动任务队列，用于处理任务 //4. 启动从mysql同步数据到redis工作 //5. 在端口10600上启动侦听，监听新连接 //6. 主线程进入循环，监听新连接的到来以及出来新连接上的数据收发 } 下面，我们将一一介绍以上步骤。
一、初始化redis连接 CacheManager* pCacheManager = CacheManager::getInstance(); CacheManager* CacheManager::getInstance() { if (!s_cache_manager) { s_cache_manager = new CacheManager(); if (s_cache_manager-&gt;Init()) { delete s_cache_manager; s_cache_manager = NULL; } } return s_cache_manager; } int CacheManager::Init() { CConfigFileReader config_file(&#34;dbproxyserver.conf&#34;); //CacheInstances=unread,group_set,token,sync,group_member char* cache_instances = config_file.GetConfigName(&#34;CacheInstances&#34;); if (!cache_instances) { log(&#34;not configure CacheIntance&#34;); return 1; } char host[64]; char port[64]; char db[64]; char maxconncnt[64]; CStrExplode instances_name(cache_instances, &#39;,&#39;); for (uint32_t i = 0; i &lt; instances_name.GetItemCnt(); i&#43;&#43;) { char* pool_name = instances_name.GetItem(i); //printf(&#34;%s&#34;, pool_name); snprintf(host, 64, &#34;%s_host&#34;, pool_name); snprintf(port, 64, &#34;%s_port&#34;, pool_name); snprintf(db, 64, &#34;%s_db&#34;, pool_name); snprintf(maxconncnt, 64, &#34;%s_maxconncnt&#34;, pool_name); char* cache_host = config_file.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/blog/5481b95ce7c64f8c99c98e3c59d74314/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="04 服务器端db_proxy_server源码分析" />
<meta property="og:description" content="04 服务器端db_proxy_server源码分析 从这篇文章开始，我将详细地分析TeamTalk服务器端每一个服务的源码和架构设计。
这篇从db_proxy_server开始。db_proxy_server是TeamTalk服务器端最后端的程序，它连接着关系型数据库mysql和nosql内存数据库redis。其位置在整个服务架构中如图所示：
我们从db_proxy_server的main()函数开始，main()函数其实就是做了以下初始化工作，我整理成如下伪码：
int main() { //1. 初始化redis连接 //2. 初始化mysql连接 //3. 启动任务队列，用于处理任务 //4. 启动从mysql同步数据到redis工作 //5. 在端口10600上启动侦听，监听新连接 //6. 主线程进入循环，监听新连接的到来以及出来新连接上的数据收发 } 下面，我们将一一介绍以上步骤。
一、初始化redis连接 CacheManager* pCacheManager = CacheManager::getInstance(); CacheManager* CacheManager::getInstance() { if (!s_cache_manager) { s_cache_manager = new CacheManager(); if (s_cache_manager-&gt;Init()) { delete s_cache_manager; s_cache_manager = NULL; } } return s_cache_manager; } int CacheManager::Init() { CConfigFileReader config_file(&#34;dbproxyserver.conf&#34;); //CacheInstances=unread,group_set,token,sync,group_member char* cache_instances = config_file.GetConfigName(&#34;CacheInstances&#34;); if (!cache_instances) { log(&#34;not configure CacheIntance&#34;); return 1; } char host[64]; char port[64]; char db[64]; char maxconncnt[64]; CStrExplode instances_name(cache_instances, &#39;,&#39;); for (uint32_t i = 0; i &lt; instances_name.GetItemCnt(); i&#43;&#43;) { char* pool_name = instances_name.GetItem(i); //printf(&#34;%s&#34;, pool_name); snprintf(host, 64, &#34;%s_host&#34;, pool_name); snprintf(port, 64, &#34;%s_port&#34;, pool_name); snprintf(db, 64, &#34;%s_db&#34;, pool_name); snprintf(maxconncnt, 64, &#34;%s_maxconncnt&#34;, pool_name); char* cache_host = config_file." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/blog/5481b95ce7c64f8c99c98e3c59d74314/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="04 服务器端db_proxy_server源码分析"/>
<meta name="twitter:description" content="04 服务器端db_proxy_server源码分析 从这篇文章开始，我将详细地分析TeamTalk服务器端每一个服务的源码和架构设计。
这篇从db_proxy_server开始。db_proxy_server是TeamTalk服务器端最后端的程序，它连接着关系型数据库mysql和nosql内存数据库redis。其位置在整个服务架构中如图所示：
我们从db_proxy_server的main()函数开始，main()函数其实就是做了以下初始化工作，我整理成如下伪码：
int main() { //1. 初始化redis连接 //2. 初始化mysql连接 //3. 启动任务队列，用于处理任务 //4. 启动从mysql同步数据到redis工作 //5. 在端口10600上启动侦听，监听新连接 //6. 主线程进入循环，监听新连接的到来以及出来新连接上的数据收发 } 下面，我们将一一介绍以上步骤。
一、初始化redis连接 CacheManager* pCacheManager = CacheManager::getInstance(); CacheManager* CacheManager::getInstance() { if (!s_cache_manager) { s_cache_manager = new CacheManager(); if (s_cache_manager-&gt;Init()) { delete s_cache_manager; s_cache_manager = NULL; } } return s_cache_manager; } int CacheManager::Init() { CConfigFileReader config_file(&#34;dbproxyserver.conf&#34;); //CacheInstances=unread,group_set,token,sync,group_member char* cache_instances = config_file.GetConfigName(&#34;CacheInstances&#34;); if (!cache_instances) { log(&#34;not configure CacheIntance&#34;); return 1; } char host[64]; char port[64]; char db[64]; char maxconncnt[64]; CStrExplode instances_name(cache_instances, &#39;,&#39;); for (uint32_t i = 0; i &lt; instances_name.GetItemCnt(); i&#43;&#43;) { char* pool_name = instances_name.GetItem(i); //printf(&#34;%s&#34;, pool_name); snprintf(host, 64, &#34;%s_host&#34;, pool_name); snprintf(port, 64, &#34;%s_port&#34;, pool_name); snprintf(db, 64, &#34;%s_db&#34;, pool_name); snprintf(maxconncnt, 64, &#34;%s_maxconncnt&#34;, pool_name); char* cache_host = config_file."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "04 服务器端db_proxy_server源码分析",
      "item": "https://haokiu.com/blog/5481b95ce7c64f8c99c98e3c59d74314/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "04 服务器端db_proxy_server源码分析",
  "name": "04 服务器端db_proxy_server源码分析",
  "description": "04 服务器端db_proxy_server源码分析 从这篇文章开始，我将详细地分析TeamTalk服务器端每一个服务的源码和架构设计。\n这篇从db_proxy_server开始。db_proxy_server是TeamTalk服务器端最后端的程序，它连接着关系型数据库mysql和nosql内存数据库redis。其位置在整个服务架构中如图所示：\n我们从db_proxy_server的main()函数开始，main()函数其实就是做了以下初始化工作，我整理成如下伪码：\nint main() { //1. 初始化redis连接 //2. 初始化mysql连接 //3. 启动任务队列，用于处理任务 //4. 启动从mysql同步数据到redis工作 //5. 在端口10600上启动侦听，监听新连接 //6. 主线程进入循环，监听新连接的到来以及出来新连接上的数据收发 } 下面，我们将一一介绍以上步骤。\n一、初始化redis连接 CacheManager* pCacheManager = CacheManager::getInstance(); CacheManager* CacheManager::getInstance() { if (!s_cache_manager) { s_cache_manager = new CacheManager(); if (s_cache_manager-\u0026gt;Init()) { delete s_cache_manager; s_cache_manager = NULL; } } return s_cache_manager; } int CacheManager::Init() { CConfigFileReader config_file(\u0026#34;dbproxyserver.conf\u0026#34;); //CacheInstances=unread,group_set,token,sync,group_member char* cache_instances = config_file.GetConfigName(\u0026#34;CacheInstances\u0026#34;); if (!cache_instances) { log(\u0026#34;not configure CacheIntance\u0026#34;); return 1; } char host[64]; char port[64]; char db[64]; char maxconncnt[64]; CStrExplode instances_name(cache_instances, \u0026#39;,\u0026#39;); for (uint32_t i = 0; i \u0026lt; instances_name.GetItemCnt(); i++) { char* pool_name = instances_name.GetItem(i); //printf(\u0026#34;%s\u0026#34;, pool_name); snprintf(host, 64, \u0026#34;%s_host\u0026#34;, pool_name); snprintf(port, 64, \u0026#34;%s_port\u0026#34;, pool_name); snprintf(db, 64, \u0026#34;%s_db\u0026#34;, pool_name); snprintf(maxconncnt, 64, \u0026#34;%s_maxconncnt\u0026#34;, pool_name); char* cache_host = config_file.",
  "keywords": [
    
  ],
  "articleBody": "04 服务器端db_proxy_server源码分析 从这篇文章开始，我将详细地分析TeamTalk服务器端每一个服务的源码和架构设计。\n这篇从db_proxy_server开始。db_proxy_server是TeamTalk服务器端最后端的程序，它连接着关系型数据库mysql和nosql内存数据库redis。其位置在整个服务架构中如图所示：\n我们从db_proxy_server的main()函数开始，main()函数其实就是做了以下初始化工作，我整理成如下伪码：\nint main() { //1. 初始化redis连接 //2. 初始化mysql连接 //3. 启动任务队列，用于处理任务 //4. 启动从mysql同步数据到redis工作 //5. 在端口10600上启动侦听，监听新连接 //6. 主线程进入循环，监听新连接的到来以及出来新连接上的数据收发 } 下面，我们将一一介绍以上步骤。\n一、初始化redis连接 CacheManager* pCacheManager = CacheManager::getInstance(); CacheManager* CacheManager::getInstance() { if (!s_cache_manager) { s_cache_manager = new CacheManager(); if (s_cache_manager-\u003eInit()) { delete s_cache_manager; s_cache_manager = NULL; } } return s_cache_manager; } int CacheManager::Init() { CConfigFileReader config_file(\"dbproxyserver.conf\"); //CacheInstances=unread,group_set,token,sync,group_member char* cache_instances = config_file.GetConfigName(\"CacheInstances\"); if (!cache_instances) { log(\"not configure CacheIntance\"); return 1; } char host[64]; char port[64]; char db[64]; char maxconncnt[64]; CStrExplode instances_name(cache_instances, ','); for (uint32_t i = 0; i \u003c instances_name.GetItemCnt(); i++) { char* pool_name = instances_name.GetItem(i); //printf(\"%s\", pool_name); snprintf(host, 64, \"%s_host\", pool_name); snprintf(port, 64, \"%s_port\", pool_name); snprintf(db, 64, \"%s_db\", pool_name); snprintf(maxconncnt, 64, \"%s_maxconncnt\", pool_name); char* cache_host = config_file.GetConfigName(host); char* str_cache_port = config_file.GetConfigName(port); char* str_cache_db = config_file.GetConfigName(db); char* str_max_conn_cnt = config_file.GetConfigName(maxconncnt); if (!cache_host || !str_cache_port || !str_cache_db || !str_max_conn_cnt) { log(\"not configure cache instance: %s\", pool_name); return 2; } CachePool* pCachePool = new CachePool(pool_name, cache_host, atoi(str_cache_port), atoi(str_cache_db), atoi(str_max_conn_cnt)); if (pCachePool-\u003eInit()) { log(\"Init cache pool failed\"); return 3; } m_cache_pool_map.insert(make_pair(pool_name, pCachePool)); } return 0; } 在pCachePool-\u003eInit()中是实际连接redis的动作：\nint CachePool::Init() { for (int i = 0; i \u003c m_cur_conn_cnt; i++) { CacheConn* pConn = new CacheConn(this); if (pConn-\u003eInit()) { delete pConn; return 1; } m_free_list.push_back(pConn); } log(\"cache pool: %s, list size: %lu\", m_pool_name.c_str(), m_free_list.size()); return 0; } pConn-\u003eInit()调用如下：\nint CacheConn::Init() { if (m_pContext) { return 0; } // 4s 尝试重连一次 uint64_t cur_time = (uint64_t)time(NULL); if (cur_time \u003c m_last_connect_time + 4) { return 1; } m_last_connect_time = cur_time; // 200ms超时 struct timeval timeout = {0, 200000}; m_pContext = redisConnectWithTimeout(m_pCachePool-\u003eGetServerIP(), m_pCachePool-\u003eGetServerPort(), timeout); if (!m_pContext || m_pContext-\u003eerr) { if (m_pContext) { log(\"redisConnect failed: %s\", m_pContext-\u003eerrstr); redisFree(m_pContext); m_pContext = NULL; } else { log(\"redisConnect failed\"); } return 1; } redisReply* reply = (redisReply *)redisCommand(m_pContext, \"SELECT %d\", m_pCachePool-\u003eGetDBNum()); if (reply \u0026\u0026 (reply-\u003etype == REDIS_REPLY_STATUS) \u0026\u0026 (strncmp(reply-\u003estr, \"OK\", 2) == 0)) { freeReplyObject(reply); return 0; } else { log(\"select cache db failed\"); return 2; } } 层级关系是这样的： CacheManager的成员变量m_cache_pool_map存储了配置文件配置的redis缓存池，这是一个map对象，key是缓存池的名字，value是缓存池CachePool对象的指针。\nmap\u003cstring, CachePool*\u003e\tm_cache_pool_map; dbproxyserver.conf目前配置了如下几个redis缓存池：\nCacheInstances=unread,group_set,token,sync,group_member 每一个缓存池对象CachePool的成员变量m_free_list中存储着若干个与redis的连接对象，具体是多少个，根据配置文件来配置。m_free_list定义：\nlist\u003cCacheConn*\u003e\tm_free_list; 这些与redis连接对象后面会介绍在何处使用。\n二、初始化mysql连接 CDBManager* pDBManager = CDBManager::getInstance(); CDBManager* CDBManager::getInstance() { if (!s_db_manager) { s_db_manager = new CDBManager(); if (s_db_manager-\u003eInit()) { delete s_db_manager; s_db_manager = NULL; } } return s_db_manager; } int CDBManager::Init() { CConfigFileReader config_file(\"dbproxyserver.conf\"); //DBInstances=teamtalk_master,teamtalk_slave char* db_instances = config_file.GetConfigName(\"DBInstances\"); if (!db_instances) { log(\"not configure DBInstances\"); return 1; } char host[64]; char port[64]; char dbname[64]; char username[64]; char password[64]; char maxconncnt[64]; CStrExplode instances_name(db_instances, ','); for (uint32_t i = 0; i \u003c instances_name.GetItemCnt(); i++) { char* pool_name = instances_name.GetItem(i); snprintf(host, 64, \"%s_host\", pool_name); snprintf(port, 64, \"%s_port\", pool_name); snprintf(dbname, 64, \"%s_dbname\", pool_name); snprintf(username, 64, \"%s_username\", pool_name); snprintf(password, 64, \"%s_password\", pool_name); snprintf(maxconncnt, 64, \"%s_maxconncnt\", pool_name); char* db_host = config_file.GetConfigName(host); char* str_db_port = config_file.GetConfigName(port); char* db_dbname = config_file.GetConfigName(dbname); char* db_username = config_file.GetConfigName(username); char* db_password = config_file.GetConfigName(password); char* str_maxconncnt = config_file.GetConfigName(maxconncnt); if (!db_host || !str_db_port || !db_dbname || !db_username || !db_password || !str_maxconncnt) { log(\"not configure db instance: %s\", pool_name); return 2; } int db_port = atoi(str_db_port); int db_maxconncnt = atoi(str_maxconncnt); CDBPool* pDBPool = new CDBPool(pool_name, db_host, db_port, db_username, db_password, db_dbname, db_maxconncnt); if (pDBPool-\u003eInit()) { log(\"init db instance failed: %s\", pool_name); return 3; } m_dbpool_map.insert(make_pair(pool_name, pDBPool)); } return 0; } 同理pDBPool-\u003eInit()中是实际连接mysql代码：\nint CDBPool::Init() { for (int i = 0; i \u003c m_db_cur_conn_cnt; i++) { CDBConn* pDBConn = new CDBConn(this); int ret = pDBConn-\u003eInit(); if (ret) { delete pDBConn; return ret; } m_free_list.push_back(pDBConn); } log(\"db pool: %s, size: %d\", m_pool_name.c_str(), (int)m_free_list.size()); return 0; } int CDBConn::Init() { m_mysql = mysql_init(NULL); if (!m_mysql) { log(\"mysql_init failed\"); return 1; } my_bool reconnect = true; mysql_options(m_mysql, MYSQL_OPT_RECONNECT, \u0026reconnect); mysql_options(m_mysql, MYSQL_SET_CHARSET_NAME, \"utf8mb4\"); if (!mysql_real_connect(m_mysql, m_pDBPool-\u003eGetDBServerIP(), m_pDBPool-\u003eGetUsername(), \"\"/*m_pDBPool-\u003eGetPasswrod()*/, m_pDBPool-\u003eGetDBName(), m_pDBPool-\u003eGetDBServerPort(), NULL, 0)) { log(\"mysql_real_connect failed: %s\", mysql_error(m_mysql)); return 2; } return 0; } 与redis连接对象类似，CDBManager的成员对象m_dbpool_map存储了mysql连接池，这也是一个stl map，key是池子的名字，value是连接池的对象CDBPool指针。配置文件中总共配置了名称为主从两个mysql连接池。\nDBInstances=teamtalk_master,teamtalk_slave 连接池对象CDBPool用一个成员变量存储自己的若干个mysql连接：\nlist\u003cCDBConn*\u003e\tm_free_list; //实际保存mysql连接的容器 具体每个连接池有多少个mysql连接，根据配置文件得到，这里主从两个库都是16个。\n这些mysql连接的用途后面介绍。\n三、启动任务队列，用于处理任务 初始化一：创建线程处理任务队列中的任务\ninit_proxy_conn(thread_num); int init_proxy_conn(uint32_t thread_num) { s_handler_map = CHandlerMap::getInstance(); g_thread_pool.Init(thread_num); netlib_add_loop(proxy_loop_callback, NULL); signal(SIGTERM, sig_handler); return netlib_register_timer(proxy_timer_callback, NULL, 1000); } 线程数量根据配置文件得到。g_thread_pool.Init(thread_num)中实际创建处理任务的线程。\nint CThreadPool::Init(uint32_t worker_size) { m_worker_size = worker_size; m_worker_list = new CWorkerThread [m_worker_size]; if (!m_worker_list) { return 1; } for (uint32_t i = 0; i \u003c m_worker_size; i++) { m_worker_list[i].SetThreadIdx(i); m_worker_list[i].Start(); } return 0; } void CWorkerThread::Start() { (void)pthread_create(\u0026m_thread_id, NULL, StartRoutine, this); } 线程函数调用序列如下：\nvoid* CWorkerThread::StartRoutine(void* arg) { CWorkerThread* pThread = (CWorkerThread*)arg; pThread-\u003eExecute(); return NULL; } void CWorkerThread::Execute() { while (true) { m_thread_notify.Lock(); // put wait in while cause there can be spurious wake up (due to signal/ENITR) while (m_task_list.empty()) { m_thread_notify.Wait(); } CTask* pTask = m_task_list.front(); m_task_list.pop_front(); m_thread_notify.Unlock(); pTask-\u003erun(); delete pTask; m_task_cnt++; //log(\"%d have the execute %d task\\n\", m_thread_idx, m_task_cnt); } } 可以看到工作线程一直在等待一个条件变量，当向任务队列中添加任务时，条件变量被唤醒：\nvoid CWorkerThread::PushTask(CTask* pTask) { m_thread_notify.Lock(); m_task_list.push_back(pTask); m_thread_notify.Signal(); m_thread_notify.Unlock(); } 任务队列的用途，下文会介绍。\n初始化二：将各个任务id与对应的处理函数绑定起来：\ns_handler_map = CHandlerMap::getInstance(); CHandlerMap* CHandlerMap::getInstance() { if (!s_handler_instance) { s_handler_instance = new CHandlerMap(); s_handler_instance-\u003eInit(); } return s_handler_instance; } void CHandlerMap::Init() { //DB_PROXY是命名空间，不是类名 // Login validate m_handler_map.insert(make_pair(uint32_t(CID_OTHER_VALIDATE_REQ), DB_PROXY::doLogin)); m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_PUSH_SHIELD), DB_PROXY::doPushShield)); m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_QUERY_PUSH_SHIELD), DB_PROXY::doQueryPushShield)); // recent session m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST), DB_PROXY::getRecentSession)); m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_REMOVE_SESSION_REQ), DB_PROXY::deleteRecentSession)); // users m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_USER_INFO_REQUEST), DB_PROXY::getUserInfo)); m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_ALL_USER_REQUEST), DB_PROXY::getChangedUser)); m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_DEPARTMENT_REQUEST), DB_PROXY::getChgedDepart)); m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST), DB_PROXY::changeUserSignInfo)); // message content m_handler_map.insert(make_pair(uint32_t(CID_MSG_DATA), DB_PROXY::sendMessage)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_LIST_REQUEST), DB_PROXY::getMessage)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_UNREAD_CNT_REQUEST), DB_PROXY::getUnreadMsgCounter)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_READ_ACK), DB_PROXY::clearUnreadMsgCounter)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_BY_MSG_ID_REQ), DB_PROXY::getMessageById)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_LATEST_MSG_ID_REQ), DB_PROXY::getLatestMsgId)); // device token m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_DEVICETOKEN), DB_PROXY::setDevicesToken)); m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_DEVICE_TOKEN_REQ), DB_PROXY::getDevicesToken)); //push 推送设置 m_handler_map.insert(make_pair(uint32_t(CID_GROUP_SHIELD_GROUP_REQUEST), DB_PROXY::setGroupPush)); m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_SHIELD_REQ), DB_PROXY::getGroupPush)); // group m_handler_map.insert(make_pair(uint32_t(CID_GROUP_NORMAL_LIST_REQUEST), DB_PROXY::getNormalGroupList)); m_handler_map.insert(make_pair(uint32_t(CID_GROUP_INFO_REQUEST), DB_PROXY::getGroupInfo)); m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CREATE_REQUEST), DB_PROXY::createGroup)); m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CHANGE_MEMBER_REQUEST), DB_PROXY::modifyMember)); // file m_handler_map.insert(make_pair(uint32_t(CID_FILE_HAS_OFFLINE_REQ), DB_PROXY::hasOfflineFile)); m_handler_map.insert(make_pair(uint32_t(CID_FILE_ADD_OFFLINE_REQ), DB_PROXY::addOfflineFile)); m_handler_map.insert(make_pair(uint32_t(CID_FILE_DEL_OFFLINE_REQ), DB_PROXY::delOfflineFile)); }\tm_handler_map.insert(make_pair(uint32_t(CID_OTHER_VALIDATE_REQ), DB_PROXY::doLogin)); m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_PUSH_SHIELD), DB_PROXY::doPushShield)); m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_QUERY_PUSH_SHIELD), DB_PROXY::doQueryPushShield)); // recent session m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST), DB_PROXY::getRecentSession)); m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_REMOVE_SESSION_REQ), DB_PROXY::deleteRecentSession)); // users m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_USER_INFO_REQUEST), DB_PROXY::getUserInfo)); m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_ALL_USER_REQUEST), DB_PROXY::getChangedUser)); m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_DEPARTMENT_REQUEST), DB_PROXY::getChgedDepart)); m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST), DB_PROXY::changeUserSignInfo)); // message content m_handler_map.insert(make_pair(uint32_t(CID_MSG_DATA), DB_PROXY::sendMessage)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_LIST_REQUEST), DB_PROXY::getMessage)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_UNREAD_CNT_REQUEST), DB_PROXY::getUnreadMsgCounter)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_READ_ACK), DB_PROXY::clearUnreadMsgCounter)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_BY_MSG_ID_REQ), DB_PROXY::getMessageById)); m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_LATEST_MSG_ID_REQ), DB_PROXY::getLatestMsgId)); // device token m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_DEVICETOKEN), DB_PROXY::setDevicesToken)); m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_DEVICE_TOKEN_REQ), DB_PROXY::getDevicesToken)); //push 推送设置 m_handler_map.insert(make_pair(uint32_t(CID_GROUP_SHIELD_GROUP_REQUEST), DB_PROXY::setGroupPush)); m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_SHIELD_REQ), DB_PROXY::getGroupPush)); // group m_handler_map.insert(make_pair(uint32_t(CID_GROUP_NORMAL_LIST_REQUEST), DB_PROXY::getNormalGroupList)); m_handler_map.insert(make_pair(uint32_t(CID_GROUP_INFO_REQUEST), DB_PROXY::getGroupInfo)); m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CREATE_REQUEST), DB_PROXY::createGroup)); m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CHANGE_MEMBER_REQUEST), DB_PROXY::modifyMember)); // file m_handler_map.insert(make_pair(uint32_t(CID_FILE_HAS_OFFLINE_REQ), DB_PROXY::hasOfflineFile)); m_handler_map.insert(make_pair(uint32_t(CID_FILE_ADD_OFFLINE_REQ), DB_PROXY::addOfflineFile)); m_handler_map.insert(make_pair(uint32_t(CID_FILE_DEL_OFFLINE_REQ), DB_PROXY::delOfflineFile)); } 四、启动从mysql同步数据到redis工作 CSyncCenter::getInstance()-\u003einit(); CSyncCenter::getInstance()-\u003estartSync(); CSyncCenter::getInstance()-\u003einit()是获得上次同步的数据位置，接下来同步从这个位置开始。\n/* * 初始化函数，从cache里面加载上次同步的时间信息等 */ void CSyncCenter::init() { // Load total update time CacheManager* pCacheManager = CacheManager::getInstance(); // increase message count CacheConn* pCacheConn = pCacheManager-\u003eGetCacheConn(\"unread\"); if (pCacheConn) { string strTotalUpdate = pCacheConn-\u003eget(\"total_user_updated\"); string strLastUpdateGroup = pCacheConn-\u003eget(\"last_update_group\"); pCacheManager-\u003eRelCacheConn(pCacheConn); if(strTotalUpdate != \"\") { m_nLastUpdate = string2int(strTotalUpdate); } else { updateTotalUpdate(time(NULL)); } if(strLastUpdateGroup.empty()) { m_nLastUpdateGroup = string2int(strLastUpdateGroup); } else { updateLastUpdateGroup(time(NULL)); } } else { log(\"no cache connection to get total_user_updated\"); } } CSyncCenter::getInstance()-\u003estartSync();新开启一个线程进行同步工作：\n/** * 开启内网数据同步以及群组聊天记录同步 */ void CSyncCenter::startSync() { #ifdef _WIN32 (void)CreateThread(NULL, 0, doSyncGroupChat, NULL, 0, \u0026m_nGroupChatThreadId); #else (void)pthread_create(\u0026m_nGroupChatThreadId, NULL, doSyncGroupChat, NULL); #endif } 线程函数doSyncGroupChat()如下：\n/** * 同步群组聊天信息 * * @param arg NULL * * @return NULL */ void* CSyncCenter::doSyncGroupChat(void* arg) { m_bSyncGroupChatRuning = true; CDBManager* pDBManager = CDBManager::getInstance(); map\u003cuint32_t, uint32_t\u003e mapChangedGroup; do{ mapChangedGroup.clear(); CDBConn* pDBConn = pDBManager-\u003eGetDBConn(\"teamtalk_slave\"); if(pDBConn) { string strSql = \"select id, lastChated from IMGroup where status=0 and lastChated \u003e=\" + int2string(m_pInstance-\u003egetLastUpdateGroup()); CResultSet* pResult = pDBConn-\u003eExecuteQuery(strSql.c_str()); if(pResult) { while (pResult-\u003eNext()) { uint32_t nGroupId = pResult-\u003eGetInt(\"id\"); uint32_t nLastChat = pResult-\u003eGetInt(\"lastChated\"); if(nLastChat != 0) { mapChangedGroup[nGroupId] = nLastChat; } } delete pResult; } pDBManager-\u003eRelDBConn(pDBConn); } else { log(\"no db connection for teamtalk_slave\"); } m_pInstance-\u003eupdateLastUpdateGroup(time(NULL)); for (auto it=mapChangedGroup.begin(); it!=mapChangedGroup.end(); ++it) { uint32_t nGroupId =it-\u003efirst; list\u003cuint32_t\u003e lsUsers; uint32_t nUpdate = it-\u003esecond; CGroupModel::getInstance()-\u003egetGroupUser(nGroupId, lsUsers); for (auto it1=lsUsers.begin(); it1!=lsUsers.end(); ++it1) { uint32_t nUserId = *it1; uint32_t nSessionId = INVALID_VALUE; nSessionId = CSessionModel::getInstance()-\u003egetSessionId(nUserId, nGroupId, IM::BaseDefine::SESSION_TYPE_GROUP, true); if(nSessionId != INVALID_VALUE) { CSessionModel::getInstance()-\u003eupdateSession(nSessionId, nUpdate); } else { CSessionModel::getInstance()-\u003eaddSession(nUserId, nGroupId, IM::BaseDefine::SESSION_TYPE_GROUP); } } } // } while (!m_pInstance-\u003em_pCondSync-\u003ewaitTime(5*1000)); } while (m_pInstance-\u003em_bSyncGroupChatWaitting \u0026\u0026 !(m_pInstance-\u003em_pCondGroupChat-\u003ewaitTime(5*1000))); // } while(m_pInstance-\u003em_bSyncGroupChatWaitting); m_bSyncGroupChatRuning = false; return NULL; } 可以看到流程就是先用sql从mysql取出数据，再用“sql”写到redis中去。操作mysql和redis时，并没有新建新连接，而是使用上文介绍的连接池和缓存池中已有的连接。我们上文说了，每个池中都有若干个连接，那使用哪个连接呢？由于保存mysql的连接是一个list对象，所以默认从list的头部取一个可用的。如果当前没有空闲连接可用，则新建一个：\nCDBConn* CDBPool::GetDBConn() { m_free_notify.Lock(); while (m_free_list.empty()) { if (m_db_cur_conn_cnt \u003e= m_db_max_conn_cnt) { m_free_notify.Wait(); } else { CDBConn* pDBConn = new CDBConn(this); int ret = pDBConn-\u003eInit(); if (ret) { log(\"Init DBConnecton failed\"); delete pDBConn; m_free_notify.Unlock(); return NULL; } else { m_free_list.push_back(pDBConn); m_db_cur_conn_cnt++; log(\"new db connection: %s, conn_cnt: %d\", m_pool_name.c_str(), m_db_cur_conn_cnt); } } } CDBConn* pConn = m_free_list.front(); m_free_list.pop_front(); m_free_notify.Unlock(); return pConn; } 分配redis和mysql的一模一样，这里代码就不贴了。\n五、在端口10600上启动侦听，监听新连接 CStrExplode listen_ip_list(listen_ip, ';'); for (uint32_t i = 0; i \u003c listen_ip_list.GetItemCnt(); i++) { ret = netlib_listen(listen_ip_list.GetItem(i), listen_port, proxy_serv_callback, NULL); if (ret == NETLIB_ERROR) return ret; } netlib_listen()创建CBaseSocket对象，并将回调函数指针proxy_serv_callback保存在CBaseSocket对象中。\nint netlib_listen( const char*\tserver_ip, uint16_t\tport, callback_t\tcallback, void*\tcallback_data) { CBaseSocket* pSocket = new CBaseSocket(); if (!pSocket) return NETLIB_ERROR; int ret = pSocket-\u003eListen(server_ip, port, callback, callback_data); if (ret == NETLIB_ERROR) delete pSocket; return ret; } pSocket-\u003eListen()是实际调用bind()和listen()函数创建侦听的地方。\nint CBaseSocket::Listen(const char* server_ip, uint16_t port, callback_t callback, void* callback_data) { m_local_ip = server_ip; m_local_port = port; m_callback = callback; m_callback_data = callback_data; m_socket = socket(AF_INET, SOCK_STREAM, 0); if (m_socket == INVALID_SOCKET) { printf(\"socket failed, err_code=%d\\n\", _GetErrorCode()); return NETLIB_ERROR; } _SetReuseAddr(m_socket); _SetNonblock(m_socket); sockaddr_in serv_addr; _SetAddr(server_ip, port, \u0026serv_addr); int ret = ::bind(m_socket, (sockaddr*)\u0026serv_addr, sizeof(serv_addr)); if (ret == SOCKET_ERROR) { log(\"bind failed, err_code=%d\", _GetErrorCode()); closesocket(m_socket); return NETLIB_ERROR; } ret = listen(m_socket, 64); if (ret == SOCKET_ERROR) { log(\"listen failed, err_code=%d\", _GetErrorCode()); closesocket(m_socket); return NETLIB_ERROR; } m_state = SOCKET_STATE_LISTENING; log(\"CBaseSocket::Listen on %s:%d\", server_ip, port); AddBaseSocket(this); CEventDispatch::Instance()-\u003eAddEvent(m_socket, SOCKET_READ | SOCKET_EXCEP); return NETLIB_OK; } 这个函数有大量的细节需要注意：\nsocket被设置成非阻塞模式；\n将绑定的地址设置成reuse（具体原因，我在《服务器编程心得》系列已经介绍过）\n将socket的状态设置成SOCKET_STATE_LISTENING，这个状态将侦听的socket与普通客户端连接的socket区别开来。\nAddBaseSocket(this);将socket句柄和对应的CBaseSocket放到一个全局对象中管理起来。\ntypedef hash_map\u003cnet_handle_t, CBaseSocket*\u003e SocketMap; SocketMap\tg_socket_map; void AddBaseSocket(CBaseSocket* pSocket) { g_socket_map.insert(make_pair((net_handle_t)pSocket-\u003eGetSocket(), pSocket)); } 之所以不用map而用hash_map是因为STL的map底层是用红黑树实现的，查找时间复杂度是log(n)，而hash_map底层是用hash表存储的，查询时间复杂度是O(1)。后面会介绍将在这个hash_map中查找所有的socket。\n目前只关注socket的读和异常事件，侦听socket可读意味着有新连接到来，异常就意味着侦听出错。对于服务器程序一般要关闭或重启服务。 六、主线程进入循环，监听新连接的到来以及出来新连接上的数据收发 netlib_eventloop(10) 10是超时时间，用于select()函数的调用：\nvoid netlib_eventloop(uint32_t wait_timeout) { CEventDispatch::Instance()-\u003eStartDispatch(wait_timeout); } void CEventDispatch::StartDispatch(uint32_t wait_timeout) { fd_set read_set, write_set, excep_set; timeval timeout; timeout.tv_sec = 0; timeout.tv_usec = wait_timeout * 1000;\t// 10 millisecond if(running) return; running = true; while (running) { _CheckTimer(); _CheckLoop(); if (!m_read_set.fd_count \u0026\u0026 !m_write_set.fd_count \u0026\u0026 !m_excep_set.fd_count) { Sleep(MIN_TIMER_DURATION); continue; } m_lock.lock(); memcpy(\u0026read_set, \u0026m_read_set, sizeof(fd_set)); memcpy(\u0026write_set, \u0026m_write_set, sizeof(fd_set)); memcpy(\u0026excep_set, \u0026m_excep_set, sizeof(fd_set)); m_lock.unlock(); int nfds = select(0, \u0026read_set, \u0026write_set, \u0026excep_set, \u0026timeout); if (nfds == SOCKET_ERROR) { log(\"select failed, error code: %d\", GetLastError()); Sleep(MIN_TIMER_DURATION); continue;\t// select again } if (nfds == 0) { continue; } for (u_int i = 0; i \u003c read_set.fd_count; i++) { //log(\"select return read count=%d\\n\", read_set.fd_count); SOCKET fd = read_set.fd_array[i]; CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd); if (pSocket) { pSocket-\u003eOnRead(); pSocket-\u003eReleaseRef(); } } for (u_int i = 0; i \u003c write_set.fd_count; i++) { //log(\"select return write count=%d\\n\", write_set.fd_count); SOCKET fd = write_set.fd_array[i]; CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd); if (pSocket) { pSocket-\u003eOnWrite(); pSocket-\u003eReleaseRef(); } } for (u_int i = 0; i \u003c excep_set.fd_count; i++) { //log(\"select return exception count=%d\\n\", excep_set.fd_count); SOCKET fd = excep_set.fd_array[i]; CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd); if (pSocket) { pSocket-\u003eOnClose(); pSocket-\u003eReleaseRef(); } } } } 这个函数是整个服务程序的动力和消息泵。我把它简化成如下伪码来重点介绍一下：\nwhile(退出条件) { //1. 遍历定时器队列，检测是否有定时器事件到期，有则执行定时器的回调函数 //2. 遍历其他任务队列，检测是否有其他任务需要执行，有，执行之 //3. 检测socket集合，分离可读、可写和异常事件 //4. 处理socket可读事件 //5. 处理socket可写事件 //6. 处理socket异常事件 } 我们先不说1、2两点，当程序初始化后，socket集合中，也只有一个socket，就是上文中说的侦听socket。当有新连接来的时候，该socket被检测到可读。执行\nfor (u_int i = 0; i \u003c read_set.fd_count; i++) { //log(\"select return read count=%d\\n\", read_set.fd_count); SOCKET fd = read_set.fd_array[i]; CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd); if (pSocket) { pSocket-\u003eOnRead(); pSocket-\u003eReleaseRef(); } }\t//log(\"select return read count=%d\\n\", read_set.fd_count); SOCKET fd = read_set.fd_array[i]; CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd); if (pSocket) { pSocket-\u003eOnRead(); pSocket-\u003eReleaseRef(); } } FindBaseSocket()就是在上文提到的socket集合map中通过句柄查找socket：\nCBaseSocket* FindBaseSocket(net_handle_t fd) { CBaseSocket* pSocket = NULL; SocketMap::iterator iter = g_socket_map.find(fd); if (iter != g_socket_map.end()) { pSocket = iter-\u003esecond; pSocket-\u003eAddRef(); } return pSocket; } 接着执行pSocket-\u003eOnRead():\nvoid CBaseSocket::OnRead() { if (m_state == SOCKET_STATE_LISTENING) { _AcceptNewSocket(); } else { u_long avail = 0; if ( (ioctlsocket(m_socket, FIONREAD, \u0026avail) == SOCKET_ERROR) || (avail == 0) ) { m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } else { m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL); } } } 因为是侦听socket，其状态被设置成SOCKET_STATE_LISTENING(上文介绍了)。接着就接受新连接。\nvoid CBaseSocket::_AcceptNewSocket() { SOCKET fd = 0; sockaddr_in peer_addr; socklen_t addr_len = sizeof(sockaddr_in); char ip_str[64]; while ( (fd = accept(m_socket, (sockaddr*)\u0026peer_addr, \u0026addr_len)) != INVALID_SOCKET ) { CBaseSocket* pSocket = new CBaseSocket(); uint32_t ip = ntohl(peer_addr.sin_addr.s_addr); uint16_t port = ntohs(peer_addr.sin_port); snprintf(ip_str, sizeof(ip_str), \"%d.%d.%d.%d\", ip \u003e\u003e 24, (ip \u003e\u003e 16) \u0026 0xFF, (ip \u003e\u003e 8) \u0026 0xFF, ip \u0026 0xFF); log(\"AcceptNewSocket, socket=%d from %s:%d\\n\", fd, ip_str, port); pSocket-\u003eSetSocket(fd); pSocket-\u003eSetCallback(m_callback); pSocket-\u003eSetCallbackData(m_callback_data); pSocket-\u003eSetState(SOCKET_STATE_CONNECTED); pSocket-\u003eSetRemoteIP(ip_str); pSocket-\u003eSetRemotePort(port); _SetNoDelay(fd); _SetNonblock(fd); AddBaseSocket(pSocket); CEventDispatch::Instance()-\u003eAddEvent(fd, SOCKET_READ | SOCKET_EXCEP); m_callback(m_callback_data, NETLIB_MSG_CONNECT, (net_handle_t)fd, NULL); } } 接收新连接，需要注意以下事项：\n产生一个新的socket和对应的CBaseSocket对象。\n该socket和对应的CBaseSocket对象和侦听socket一样也被加入全局g_socket_map中进行管理。\n新socket同样被设置成非阻塞的。\n禁用该socket的nagle算法（_SetNoDelay(fd);）。\n关注该socket的读和异常事件（CEventDispatch::Instance()-\u003eAddEvent(fd, SOCKET_READ | SOCKET_EXCEP);）。\n将socket的状态设置成SOCKET_STATE_CONNECTED。\n调用侦听socket的的回调函数m_callback(m_callback_data, NETLIB_MSG_CONNECT, (net_handle_t)fd, NULL)，并传入消息类型是NETLIB_MSG_CONNECT。\n这个回调函数在上面初始化侦听函数设置的，指向函数proxy_serv_callback。调用代码如下：\nvoid proxy_serv_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { if (msg == NETLIB_MSG_CONNECT) { CProxyConn* pConn = new CProxyConn(); pConn-\u003eOnConnect(handle); } else { log(\"!!!error msg: %d\", msg); } } 接着调用CProxyConn的OnConnect()函数：\nvoid CProxyConn::OnConnect(net_handle_t handle) { m_handle = handle; g_proxy_conn_map.insert(make_pair(handle, this)); netlib_option(handle, NETLIB_OPT_SET_CALLBACK, (void*)imconn_callback); netlib_option(handle, NETLIB_OPT_SET_CALLBACK_DATA, (void*)\u0026g_proxy_conn_map); netlib_option(handle, NETLIB_OPT_GET_REMOTE_IP, (void*)\u0026m_peer_ip); netlib_option(handle, NETLIB_OPT_GET_REMOTE_PORT, (void*)\u0026m_peer_port); log(\"connect from %s:%d, handle=%d\", m_peer_ip.c_str(), m_peer_port, m_handle); } 注意！这里，已经悄悄地将该新socket的回调函数由proxy_serv_callback偷偷地换成了imconn_callback。同时，将该连接对象放入一个全局map g_proxy_conn_map中：\ntypedef hash_map\u003cnet_handle_t, CImConn*\u003e ConnMap_t; static ConnMap_t g_proxy_conn_map; 同样，该map的key是socket句柄，value是连接对象基类的指针。\n至此，对于侦听socket，如果socket可读，则接收新连接，并置换其默认OnRead的回调函数为imconn_callback；而对于新socket，如果socket可读，则会调用imconn_callback。\n我们接着看新socket可读的处理流程：\nvoid CBaseSocket::OnRead() { if (m_state == SOCKET_STATE_LISTENING) { _AcceptNewSocket(); } else { u_long avail = 0; if ( (ioctlsocket(m_socket, FIONREAD, \u0026avail) == SOCKET_ERROR) || (avail == 0) ) { m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } else { m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL); } } } 上述OnRead函数会走else分支，先调用ioctlsocket获得可读的数据字节数。如果出错或者字节数为0，则以消息NETLIB_MSG_CLOSE调用回调函数imconn_callback,\n反之，以消息NETLIB_MSG_READ调用回调函数imconn_callback。\nvoid imconn_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { NOTUSED_ARG(handle); NOTUSED_ARG(pParam); if (!callback_data) return; ConnMap_t* conn_map = (ConnMap_t*)callback_data; CImConn* pConn = FindImConn(conn_map, handle); if (!pConn) return; //log(\"msg=%d, handle=%d \", msg, handle); switch (msg) { case NETLIB_MSG_CONFIRM: pConn-\u003eOnConfirm(); break; case NETLIB_MSG_READ: pConn-\u003eOnRead(); break; case NETLIB_MSG_WRITE: pConn-\u003eOnWrite(); break; case NETLIB_MSG_CLOSE: pConn-\u003eOnClose(); break; default: log(\"!!!imconn_callback error msg: %d \", msg); break; } pConn-\u003eReleaseRef(); } 出错消息NETLIB_MSG_CLOSE没啥好看的，无非是关闭连接。我们来看NETLIB_MSG_READ消息，会调用pConn-\u003eOnRead()，pConn是一个CImConn指针，但根据上文介绍我们知道，其实际是一个CImConn的子类CProxyConn对象：\nclass CProxyConn : public CImConn { 所以pConn-\u003eOnRead()实际会调用CProxyConn的OnRead()：\nvoid CProxyConn::OnRead() { for (;;) { uint32_t free_buf_len = m_in_buf.GetAllocSize() - m_in_buf.GetWriteOffset(); if (free_buf_len \u003c READ_BUF_SIZE) m_in_buf.Extend(READ_BUF_SIZE); int ret = netlib_recv(m_handle, m_in_buf.GetBuffer() + m_in_buf.GetWriteOffset(), READ_BUF_SIZE); if (ret \u003c= 0) break; m_recv_bytes += ret; m_in_buf.IncWriteOffset(ret); m_last_recv_tick = get_tick_count(); } uint32_t pdu_len = 0; try { while ( CImPdu::IsPduAvailable(m_in_buf.GetBuffer(), m_in_buf.GetWriteOffset(), pdu_len) ) { HandlePduBuf(m_in_buf.GetBuffer(), pdu_len); m_in_buf.Read(NULL, pdu_len); } } catch (CPduException\u0026 ex) { log(\"!!!catch exception, err_code=%u, err_msg=%s, close the connection \", ex.GetErrorCode(), ex.GetErrorMsg()); OnClose(); } } CImConn实际是代表一个连接，即每一个连接都有这样一个对象。具体被分化成它的各个子对象，如CProxyConn。每一个连接CImConn都存在一个读缓冲区和写缓冲区，读缓冲区用于存放从网络上收取的数据，写缓冲区用于存放即将发到网络中数据。CProxyConn::OnRead()先检测该对象的读缓冲区中还有多少可用空间，如果可用空间小于当前收到的字节数目，则将该读缓冲区的大小扩展到需要的大小READ_BUF_SIZE。接着收到的数据放入读缓冲区中。并记录下这次收取数据的时间到m_last_recv_tick变量中。接着开始解包，即调用CImPdu::IsPduAvailable()从读取缓冲区中取出数据处理，先判断现有数据是否大于一个包头的大小，如果不大于，退出。如果大于一个包头的大小，则接着根据包头中的信息得到整个包的大小：\nbool CImPdu::IsPduAvailable(uchar_t* buf, uint32_t len, uint32_t\u0026 pdu_len) { if (len \u003c IM_PDU_HEADER_LEN) return false; pdu_len = CByteStream::ReadUint32(buf); if (pdu_len \u003e len) { //log(\"pdu_len=%d, len=%d\\n\", pdu_len, len); return false; } if(0 == pdu_len) { throw CPduException(1, \"pdu_len is 0\"); } return true; } 得到包的大小就可以正式处理包了，调用HandlePduBuf(m_in_buf.GetBuffer(), pdu_len);\nvoid CProxyConn::HandlePduBuf(uchar_t* pdu_buf, uint32_t pdu_len) { CImPdu* pPdu = NULL; pPdu = CImPdu::ReadPdu(pdu_buf, pdu_len); if (pPdu-\u003eGetCommandId() == IM::BaseDefine::CID_OTHER_HEARTBEAT) { return; } pdu_handler_t handler = s_handler_map-\u003eGetHandler(pPdu-\u003eGetCommandId()); if (handler) { CTask* pTask = new CProxyTask(m_uuid, handler, pPdu); g_thread_pool.AddTask(pTask); } else { log(\"no handler for packet type: %d\", pPdu-\u003eGetCommandId()); } } 包的数据结构是CImPdu（Im 即Instant Message即时通讯软件的意思，teamtalk本来就是一款即时通讯，pdu，Protocol Data Unit 协议数据单元，通俗的说就是一个包单位），该数据结构分为包头和包体两部分。类CImPdu的两个成员变量：\nCSimpleBuffer\tm_buf; PduHeader_t m_pdu_header; 分别表示包头和包体，包头的定义PduHeader_t如下：\ntypedef struct { uint32_t length;\t// the whole pdu length uint16_t version;\t// pdu version number uint16_t\tflag;\t// not used uint16_t\tservice_id;\t// uint16_t\tcommand_id;\t// uint16_t\tseq_num; // 包序号 uint16_t reversed; // 保留 } PduHeader_t; 通过包头的command_id就知道该包是什么数据了。接着根据对应的命令号调用在程序初始化阶段绑定的包处理函数：\npdu_handler_t handler = s_handler_map-\u003eGetHandler(pPdu-\u003eGetCommandId()); 执行处理函数不是直接调用该函数，而是包装成一个任务放入前面介绍的任务队列中：\ndu_handler_t handler = s_handler_map-\u003eGetHandler(pPdu-\u003eGetCommandId()); if (handler) { CTask* pTask = new CProxyTask(m_uuid, handler, pPdu); g_thread_pool.AddTask(pTask); } else { log(\"no handler for packet type: %d\", pPdu-\u003eGetCommandId()); } 前面介绍过，处理任务的线程可能有多个，那么到底将任务加入到哪个工作线程呢？这里采取的策略是随机分配：\nvoid CThreadPool::AddTask(CTask* pTask) { /* * select a random thread to push task * we can also select a thread that has less task to do * but that will scan the whole thread list and use thread lock to get each task size */ uint32_t thread_idx = random() % m_worker_size; m_worker_list[thread_idx].PushTask(pTask); } 当然需要注意的是。如果数据包是心跳包的话，就直接不处理了。因为心跳包只是来保活通信的，与具体业务无关：\nif (pPdu-\u003eGetCommandId() == IM::BaseDefine::CID_OTHER_HEARTBEAT) { return; } 该包处理完成以后，将该包的数据从连接的读缓冲区移除：\nm_in_buf.Read(NULL, pdu_len); 接着继续处理下一个包，因为收来的数据可能不够一个包大小，也可能是多个包的大小，所以要放在一个循环里面解包处理，直到读缓冲区中无数据或数据不够一个包的大小。\n我们将这个流程抽象出来，这个流程也是现在所有网络通信库都要做的工作：\nwhile(退出条件) { //1. 检测非侦听socket可读 //2. 处理可读事件 //3. 检测可读取的字节数，出错就关闭，不出错，将收取的字节放入连接的读缓冲区 //循环做以下处理 //4. 检测可读缓冲区数据大小是否大于等于一个包头大小: 否，数据不够一个包，跳出该循环; //\t是，从包头中得到一个包体的大小，检测读缓冲区是否够一个包头+包体的大小；否，数据不够一个包，跳出循环 //\t是，解包，根据包命令号，处理该包数据，可以产生一个任务，丢入任务队列。 //\t从可读缓冲区中移除刚才处理的包数据的字节数目。 //\t继续第4步。 } 当加入任务后，任务队列线程被唤醒，从任务队列的头部拿出该任务执行。这个上文介绍过了。\n到此，本文还没有完，因为上文只介绍了从客户端收取数据，然后解包。并没有介绍解完包，调用处理函数处理后如何应答客户端。下面以一个登录数据包的应答来叙述这个应答流程。登录任务从任务队列中取出来后，执行如下函数：\nvoid CHandlerMap::Init() { //DB_PROXY是命名空间，不是类名 // Login validate m_handler_map.insert(make_pair(uint32_t(CID_OTHER_VALIDATE_REQ), DB_PROXY::doLogin)); void doLogin(CImPdu* pPdu, uint32_t conn_uuid) { CImPdu* pPduResp = new CImPdu; IM::Server::IMValidateReq msg; IM::Server::IMValidateRsp msgResp; if(msg.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength())) { string strDomain = msg.user_name(); string strPass = msg.password(); msgResp.set_user_name(strDomain); msgResp.set_attach_data(msg.attach_data()); do { CAutoLock cAutoLock(\u0026g_cLimitLock); list\u003cuint32_t\u003e\u0026 lsErrorTime = g_hmLimits[strDomain]; uint32_t tmNow = time(NULL); //清理超过30分钟的错误时间点记录 /* 清理放在这里还是放在密码错误后添加的时候呢？ 放在这里，每次都要遍历，会有一点点性能的损失。 放在后面，可能会造成30分钟之前有10次错的，但是本次是对的就没办法再访问了。 */ auto itTime=lsErrorTime.begin(); for(; itTime!=lsErrorTime.end();++itTime) { if(tmNow - *itTime \u003e 30*60) { break; } } if(itTime != lsErrorTime.end()) { lsErrorTime.erase(itTime, lsErrorTime.end()); } // 判断30分钟内密码错误次数是否大于10 if(lsErrorTime.size() \u003e 10) { itTime = lsErrorTime.begin(); if(tmNow - *itTime \u003c= 30*60) { msgResp.set_result_code(6); msgResp.set_result_string(\"用户名/密码错误次数太多\"); pPduResp-\u003eSetPBMsg(\u0026msgResp); pPduResp-\u003eSetSeqNum(pPdu-\u003eGetSeqNum()); pPduResp-\u003eSetServiceId(IM::BaseDefine::SID_OTHER); pPduResp-\u003eSetCommandId(IM::BaseDefine::CID_OTHER_VALIDATE_RSP); CProxyConn::AddResponsePdu(conn_uuid, pPduResp); return ; } } } while(false); log(\"%s request login.\", strDomain.c_str()); IM::BaseDefine::UserInfo cUser; if(g_loginStrategy.doLogin(strDomain, strPass, cUser)) { IM::BaseDefine::UserInfo* pUser = msgResp.mutable_user_info(); pUser-\u003eset_user_id(cUser.user_id()); pUser-\u003eset_user_gender(cUser.user_gender()); pUser-\u003eset_department_id(cUser.department_id()); pUser-\u003eset_user_nick_name(cUser.user_nick_name()); pUser-\u003eset_user_domain(cUser.user_domain()); pUser-\u003eset_avatar_url(cUser.avatar_url()); pUser-\u003eset_email(cUser.email()); pUser-\u003eset_user_tel(cUser.user_tel()); pUser-\u003eset_user_real_name(cUser.user_real_name()); pUser-\u003eset_status(0); pUser-\u003eset_sign_info(cUser.sign_info()); msgResp.set_result_code(0); msgResp.set_result_string(\"成功\"); //如果登陆成功，则清除错误尝试限制 CAutoLock cAutoLock(\u0026g_cLimitLock); list\u003cuint32_t\u003e\u0026 lsErrorTime = g_hmLimits[strDomain]; lsErrorTime.clear(); } else { //密码错误，记录一次登陆失败 uint32_t tmCurrent = time(NULL); CAutoLock cAutoLock(\u0026g_cLimitLock); list\u003cuint32_t\u003e\u0026 lsErrorTime = g_hmLimits[strDomain]; lsErrorTime.push_front(tmCurrent); log(\"get result false\"); msgResp.set_result_code(1); msgResp.set_result_string(\"用户名/密码错误\"); } } else { msgResp.set_result_code(2); msgResp.set_result_string(\"服务端内部错误\"); } pPduResp-\u003eSetPBMsg(\u0026msgResp); pPduResp-\u003eSetSeqNum(pPdu-\u003eGetSeqNum()); pPduResp-\u003eSetServiceId(IM::BaseDefine::SID_OTHER); pPduResp-\u003eSetCommandId(IM::BaseDefine::CID_OTHER_VALIDATE_RSP); CProxyConn::AddResponsePdu(conn_uuid, pPduResp); } 这段代码有点复杂，下面分析之：\n首先，将登录请求包数据通过函数参数（第一个参数）传入进来，其次是连接对象的id。前面已经介绍过了，每一个新的socket不仅对应一个CBaseSocket对象，同时也对应一个连接对象CImConn（可能会被具体化成对应的子类，如CProxyConn）。这些连接对象被放在另外一个全局map g_proxy_conn_map里面进行管理。\n通过包数据，我们能得到登录的用户名和密码等信息。接着检测30分钟之内，尝试登录的次数，如果30分钟之内密码错误次数超过10此。则不允许登录。组成一个提示“用户名或密码错误此时太多”的包：\nmsgResp.set_result_code(6); msgResp.set_result_string(\"用户名/密码错误次数太多\"); pPduResp-\u003eSetPBMsg(\u0026msgResp); pPduResp-\u003eSetSeqNum(pPdu-\u003eGetSeqNum()); pPduResp-\u003eSetServiceId(IM::BaseDefine::SID_OTHER); pPduResp-\u003eSetCommandId(IM::BaseDefine::CID_OTHER_VALIDATE_RSP); CProxyConn::AddResponsePdu(conn_uuid, pPduResp); 如果不存在这种情况，则接着调用g_loginStrategy.doLogin(strDomain, strPass, cUser)连接数据库进行用户名和密码校验：\nbool CInterLoginStrategy::doLogin(const std::string \u0026strName, const std::string \u0026strPass, IM::BaseDefine::UserInfo\u0026 user) { bool bRet = false; CDBManager* pDBManger = CDBManager::getInstance(); CDBConn* pDBConn = pDBManger-\u003eGetDBConn(\"teamtalk_slave\"); if (pDBConn) { string strSql = \"select * from IMUser where name='\" + strName + \"' and status=0\"; CResultSet* pResultSet = pDBConn-\u003eExecuteQuery(strSql.c_str()); if(pResultSet) { string strResult, strSalt; uint32_t nId, nGender, nDeptId, nStatus; string strNick, strAvatar, strEmail, strRealName, strTel, strDomain,strSignInfo; while (pResultSet-\u003eNext()) { nId = pResultSet-\u003eGetInt(\"id\"); strResult = pResultSet-\u003eGetString(\"password\"); strSalt = pResultSet-\u003eGetString(\"salt\"); strNick = pResultSet-\u003eGetString(\"nick\"); nGender = pResultSet-\u003eGetInt(\"sex\"); strRealName = pResultSet-\u003eGetString(\"name\"); strDomain = pResultSet-\u003eGetString(\"domain\"); strTel = pResultSet-\u003eGetString(\"phone\"); strEmail = pResultSet-\u003eGetString(\"email\"); strAvatar = pResultSet-\u003eGetString(\"avatar\"); nDeptId = pResultSet-\u003eGetInt(\"departId\"); nStatus = pResultSet-\u003eGetInt(\"status\"); strSignInfo = pResultSet-\u003eGetString(\"sign_info\"); } string strInPass = strPass + strSalt; char szMd5[33]; CMd5::MD5_Calculate(strInPass.c_str(), strInPass.length(), szMd5); string strOutPass(szMd5); //去掉密码校验 //if(strOutPass == strResult) { bRet = true; user.set_user_id(nId); user.set_user_nick_name(strNick); user.set_user_gender(nGender); user.set_user_real_name(strRealName); user.set_user_domain(strDomain); user.set_user_tel(strTel); user.set_email(strEmail); user.set_avatar_url(strAvatar); user.set_department_id(nDeptId); user.set_status(nStatus); user.set_sign_info(strSignInfo); } delete pResultSet; } pDBManger-\u003eRelDBConn(pDBConn); } return bRet; } 这里也需要一个mysql连接，这个连接的分配方式在前面介绍过了。即在连接池中随机拿一个，如果池中不存在，则新建一个。用完还回去：\npDBManger-\u003eRelDBConn(pDBConn); 接着通过用户名从数据库中取出该用户信息，如果记录存在，则接着校验密码。密码在数据库里面的存储形式是：密码+用户的salt值 组成的字符串的md5值。密码如果也校验正确，组装成一个正确应答数据包（附上命令号、序列号、提示信息等）：\npPduResp-\u003eSetPBMsg(\u0026msgResp); pPduResp-\u003eSetSeqNum(pPdu-\u003eGetSeqNum()); pPduResp-\u003eSetServiceId(IM::BaseDefine::SID_OTHER); pPduResp-\u003eSetCommandId(IM::BaseDefine::CID_OTHER_VALIDATE_RSP); CProxyConn::AddResponsePdu(conn_uuid, pPduResp); 现在不管登录成功与否，登录应答包也已经组装好了。接下来，就是如何发出去了？上述代码最后一行：\nCProxyConn::AddResponsePdu(conn_uuid, pPduResp) 其调用如下：\nvoid CProxyConn::AddResponsePdu(uint32_t conn_uuid, CImPdu* pPdu) { ResponsePdu_t* pResp = new ResponsePdu_t; pResp-\u003econn_uuid = conn_uuid; pResp-\u003epPdu = pPdu; s_list_lock.lock(); s_response_pdu_list.push_back(pResp); s_list_lock.unlock(); } 我们这里并没有直接将应答数据包通过连接对象CProxyConn发出去。因为直接发出去，未必能发出去。这会导致程序阻塞。（原因是：对方的tcp窗口太小，导致tcp窗口太小的常见原因是：对方无法收包或不及时收包，数据积压在对方网络协议栈里面）。我们这里是将应答数据包放入连接对象的一个应答链表s_response_pdu_list中。这是一个stl list容器：\nstatic list\u003cResponsePdu_t*\u003e\ts_response_pdu_list;\t// 主线程发送回复消息 那么，包在这个链表中，何时被发出去呢？我们在介绍该服务的消息泵时介绍到如下流程：\nwhile(退出条件) { //1. 遍历定时器队列，检测是否有定时器事件到期，有则执行定时器的回调函数 //2. 遍历其他任务队列，检测是否有其他任务需要执行，有，执行之 //3. 检测socket集合，分离可读、可写和异常事件 //4. 处理socket可读事件 //5. 处理socket可写事件 //6. 处理socket异常事件 } 注意第2步：遍历其他任务队列，检测是否有其他任务需要执行，有，执行之。我们来看看这步具体做了什么。\n在main函数里面初始化任务队列线程时，同时也创建了一个其他任务：\ninit_proxy_conn(thread_num); int init_proxy_conn(uint32_t thread_num) { s_handler_map = CHandlerMap::getInstance(); g_thread_pool.Init(thread_num); netlib_add_loop(proxy_loop_callback, NULL); signal(SIGTERM, sig_handler); return netlib_register_timer(proxy_timer_callback, NULL, 1000); } 注意代码netlib_add_loop(proxy_loop_callback, NULL);该行加入了一个其他任务到其他任务队列。这样在主线程的消息泵中：2. 遍历其他任务队列，检测是否有其他任务需要执行，有，执行之。\n_CheckLoop(); void CEventDispatch::_CheckLoop() { for (list\u003cTimerItem*\u003e::iterator it = m_loop_list.begin(); it != m_loop_list.end(); it++) { TimerItem* pItem = *it; pItem-\u003ecallback(pItem-\u003euser_data, NETLIB_MSG_LOOP, 0, NULL); } } 其他任务的回调函数目前只有一个，就是上面设置的proxy_loop_callback：\nvoid proxy_loop_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { CProxyConn::SendResponsePduList(); } void CProxyConn::SendResponsePduList() { s_list_lock.lock(); while (!s_response_pdu_list.empty()) { ResponsePdu_t* pResp = s_response_pdu_list.front(); s_response_pdu_list.pop_front(); s_list_lock.unlock(); CProxyConn* pConn = get_proxy_conn_by_uuid(pResp-\u003econn_uuid); if (pConn) { if (pResp-\u003epPdu) { pConn-\u003eSendPdu(pResp-\u003epPdu); } else { log(\"close connection uuid=%d by parse pdu error\\b\", pResp-\u003econn_uuid); pConn-\u003eClose(); } } if (pResp-\u003epPdu) delete pResp-\u003epPdu; delete pResp; s_list_lock.lock(); } s_list_lock.unlock(); } 看到这里，你应该明白了。原来应答数据包在这里从list中取出来。然后调用pConn-\u003eSendPdu(pResp-\u003epPdu)“发出去”。这里需要解释两个问题：第一个就是一般服务器端会有多个连接对象，那么如何定位某个应答数据包对应的连接对象呢？这里就通过数据包本身的conn_uuid来确定：\nCProxyConn* pConn = get_proxy_conn_by_uuid(pResp-\u003econn_uuid); CProxyConn* get_proxy_conn_by_uuid(uint32_t uuid) { CProxyConn* pConn = NULL; UserMap_t::iterator it = g_uuid_conn_map.find(uuid); if (it != g_uuid_conn_map.end()) { pConn = (CProxyConn *)it-\u003esecond; } return pConn; } 全局对象g_uuid_conn_map里面存的是uuid与连接对象的对应关系。这个关系何时存入到这个全局g_uuid_conn_map对象的呢？在CProxyConn的构造函数中：\nCProxyConn::CProxyConn() { m_uuid = ++CProxyConn::s_uuid_alloctor; if (m_uuid == 0) { m_uuid = ++CProxyConn::s_uuid_alloctor; } g_uuid_conn_map.insert(make_pair(m_uuid, this)); } 这个uuid的基数是一个CProxyConn的静态变量：\nstatic uint32_t\ts_uuid_alloctor; 默认是0：\nuint32_t CProxyConn::s_uuid_alloctor = 0; 以后每产生一个新连接对象CProxyConn，在此基础上递增，因为没有用锁保护，所以只能在一个线程里面调用。而CProxyConn正好就是在主线程里面产生的，前面介绍过了，再次贴一下代码吧：\nvoid proxy_serv_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { if (msg == NETLIB_MSG_CONNECT) { CProxyConn* pConn = new CProxyConn(); pConn-\u003eOnConnect(handle); } else { log(\"!!!error msg: %d\", msg); } } 这样uuid和连接对象CProxyConn还有CBaseSocket这三者的关系就唯一绑定了。\n接着说，通过uuid获得对应数据包的连接对象后，调用其方法pConn-\u003eSendPdu(pResp-\u003epPdu); “发出去”？但是，还是不行，因为这还没有解决上文提出的该连接上对端的tcp窗口太小导致数据发不出的问题。所以pConn-\u003eSendPdu()方法中一定不是调用send函数直接发送数据：\nint SendPdu(CImPdu* pPdu) { return Send(pPdu-\u003eGetBuffer(), pPdu-\u003eGetLength()); } 实际上是调用其基类CImConn类的Send方法，发送数据的时候，先记录一下发送数据的时间：m_last_send_tick = get_tick_count();\nint CImConn::Send(void* data, int len) { m_last_send_tick = get_tick_count(); //\t++g_send_pkt_cnt; if (m_busy) { m_out_buf.Write(data, len); return len; } int offset = 0; int remain = len; while (remain \u003e 0) { int send_size = remain; if (send_size \u003e NETLIB_MAX_SOCKET_BUF_SIZE) { send_size = NETLIB_MAX_SOCKET_BUF_SIZE; } int ret = netlib_send(m_handle, (char*)data + offset, send_size); if (ret \u003c= 0) { ret = 0; break; } offset += ret; remain -= ret; } if (remain \u003e 0) { m_out_buf.Write((char*)data + offset, remain); m_busy = true; log(\"send busy, remain=%d \", m_out_buf.GetWriteOffset()); } else { OnWriteCompelete(); } return len; } 注意这段代码，也是特别的讲究：\n先试着调用底层send方法去发送，能发多少是多少，剩下发不完的，写入该连接的发送缓冲区中，并将忙碌标志m_busy置位（设置为ture）。反之，如果数据一次性发送完成，则调用数据发送完成函数OnWriteComplete（），这个函数目前为空，即不做任何事情。\nint ret = netlib_send(m_handle, (char*)data + offset , send_size); int netlib_send(net_handle_t handle, void* buf, int len) { CBaseSocket* pSocket = FindBaseSocket(handle); if (!pSocket) { return NETLIB_ERROR; } int ret = pSocket-\u003eSend(buf, len); pSocket-\u003eReleaseRef(); return ret; } 上面的代码通过socket句柄找到具体的CBaseSocket对象。接着调用CBaseSocket::Send()方法：\nint CBaseSocket::Send(void* buf, int len) { if (m_state != SOCKET_STATE_CONNECTED) return NETLIB_ERROR; int ret = send(m_socket, (char*)buf, len, 0); if (ret == SOCKET_ERROR) { int err_code = _GetErrorCode(); if (_IsBlock(err_code)) { #if ((defined _WIN32) || (defined __APPLE__)) CEventDispatch::Instance()-\u003eAddEvent(m_socket, SOCKET_WRITE); #endif ret = 0; //log(\"socket send block fd=%d\", m_socket); } else { log(\"!!!send failed, error code: %d\", err_code); } } return ret; } 该方法发送指定长度的数据，因为socket在创建的时候被设置成非阻塞的（上文介绍过）。所以，如果发送不了，底层send函数会立刻返回，并返回错误码EINPROGRESS（EWOULDBLOCK），表明对端tcp窗口太小，当前已经无法发出去：\nbool CBaseSocket::_IsBlock(int error_code) { #ifdef _WIN32 return ( (error_code == WSAEINPROGRESS) || (error_code == WSAEWOULDBLOCK) ); #else return ( (error_code == EINPROGRESS) || (error_code == EWOULDBLOCK) ); #endif } 这个时候，我们再设置关注该socket的可写事件。这样，下次对端tcp窗口大小增大时，本端的socket可写时，我们就能接着发送数据了。会在服务的消息泵中检测可写事件，接着调用CBaseSocket::OnWrite()， 该函数首先移除该socket的可写事件（这里为啥只有win32平台和mac机器移除可写事件，linux平台不需要吗？个人觉得是程序作者的疏忽）。\nvoid CBaseSocket::OnWrite() { #if ((defined _WIN32) || (defined __APPLE__)) CEventDispatch::Instance()-\u003eRemoveEvent(m_socket, SOCKET_WRITE); #endif if (m_state == SOCKET_STATE_CONNECTING) { int error = 0; socklen_t len = sizeof(error); #ifdef _WIN32 getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (char*)\u0026error, \u0026len); #else getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (void*)\u0026error, \u0026len); #endif if (error) { m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } else { m_state = SOCKET_STATE_CONNECTED; m_callback(m_callback_data, NETLIB_MSG_CONFIRM, (net_handle_t)m_socket, NULL); } } else { m_callback(m_callback_data, NETLIB_MSG_WRITE, (net_handle_t)m_socket, NULL); } } 走else分支，调用设置的回调函数imconn_callback：\nvoid imconn_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { NOTUSED_ARG(handle); NOTUSED_ARG(pParam); if (!callback_data) return; ConnMap_t* conn_map = (ConnMap_t*)callback_data; CImConn* pConn = FindImConn(conn_map, handle); if (!pConn) return; //log(\"msg=%d, handle=%d \", msg, handle); switch (msg) { case NETLIB_MSG_CONFIRM: pConn-\u003eOnConfirm(); break; case NETLIB_MSG_READ: pConn-\u003eOnRead(); break; case NETLIB_MSG_WRITE: pConn-\u003eOnWrite(); break; case NETLIB_MSG_CLOSE: pConn-\u003eOnClose(); break; default: log(\"!!!imconn_callback error msg: %d \", msg); break; } pConn-\u003eReleaseRef(); } 因为这次传入的消息是NETLIB_MSG_WRITE，所以走pConn-\u003eOnWrite分支，接着由于多态调用CImConn的子类CProxyConn的OnWrite()函数，但由于子类CProxyConn并没有改写OnWrite()方法，所以调用CImConn的OnWrite():\nvoid CImConn::OnWrite() { if (!m_busy) return; while (m_out_buf.GetWriteOffset() \u003e 0) { int send_size = m_out_buf.GetWriteOffset(); if (send_size \u003e NETLIB_MAX_SOCKET_BUF_SIZE) { send_size = NETLIB_MAX_SOCKET_BUF_SIZE; } int ret = netlib_send(m_handle, m_out_buf.GetBuffer(), send_size); if (ret \u003c= 0) { ret = 0; break; } m_out_buf.Read(NULL, ret); } if (m_out_buf.GetWriteOffset() == 0) { m_busy = false; } log(\"onWrite, remain=%d \", m_out_buf.GetWriteOffset()); } 接着继续从写缓冲区取出数据继续发送，如果还是只能发送出去，继续监听该socket可写事件，每次发送出去多少，就从写缓冲区中移除该部分字节。如果全部发送完了。将忙碌标志m_busy清零（false）。\n至此，应答数据包的流程也介绍完了。我们来总结下该流程：\n//1. 主消息泵检测到有其他任务需要做，做之。 //2. 该任务是从全局的链表中取出应答包数据，找到对应的连接对象，然后尝试直接发出去； //3. 如果发不出，则将该数据存入该连接的发送缓冲区（写缓冲区），并监听该连接的socket可写事件。 //4. 下次该socket触发可写事件时，接着发送该连接的写缓冲区中剩余的数据。如此循环直到所有数据都发送成功。 //5. 取消监听该socket可写事件，以避免无数据的情况下触发写事件（该事件大多数情况下很频繁） 上面的流程从第2步到第5步也是主流网络库的发数据的逻辑。总而言之，就是说，先试着发送数据，如果发不出去，存起来，监听可写事件，下次触发可写事件后接着发。一直到数据全部发出去后，移除监听可写事件。通常只要可写事件是不断会触发的，所以默认不监听可写事件，只有数据发不出的时候才会监听可写事件。这个原则，千万要记住。\n最后一个问题，是关于心跳包的，即db_proxy_server是如何发送心跳包的：\n程序初始化的时候，注册一个定时器函数：\ninit_proxy_conn(thread_num); int init_proxy_conn(uint32_t thread_num) { s_handler_map = CHandlerMap::getInstance(); g_thread_pool.Init(thread_num); netlib_add_loop(proxy_loop_callback, NULL); signal(SIGTERM, sig_handler); return netlib_register_timer(proxy_timer_callback, NULL, 1000); } 最后一行：return netlib_register_timer(proxy_timer_callback, NULL, 1000);\n然后在消息泵里面检测定时器：\n_CheckTimer(); void CEventDispatch::_CheckTimer() { uint64_t curr_tick = get_tick_count(); list\u003cTimerItem*\u003e::iterator it; for (it = m_timer_list.begin(); it != m_timer_list.end(); ) { TimerItem* pItem = *it; it++;\t// iterator maybe deleted in the callback, so we should increment it before callback if (curr_tick \u003e= pItem-\u003enext_tick) { pItem-\u003enext_tick += pItem-\u003einterval; pItem-\u003ecallback(pItem-\u003euser_data, NETLIB_MSG_TIMER, 0, NULL); } } } uint64_t get_tick_count() { #ifdef _WIN32 LARGE_INTEGER liCounter; LARGE_INTEGER liCurrent; if (!QueryPerformanceFrequency(\u0026liCounter)) return GetTickCount(); QueryPerformanceCounter(\u0026liCurrent); return (uint64_t)(liCurrent.QuadPart * 1000 / liCounter.QuadPart); #else struct timeval tval; uint64_t ret_tick; gettimeofday(\u0026tval, NULL); ret_tick = tval.tv_sec * 1000L + tval.tv_usec / 1000L; return ret_tick; #endif } 由上面的函数可以看出来定时器的单位是毫秒，当定时器时间到了后，调用回调函数proxy_timer_callback：\nvoid proxy_timer_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { uint64_t cur_time = get_tick_count(); for (ConnMap_t::iterator it = g_proxy_conn_map.begin(); it != g_proxy_conn_map.end(); ) { ConnMap_t::iterator it_old = it; it++; CProxyConn* pConn = (CProxyConn*)it_old-\u003esecond; pConn-\u003eOnTimer(cur_time); } } void CProxyConn::OnTimer(uint64_t curr_tick) { if (curr_tick \u003e m_last_send_tick + SERVER_HEARTBEAT_INTERVAL) { CImPdu cPdu; IM::Other::IMHeartBeat msg; cPdu.SetPBMsg(\u0026msg); cPdu.SetServiceId(IM::BaseDefine::SID_OTHER); cPdu.SetCommandId(IM::BaseDefine::CID_OTHER_HEARTBEAT); SendPdu(\u0026cPdu); } if (curr_tick \u003e m_last_recv_tick + SERVER_TIMEOUT) { log(\"proxy connection timeout %s:%d\", m_peer_ip.c_str(), m_peer_port); Close(); } } m_last_send_tick是上一次发送数据的时间，我们上文中介绍过，如果当前时间距上一次发送数据的时间已经超过了指定的时间间隔，则发送一个心跳包（这里的时间间隔是5000毫秒）。\nm_last_recv_tick是上一次收取数据的时间，我们上文也介绍过，如果当前时间举例上一次接收时间已经超过了指定的时间间隔（相当于一段时间内，对端没有给当前服务发送任何数据），这个时候就关闭该连接（这里设置的时间间隔是30000毫秒，也就是30秒）。\n这种心跳包机制特别值得推崇，也是常见的心跳包策略。\n至此，db_proxy_server的框架和原理也就介绍完了。剩下的就是一些业务逻辑了。如果你感兴趣，可以自己查看对应的命令号绑定的处理函数的处理流程。\n文中如果有说错的地方，欢迎提出留言指正。\n",
  "wordCount" : "3582",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/blog/5481b95ce7c64f8c99c98e3c59d74314/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      04 服务器端db_proxy_server源码分析
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#04-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%afdb_proxy_server%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" aria-label="04 服务器端db_proxy_server源码分析">04 服务器端db_proxy_server源码分析</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e4%b8%80%e5%88%9d%e5%a7%8b%e5%8c%96redis%e8%bf%9e%e6%8e%a5" aria-label="一、初始化redis连接">一、初始化redis连接</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%88%9d%e5%a7%8b%e5%8c%96mysql%e8%bf%9e%e6%8e%a5" aria-label="二、初始化mysql连接">二、初始化mysql连接</a></li>
                <li>
                    <a href="#%e4%b8%89%e5%90%af%e5%8a%a8%e4%bb%bb%e5%8a%a1%e9%98%9f%e5%88%97%e7%94%a8%e4%ba%8e%e5%a4%84%e7%90%86%e4%bb%bb%e5%8a%a1" aria-label="三、启动任务队列，用于处理任务">三、启动任务队列，用于处理任务</a></li>
                <li>
                    <a href="#%e5%9b%9b%e5%90%af%e5%8a%a8%e4%bb%8emysql%e5%90%8c%e6%ad%a5%e6%95%b0%e6%8d%ae%e5%88%b0redis%e5%b7%a5%e4%bd%9c" aria-label="四、启动从mysql同步数据到redis工作">四、启动从mysql同步数据到redis工作</a></li>
                <li>
                    <a href="#%e4%ba%94%e5%9c%a8%e7%ab%af%e5%8f%a310600%e4%b8%8a%e5%90%af%e5%8a%a8%e4%be%a6%e5%90%ac%e7%9b%91%e5%90%ac%e6%96%b0%e8%bf%9e%e6%8e%a5" aria-label="五、在端口10600上启动侦听，监听新连接">五、在端口10600上启动侦听，监听新连接</a></li>
                <li>
                    <a href="#%e5%85%ad%e4%b8%bb%e7%ba%bf%e7%a8%8b%e8%bf%9b%e5%85%a5%e5%be%aa%e7%8e%af%e7%9b%91%e5%90%ac%e6%96%b0%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%88%b0%e6%9d%a5%e4%bb%a5%e5%8f%8a%e5%87%ba%e6%9d%a5%e6%96%b0%e8%bf%9e%e6%8e%a5%e4%b8%8a%e7%9a%84%e6%95%b0%e6%8d%ae%e6%94%b6%e5%8f%91" aria-label="六、主线程进入循环，监听新连接的到来以及出来新连接上的数据收发">六、主线程进入循环，监听新连接的到来以及出来新连接上的数据收发</a>
                </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="04-服务器端db_proxy_server源码分析">04 服务器端db_proxy_server源码分析</h1>
<p>从这篇文章开始，我将详细地分析TeamTalk服务器端每一个服务的源码和架构设计。</p>
<p>这篇从db_proxy_server开始。db_proxy_server是TeamTalk服务器端最后端的程序，它连接着关系型数据库mysql和nosql内存数据库redis。其位置在整个服务架构中如图所示：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/b5176e5e61fbb5a73c357b73fa8cdece.jpg" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>我们从db_proxy_server的main()函数开始，main()函数其实就是做了以下初始化工作，我整理成如下伪码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>int main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	//1. 初始化redis连接
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	//2. 初始化mysql连接
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	//3. 启动任务队列，用于处理任务
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	//4. 启动从mysql同步数据到redis工作
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	//5. 在端口10600上启动侦听，监听新连接
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	//6. 主线程进入循环，监听新连接的到来以及出来新连接上的数据收发
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面，我们将一一介绍以上步骤。</p>
<h3 id="一初始化redis连接">一、初始化redis连接</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CacheManager<span style="color:#f92672">*</span> pCacheManager <span style="color:#f92672">=</span> CacheManager<span style="color:#f92672">::</span>getInstance();
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CacheManager<span style="color:#f92672">*</span> CacheManager<span style="color:#f92672">::</span>getInstance()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s_cache_manager) {
</span></span><span style="display:flex;"><span>		s_cache_manager <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CacheManager();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (s_cache_manager<span style="color:#f92672">-&gt;</span>Init()) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">delete</span> s_cache_manager;
</span></span><span style="display:flex;"><span>			s_cache_manager <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> s_cache_manager;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CacheManager<span style="color:#f92672">::</span>Init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CConfigFileReader <span style="color:#a6e22e">config_file</span>(<span style="color:#e6db74">&#34;dbproxyserver.conf&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//CacheInstances=unread,group_set,token,sync,group_member
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cache_instances <span style="color:#f92672">=</span> config_file.GetConfigName(<span style="color:#e6db74">&#34;CacheInstances&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cache_instances) {
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;not configure CacheIntance&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> host[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> port[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> db[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> maxconncnt[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	CStrExplode <span style="color:#a6e22e">instances_name</span>(cache_instances, <span style="color:#e6db74">&#39;,&#39;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> instances_name.GetItemCnt(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pool_name <span style="color:#f92672">=</span> instances_name.GetItem(i);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//printf(&#34;%s&#34;, pool_name);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		snprintf(host, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_host&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>		snprintf(port, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_port&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>		snprintf(db, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_db&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>        snprintf(maxconncnt, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_maxconncnt&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cache_host <span style="color:#f92672">=</span> config_file.GetConfigName(host);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> str_cache_port <span style="color:#f92672">=</span> config_file.GetConfigName(port);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> str_cache_db <span style="color:#f92672">=</span> config_file.GetConfigName(db);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> str_max_conn_cnt <span style="color:#f92672">=</span> config_file.GetConfigName(maxconncnt);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cache_host <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>str_cache_port <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>str_cache_db <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>str_max_conn_cnt) {
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;not configure cache instance: %s&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		CachePool<span style="color:#f92672">*</span> pCachePool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CachePool(pool_name, cache_host, atoi(str_cache_port),
</span></span><span style="display:flex;"><span>				atoi(str_cache_db), atoi(str_max_conn_cnt));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (pCachePool<span style="color:#f92672">-&gt;</span>Init()) {
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;Init cache pool failed&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_cache_pool_map.insert(make_pair(pool_name, pCachePool));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在pCachePool-&gt;Init()中是实际连接redis的动作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CachePool<span style="color:#f92672">::</span>Init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m_cur_conn_cnt; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		CacheConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CacheConn(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (pConn<span style="color:#f92672">-&gt;</span>Init()) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">delete</span> pConn;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_free_list.push_back(pConn);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;cache pool: %s, list size: %lu&#34;</span>, m_pool_name.c_str(), m_free_list.size());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>pConn-&gt;Init()调用如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CacheConn<span style="color:#f92672">::</span>Init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_pContext) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 4s 尝试重连一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">uint64_t</span> cur_time <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)time(NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cur_time <span style="color:#f92672">&lt;</span> m_last_connect_time <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_last_connect_time <span style="color:#f92672">=</span> cur_time;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 200ms超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span> timeout <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">200000</span>};
</span></span><span style="display:flex;"><span>	m_pContext <span style="color:#f92672">=</span> redisConnectWithTimeout(m_pCachePool<span style="color:#f92672">-&gt;</span>GetServerIP(), m_pCachePool<span style="color:#f92672">-&gt;</span>GetServerPort(), timeout);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_pContext <span style="color:#f92672">||</span> m_pContext<span style="color:#f92672">-&gt;</span>err) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (m_pContext) {
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;redisConnect failed: %s&#34;</span>, m_pContext<span style="color:#f92672">-&gt;</span>errstr);
</span></span><span style="display:flex;"><span>			redisFree(m_pContext);
</span></span><span style="display:flex;"><span>			m_pContext <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;redisConnect failed&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	redisReply<span style="color:#f92672">*</span> reply <span style="color:#f92672">=</span> (redisReply <span style="color:#f92672">*</span>)redisCommand(m_pContext, <span style="color:#e6db74">&#34;SELECT %d&#34;</span>, m_pCachePool<span style="color:#f92672">-&gt;</span>GetDBNum());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reply <span style="color:#f92672">&amp;&amp;</span> (reply<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">==</span> REDIS_REPLY_STATUS) <span style="color:#f92672">&amp;&amp;</span> (strncmp(reply<span style="color:#f92672">-&gt;</span>str, <span style="color:#e6db74">&#34;OK&#34;</span>, <span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		freeReplyObject(reply);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;select cache db failed&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>层级关系是这样的：
CacheManager的成员变量m_cache_pool_map存储了配置文件配置的redis缓存池，这是一个map对象，key是缓存池的名字，value是缓存池CachePool对象的指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>map<span style="color:#f92672">&lt;</span>string, CachePool<span style="color:#f92672">*&gt;</span>	m_cache_pool_map;
</span></span></code></pre></div><p>dbproxyserver.conf目前配置了如下几个redis缓存池：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>CacheInstances=unread,group_set,token,sync,group_member
</span></span></code></pre></div><p>每一个缓存池对象CachePool的成员变量m_free_list中存储着若干个与redis的连接对象，具体是多少个，根据配置文件来配置。m_free_list定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>list<span style="color:#f92672">&lt;</span>CacheConn<span style="color:#f92672">*&gt;</span>	m_free_list;
</span></span></code></pre></div><p>这些与redis连接对象后面会介绍在何处使用。</p>
<h3 id="二初始化mysql连接">二、初始化mysql连接</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CDBManager<span style="color:#f92672">*</span> pDBManager <span style="color:#f92672">=</span> CDBManager<span style="color:#f92672">::</span>getInstance();
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CDBManager<span style="color:#f92672">*</span> CDBManager<span style="color:#f92672">::</span>getInstance()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s_db_manager) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>		s_db_manager <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CDBManager();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (s_db_manager<span style="color:#f92672">-&gt;</span>Init()) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">delete</span> s_db_manager;
</span></span><span style="display:flex;"><span>			s_db_manager <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> s_db_manager;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CDBManager<span style="color:#f92672">::</span>Init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CConfigFileReader <span style="color:#a6e22e">config_file</span>(<span style="color:#e6db74">&#34;dbproxyserver.conf&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//DBInstances=teamtalk_master,teamtalk_slave
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> db_instances <span style="color:#f92672">=</span> config_file.GetConfigName(<span style="color:#e6db74">&#34;DBInstances&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>db_instances) {
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;not configure DBInstances&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> host[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> port[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> dbname[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> username[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> password[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> maxconncnt[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	CStrExplode <span style="color:#a6e22e">instances_name</span>(db_instances, <span style="color:#e6db74">&#39;,&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> instances_name.GetItemCnt(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pool_name <span style="color:#f92672">=</span> instances_name.GetItem(i);
</span></span><span style="display:flex;"><span>		snprintf(host, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_host&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>		snprintf(port, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_port&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>		snprintf(dbname, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_dbname&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>		snprintf(username, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_username&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>		snprintf(password, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_password&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>        snprintf(maxconncnt, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;%s_maxconncnt&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> db_host <span style="color:#f92672">=</span> config_file.GetConfigName(host);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> str_db_port <span style="color:#f92672">=</span> config_file.GetConfigName(port);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> db_dbname <span style="color:#f92672">=</span> config_file.GetConfigName(dbname);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> db_username <span style="color:#f92672">=</span> config_file.GetConfigName(username);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> db_password <span style="color:#f92672">=</span> config_file.GetConfigName(password);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> str_maxconncnt <span style="color:#f92672">=</span> config_file.GetConfigName(maxconncnt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>db_host <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>str_db_port <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>db_dbname <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>db_username <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>db_password <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>str_maxconncnt) {
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;not configure db instance: %s&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> db_port <span style="color:#f92672">=</span> atoi(str_db_port);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> db_maxconncnt <span style="color:#f92672">=</span> atoi(str_maxconncnt);
</span></span><span style="display:flex;"><span>		CDBPool<span style="color:#f92672">*</span> pDBPool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CDBPool(pool_name, db_host, db_port, db_username, db_password, db_dbname, db_maxconncnt);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (pDBPool<span style="color:#f92672">-&gt;</span>Init()) 
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;init db instance failed: %s&#34;</span>, pool_name);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		m_dbpool_map.insert(make_pair(pool_name, pDBPool));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同理pDBPool-&gt;Init()中是实际连接mysql代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CDBPool<span style="color:#f92672">::</span>Init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m_db_cur_conn_cnt; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		CDBConn<span style="color:#f92672">*</span> pDBConn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CDBConn(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> pDBConn<span style="color:#f92672">-&gt;</span>Init();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">delete</span> pDBConn;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_free_list.push_back(pDBConn);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;db pool: %s, size: %d&#34;</span>, m_pool_name.c_str(), (<span style="color:#66d9ef">int</span>)m_free_list.size());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CDBConn<span style="color:#f92672">::</span>Init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_mysql <span style="color:#f92672">=</span> mysql_init(NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_mysql) {
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;mysql_init failed&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	my_bool reconnect <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	mysql_options(m_mysql, MYSQL_OPT_RECONNECT, <span style="color:#f92672">&amp;</span>reconnect);
</span></span><span style="display:flex;"><span>	mysql_options(m_mysql, MYSQL_SET_CHARSET_NAME, <span style="color:#e6db74">&#34;utf8mb4&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mysql_real_connect(m_mysql, m_pDBPool<span style="color:#f92672">-&gt;</span>GetDBServerIP(), m_pDBPool<span style="color:#f92672">-&gt;</span>GetUsername(), <span style="color:#e6db74">&#34;&#34;</span><span style="color:#75715e">/*m_pDBPool-&gt;GetPasswrod()*/</span>,
</span></span><span style="display:flex;"><span>			m_pDBPool<span style="color:#f92672">-&gt;</span>GetDBName(), m_pDBPool<span style="color:#f92672">-&gt;</span>GetDBServerPort(), NULL, <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;mysql_real_connect failed: %s&#34;</span>, mysql_error(m_mysql));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与redis连接对象类似，CDBManager的成员对象m_dbpool_map存储了mysql连接池，这也是一个stl map，key是池子的名字，value是连接池的对象CDBPool指针。配置文件中总共配置了名称为主从两个mysql连接池。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>DBInstances=teamtalk_master,teamtalk_slave
</span></span></code></pre></div><p>连接池对象CDBPool用一个成员变量存储自己的若干个mysql连接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>list<span style="color:#f92672">&lt;</span>CDBConn<span style="color:#f92672">*&gt;</span>	m_free_list;        <span style="color:#75715e">//实际保存mysql连接的容器
</span></span></span></code></pre></div><p>具体每个连接池有多少个mysql连接，根据配置文件得到，这里主从两个库都是16个。</p>
<p>这些mysql连接的用途后面介绍。</p>
<h3 id="三启动任务队列用于处理任务">三、启动任务队列，用于处理任务</h3>
<p>初始化一：创建线程处理任务队列中的任务</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>init_proxy_conn(thread_num);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">init_proxy_conn</span>(<span style="color:#66d9ef">uint32_t</span> thread_num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	s_handler_map <span style="color:#f92672">=</span> CHandlerMap<span style="color:#f92672">::</span>getInstance();
</span></span><span style="display:flex;"><span>	g_thread_pool.Init(thread_num);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	netlib_add_loop(proxy_loop_callback, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	signal(SIGTERM, sig_handler);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> netlib_register_timer(proxy_timer_callback, NULL, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>线程数量根据配置文件得到。g_thread_pool.Init(thread_num)中实际创建处理任务的线程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CThreadPool<span style="color:#f92672">::</span>Init(<span style="color:#66d9ef">uint32_t</span> worker_size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    m_worker_size <span style="color:#f92672">=</span> worker_size;
</span></span><span style="display:flex;"><span>	m_worker_list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CWorkerThread [m_worker_size];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_worker_list) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m_worker_size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		m_worker_list[i].SetThreadIdx(i);
</span></span><span style="display:flex;"><span>		m_worker_list[i].Start();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CWorkerThread<span style="color:#f92672">::</span>Start()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	(<span style="color:#66d9ef">void</span>)pthread_create(<span style="color:#f92672">&amp;</span>m_thread_id, NULL, StartRoutine, <span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>线程函数调用序列如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> CWorkerThread<span style="color:#f92672">::</span>StartRoutine(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CWorkerThread<span style="color:#f92672">*</span> pThread <span style="color:#f92672">=</span> (CWorkerThread<span style="color:#f92672">*</span>)arg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pThread<span style="color:#f92672">-&gt;</span>Execute();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CWorkerThread<span style="color:#f92672">::</span>Execute()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>		m_thread_notify.Lock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// put wait in while cause there can be spurious wake up (due to signal/ENITR)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> (m_task_list.empty()) {
</span></span><span style="display:flex;"><span>			m_thread_notify.Wait();
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		CTask<span style="color:#f92672">*</span> pTask <span style="color:#f92672">=</span> m_task_list.front();
</span></span><span style="display:flex;"><span>		m_task_list.pop_front();
</span></span><span style="display:flex;"><span>		m_thread_notify.Unlock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		pTask<span style="color:#f92672">-&gt;</span>run();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">delete</span> pTask;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_task_cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//log(&#34;%d have the execute %d task\n&#34;, m_thread_idx, m_task_cnt);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到工作线程一直在等待一个条件变量，当向任务队列中添加任务时，条件变量被唤醒：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CWorkerThread<span style="color:#f92672">::</span>PushTask(CTask<span style="color:#f92672">*</span> pTask)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_thread_notify.Lock();
</span></span><span style="display:flex;"><span>	m_task_list.push_back(pTask);
</span></span><span style="display:flex;"><span>	m_thread_notify.Signal();
</span></span><span style="display:flex;"><span>	m_thread_notify.Unlock();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>任务队列的用途，下文会介绍。</p>
<p>初始化二：将各个任务id与对应的处理函数绑定起来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>s_handler_map <span style="color:#f92672">=</span> CHandlerMap<span style="color:#f92672">::</span>getInstance();
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CHandlerMap<span style="color:#f92672">*</span> CHandlerMap<span style="color:#f92672">::</span>getInstance()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s_handler_instance) {
</span></span><span style="display:flex;"><span>		s_handler_instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CHandlerMap();
</span></span><span style="display:flex;"><span>		s_handler_instance<span style="color:#f92672">-&gt;</span>Init();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> s_handler_instance;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CHandlerMap<span style="color:#f92672">::</span>Init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//DB_PROXY是命名空间，不是类名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Login validate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_OTHER_VALIDATE_REQ), DB_PROXY<span style="color:#f92672">::</span>doLogin));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_LOGIN_REQ_PUSH_SHIELD), DB_PROXY<span style="color:#f92672">::</span>doPushShield));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_LOGIN_REQ_QUERY_PUSH_SHIELD), DB_PROXY<span style="color:#f92672">::</span>doQueryPushShield));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// recent session
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getRecentSession));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_REMOVE_SESSION_REQ), DB_PROXY<span style="color:#f92672">::</span>deleteRecentSession));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// users
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_USER_INFO_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getUserInfo));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_ALL_USER_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getChangedUser));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_DEPARTMENT_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getChgedDepart));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST), DB_PROXY<span style="color:#f92672">::</span>changeUserSignInfo));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// message content
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_DATA), DB_PROXY<span style="color:#f92672">::</span>sendMessage));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_LIST_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getMessage));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_UNREAD_CNT_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getUnreadMsgCounter));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_READ_ACK), DB_PROXY<span style="color:#f92672">::</span>clearUnreadMsgCounter));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_GET_BY_MSG_ID_REQ), DB_PROXY<span style="color:#f92672">::</span>getMessageById));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_GET_LATEST_MSG_ID_REQ), DB_PROXY<span style="color:#f92672">::</span>getLatestMsgId));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// device token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_LOGIN_REQ_DEVICETOKEN), DB_PROXY<span style="color:#f92672">::</span>setDevicesToken));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_OTHER_GET_DEVICE_TOKEN_REQ), DB_PROXY<span style="color:#f92672">::</span>getDevicesToken));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//push 推送设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_SHIELD_GROUP_REQUEST), DB_PROXY<span style="color:#f92672">::</span>setGroupPush));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_OTHER_GET_SHIELD_REQ), DB_PROXY<span style="color:#f92672">::</span>getGroupPush));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_NORMAL_LIST_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getNormalGroupList));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_INFO_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getGroupInfo));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_CREATE_REQUEST), DB_PROXY<span style="color:#f92672">::</span>createGroup));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_CHANGE_MEMBER_REQUEST), DB_PROXY<span style="color:#f92672">::</span>modifyMember));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_FILE_HAS_OFFLINE_REQ), DB_PROXY<span style="color:#f92672">::</span>hasOfflineFile));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_FILE_ADD_OFFLINE_REQ), DB_PROXY<span style="color:#f92672">::</span>addOfflineFile));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_FILE_DEL_OFFLINE_REQ), DB_PROXY<span style="color:#f92672">::</span>delOfflineFile));
</span></span><span style="display:flex;"><span>}	m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_OTHER_VALIDATE_REQ), DB_PROXY<span style="color:#f92672">::</span>doLogin));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_LOGIN_REQ_PUSH_SHIELD), DB_PROXY<span style="color:#f92672">::</span>doPushShield));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_LOGIN_REQ_QUERY_PUSH_SHIELD), DB_PROXY<span style="color:#f92672">::</span>doQueryPushShield));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// recent session
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getRecentSession));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_REMOVE_SESSION_REQ), DB_PROXY<span style="color:#f92672">::</span>deleteRecentSession));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// users
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_USER_INFO_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getUserInfo));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_ALL_USER_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getChangedUser));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_DEPARTMENT_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getChgedDepart));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST), DB_PROXY<span style="color:#f92672">::</span>changeUserSignInfo));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// message content
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_DATA), DB_PROXY<span style="color:#f92672">::</span>sendMessage));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_LIST_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getMessage));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_UNREAD_CNT_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getUnreadMsgCounter));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_READ_ACK), DB_PROXY<span style="color:#f92672">::</span>clearUnreadMsgCounter));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_GET_BY_MSG_ID_REQ), DB_PROXY<span style="color:#f92672">::</span>getMessageById));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_MSG_GET_LATEST_MSG_ID_REQ), DB_PROXY<span style="color:#f92672">::</span>getLatestMsgId));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// device token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_LOGIN_REQ_DEVICETOKEN), DB_PROXY<span style="color:#f92672">::</span>setDevicesToken));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_OTHER_GET_DEVICE_TOKEN_REQ), DB_PROXY<span style="color:#f92672">::</span>getDevicesToken));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//push 推送设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_SHIELD_GROUP_REQUEST), DB_PROXY<span style="color:#f92672">::</span>setGroupPush));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_OTHER_GET_SHIELD_REQ), DB_PROXY<span style="color:#f92672">::</span>getGroupPush));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_NORMAL_LIST_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getNormalGroupList));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_INFO_REQUEST), DB_PROXY<span style="color:#f92672">::</span>getGroupInfo));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_CREATE_REQUEST), DB_PROXY<span style="color:#f92672">::</span>createGroup));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_GROUP_CHANGE_MEMBER_REQUEST), DB_PROXY<span style="color:#f92672">::</span>modifyMember));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_FILE_HAS_OFFLINE_REQ), DB_PROXY<span style="color:#f92672">::</span>hasOfflineFile));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_FILE_ADD_OFFLINE_REQ), DB_PROXY<span style="color:#f92672">::</span>addOfflineFile));
</span></span><span style="display:flex;"><span>    m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_FILE_DEL_OFFLINE_REQ), DB_PROXY<span style="color:#f92672">::</span>delOfflineFile));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="四启动从mysql同步数据到redis工作">四、启动从mysql同步数据到redis工作</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CSyncCenter<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>init();
</span></span><span style="display:flex;"><span>CSyncCenter<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>startSync();
</span></span></code></pre></div><p>CSyncCenter::getInstance()-&gt;init()是获得上次同步的数据位置，接下来同步从这个位置开始。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 初始化函数，从cache里面加载上次同步的时间信息等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CSyncCenter<span style="color:#f92672">::</span>init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Load total update time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CacheManager<span style="color:#f92672">*</span> pCacheManager <span style="color:#f92672">=</span> CacheManager<span style="color:#f92672">::</span>getInstance();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// increase message count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CacheConn<span style="color:#f92672">*</span> pCacheConn <span style="color:#f92672">=</span> pCacheManager<span style="color:#f92672">-&gt;</span>GetCacheConn(<span style="color:#e6db74">&#34;unread&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pCacheConn)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        string strTotalUpdate <span style="color:#f92672">=</span> pCacheConn<span style="color:#f92672">-&gt;</span>get(<span style="color:#e6db74">&#34;total_user_updated&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        string strLastUpdateGroup <span style="color:#f92672">=</span> pCacheConn<span style="color:#f92672">-&gt;</span>get(<span style="color:#e6db74">&#34;last_update_group&#34;</span>);
</span></span><span style="display:flex;"><span>        pCacheManager<span style="color:#f92672">-&gt;</span>RelCacheConn(pCacheConn);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(strTotalUpdate <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            m_nLastUpdate <span style="color:#f92672">=</span> string2int(strTotalUpdate);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            updateTotalUpdate(time(NULL));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(strLastUpdateGroup.empty())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            m_nLastUpdateGroup <span style="color:#f92672">=</span> string2int(strLastUpdateGroup);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            updateLastUpdateGroup(time(NULL));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;no cache connection to get total_user_updated&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>CSyncCenter::getInstance()-&gt;startSync();新开启一个线程进行同步工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  开启内网数据同步以及群组聊天记录同步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CSyncCenter<span style="color:#f92672">::</span>startSync()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#66d9ef">void</span>)CreateThread(NULL, <span style="color:#ae81ff">0</span>, doSyncGroupChat, NULL, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>m_nGroupChatThreadId);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#66d9ef">void</span>)pthread_create(<span style="color:#f92672">&amp;</span>m_nGroupChatThreadId, NULL, doSyncGroupChat, NULL);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>线程函数doSyncGroupChat()如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  同步群组聊天信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  @param arg NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  @return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> CSyncCenter<span style="color:#f92672">::</span>doSyncGroupChat(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    m_bSyncGroupChatRuning <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    CDBManager<span style="color:#f92672">*</span> pDBManager <span style="color:#f92672">=</span> CDBManager<span style="color:#f92672">::</span>getInstance();
</span></span><span style="display:flex;"><span>    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, <span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;</span> mapChangedGroup;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span>{
</span></span><span style="display:flex;"><span>        mapChangedGroup.clear();
</span></span><span style="display:flex;"><span>        CDBConn<span style="color:#f92672">*</span> pDBConn <span style="color:#f92672">=</span> pDBManager<span style="color:#f92672">-&gt;</span>GetDBConn(<span style="color:#e6db74">&#34;teamtalk_slave&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pDBConn)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            string strSql <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select id, lastChated from IMGroup where status=0 and lastChated &gt;=&#34;</span> <span style="color:#f92672">+</span> int2string(m_pInstance<span style="color:#f92672">-&gt;</span>getLastUpdateGroup());
</span></span><span style="display:flex;"><span>            CResultSet<span style="color:#f92672">*</span> pResult <span style="color:#f92672">=</span> pDBConn<span style="color:#f92672">-&gt;</span>ExecuteQuery(strSql.c_str());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(pResult)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (pResult<span style="color:#f92672">-&gt;</span>Next()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">uint32_t</span> nGroupId <span style="color:#f92672">=</span> pResult<span style="color:#f92672">-&gt;</span>GetInt(<span style="color:#e6db74">&#34;id&#34;</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">uint32_t</span> nLastChat <span style="color:#f92672">=</span> pResult<span style="color:#f92672">-&gt;</span>GetInt(<span style="color:#e6db74">&#34;lastChated&#34;</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>(nLastChat <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        mapChangedGroup[nGroupId] <span style="color:#f92672">=</span> nLastChat;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">delete</span> pResult;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            pDBManager<span style="color:#f92672">-&gt;</span>RelDBConn(pDBConn);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;no db connection for teamtalk_slave&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        m_pInstance<span style="color:#f92672">-&gt;</span>updateLastUpdateGroup(time(NULL));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it<span style="color:#f92672">=</span>mapChangedGroup.begin(); it<span style="color:#f92672">!=</span>mapChangedGroup.end(); <span style="color:#f92672">++</span>it)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">uint32_t</span> nGroupId <span style="color:#f92672">=</span>it<span style="color:#f92672">-&gt;</span>first;
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;</span> lsUsers;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">uint32_t</span> nUpdate <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>            CGroupModel<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>getGroupUser(nGroupId, lsUsers);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it1<span style="color:#f92672">=</span>lsUsers.begin(); it1<span style="color:#f92672">!=</span>lsUsers.end(); <span style="color:#f92672">++</span>it1)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">uint32_t</span> nUserId <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it1;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">uint32_t</span> nSessionId <span style="color:#f92672">=</span> INVALID_VALUE;
</span></span><span style="display:flex;"><span>                nSessionId <span style="color:#f92672">=</span> CSessionModel<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>getSessionId(nUserId, nGroupId, IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SESSION_TYPE_GROUP, true);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(nSessionId <span style="color:#f92672">!=</span> INVALID_VALUE)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    CSessionModel<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>updateSession(nSessionId, nUpdate);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    CSessionModel<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>addSession(nUserId, nGroupId, IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SESSION_TYPE_GROUP);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    } while (!m_pInstance-&gt;m_pCondSync-&gt;waitTime(5*1000));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">while</span> (m_pInstance<span style="color:#f92672">-&gt;</span>m_bSyncGroupChatWaitting <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(m_pInstance<span style="color:#f92672">-&gt;</span>m_pCondGroupChat<span style="color:#f92672">-&gt;</span>waitTime(<span style="color:#ae81ff">5</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1000</span>)));
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    } while(m_pInstance-&gt;m_bSyncGroupChatWaitting);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m_bSyncGroupChatRuning <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到流程就是先用sql从mysql取出数据，再用“sql”写到redis中去。操作mysql和redis时，并没有新建新连接，而是使用上文介绍的连接池和缓存池中已有的连接。我们上文说了，每个池中都有若干个连接，那使用哪个连接呢？由于保存mysql的连接是一个list对象，所以默认从list的头部取一个可用的。如果当前没有空闲连接可用，则新建一个：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CDBConn<span style="color:#f92672">*</span> CDBPool<span style="color:#f92672">::</span>GetDBConn()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_free_notify.Lock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (m_free_list.empty()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (m_db_cur_conn_cnt <span style="color:#f92672">&gt;=</span> m_db_max_conn_cnt) {
</span></span><span style="display:flex;"><span>			m_free_notify.Wait();
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			CDBConn<span style="color:#f92672">*</span> pDBConn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CDBConn(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> pDBConn<span style="color:#f92672">-&gt;</span>Init();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (ret) {
</span></span><span style="display:flex;"><span>				log(<span style="color:#e6db74">&#34;Init DBConnecton failed&#34;</span>);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">delete</span> pDBConn;
</span></span><span style="display:flex;"><span>				m_free_notify.Unlock();
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				m_free_list.push_back(pDBConn);
</span></span><span style="display:flex;"><span>				m_db_cur_conn_cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>				log(<span style="color:#e6db74">&#34;new db connection: %s, conn_cnt: %d&#34;</span>, m_pool_name.c_str(), m_db_cur_conn_cnt);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CDBConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> m_free_list.front();
</span></span><span style="display:flex;"><span>	m_free_list.pop_front();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_free_notify.Unlock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> pConn;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>分配redis和mysql的一模一样，这里代码就不贴了。</p>
<h3 id="五在端口10600上启动侦听监听新连接">五、在端口10600上启动侦听，监听新连接</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CStrExplode listen_ip_list(listen_ip, <span style="color:#e6db74">&#39;;&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> listen_ip_list.GetItemCnt(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> netlib_listen(listen_ip_list.GetItem(i), listen_port, proxy_serv_callback, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> NETLIB_ERROR)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>netlib_listen()创建CBaseSocket对象，并将回调函数指针proxy_serv_callback保存在CBaseSocket对象中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> netlib_listen(
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span>*	server_ip, 
</span></span><span style="display:flex;"><span>		uint16_t	port,
</span></span><span style="display:flex;"><span>		callback_t	callback,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span>*		callback_data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CBaseSocket* pSocket = <span style="color:#66d9ef">new</span> CBaseSocket();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (!pSocket)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_ERROR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret =  pSocket-&gt;Listen(server_ip, port, callback, callback_data);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret == NETLIB_ERROR)
</span></span><span style="display:flex;"><span>		delete pSocket;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>pSocket-&gt;Listen()是实际调用bind()和listen()函数创建侦听的地方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CBaseSocket<span style="color:#f92672">::</span>Listen(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> server_ip, <span style="color:#66d9ef">uint16_t</span> port, callback_t callback, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_local_ip <span style="color:#f92672">=</span> server_ip;
</span></span><span style="display:flex;"><span>	m_local_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>	m_callback <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>	m_callback_data <span style="color:#f92672">=</span> callback_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_socket <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_socket <span style="color:#f92672">==</span> INVALID_SOCKET)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">&#34;socket failed, err_code=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, _GetErrorCode());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_ERROR;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_SetReuseAddr(m_socket);
</span></span><span style="display:flex;"><span>	_SetNonblock(m_socket);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sockaddr_in serv_addr;
</span></span><span style="display:flex;"><span>	_SetAddr(server_ip, port, <span style="color:#f92672">&amp;</span>serv_addr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>bind(m_socket, (sockaddr<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_addr, <span style="color:#66d9ef">sizeof</span>(serv_addr));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> SOCKET_ERROR)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;bind failed, err_code=%d&#34;</span>, _GetErrorCode());
</span></span><span style="display:flex;"><span>		closesocket(m_socket);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_ERROR;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> listen(m_socket, <span style="color:#ae81ff">64</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> SOCKET_ERROR)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;listen failed, err_code=%d&#34;</span>, _GetErrorCode());
</span></span><span style="display:flex;"><span>		closesocket(m_socket);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_ERROR;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_state <span style="color:#f92672">=</span> SOCKET_STATE_LISTENING;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;CBaseSocket::Listen on %s:%d&#34;</span>, server_ip, port);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	AddBaseSocket(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>	CEventDispatch<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>AddEvent(m_socket, SOCKET_READ <span style="color:#f92672">|</span> SOCKET_EXCEP);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NETLIB_OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数有大量的细节需要注意：</p>
<ol>
<li>
<p>socket被设置成非阻塞模式；</p>
</li>
<li>
<p>将绑定的地址设置成reuse（具体原因，我在《服务器编程心得》系列已经介绍过）</p>
</li>
<li>
<p>将socket的状态设置成SOCKET_STATE_LISTENING，这个状态将侦听的socket与普通客户端连接的socket区别开来。</p>
</li>
<li>
<p>AddBaseSocket(this);将socket句柄和对应的CBaseSocket放到一个全局对象中管理起来。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> hash_map<span style="color:#f92672">&lt;</span>net_handle_t, CBaseSocket<span style="color:#f92672">*&gt;</span> SocketMap;
</span></span><span style="display:flex;"><span>SocketMap	g_socket_map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">AddBaseSocket</span>(CBaseSocket<span style="color:#f92672">*</span> pSocket)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	g_socket_map.insert(make_pair((net_handle_t)pSocket<span style="color:#f92672">-&gt;</span>GetSocket(), pSocket));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>之所以不用map而用hash_map是因为STL的map底层是用红黑树实现的，查找时间复杂度是log(n)，而hash_map底层是用hash表存储的，查询时间复杂度是O(1)。后面会介绍将在这个hash_map中查找所有的socket。</p>
<ol start="5">
<li>目前只关注socket的读和异常事件，侦听socket可读意味着有新连接到来，异常就意味着侦听出错。对于服务器程序一般要关闭或重启服务。</li>
</ol>
<h3 id="六主线程进入循环监听新连接的到来以及出来新连接上的数据收发">六、主线程进入循环，监听新连接的到来以及出来新连接上的数据收发</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>netlib_eventloop(<span style="color:#ae81ff">10</span>)
</span></span></code></pre></div><p>10是超时时间，用于select()函数的调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">netlib_eventloop</span>(<span style="color:#66d9ef">uint32_t</span> wait_timeout)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CEventDispatch<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>StartDispatch(wait_timeout);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CEventDispatch<span style="color:#f92672">::</span>StartDispatch(<span style="color:#66d9ef">uint32_t</span> wait_timeout)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	fd_set read_set, write_set, excep_set;
</span></span><span style="display:flex;"><span>	timeval timeout;
</span></span><span style="display:flex;"><span>	timeout.tv_sec <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	timeout.tv_usec <span style="color:#f92672">=</span> wait_timeout <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span>;	<span style="color:#75715e">// 10 millisecond
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(running)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    running <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (running)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		_CheckTimer();
</span></span><span style="display:flex;"><span>        _CheckLoop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_read_set.fd_count <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>m_write_set.fd_count <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>m_excep_set.fd_count)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			Sleep(MIN_TIMER_DURATION);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_lock.lock();
</span></span><span style="display:flex;"><span>		memcpy(<span style="color:#f92672">&amp;</span>read_set, <span style="color:#f92672">&amp;</span>m_read_set, <span style="color:#66d9ef">sizeof</span>(fd_set));
</span></span><span style="display:flex;"><span>		memcpy(<span style="color:#f92672">&amp;</span>write_set, <span style="color:#f92672">&amp;</span>m_write_set, <span style="color:#66d9ef">sizeof</span>(fd_set));
</span></span><span style="display:flex;"><span>		memcpy(<span style="color:#f92672">&amp;</span>excep_set, <span style="color:#f92672">&amp;</span>m_excep_set, <span style="color:#66d9ef">sizeof</span>(fd_set));
</span></span><span style="display:flex;"><span>		m_lock.unlock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nfds <span style="color:#f92672">=</span> select(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>read_set, <span style="color:#f92672">&amp;</span>write_set, <span style="color:#f92672">&amp;</span>excep_set, <span style="color:#f92672">&amp;</span>timeout);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (nfds <span style="color:#f92672">==</span> SOCKET_ERROR)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;select failed, error code: %d&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>			Sleep(MIN_TIMER_DURATION);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;			<span style="color:#75715e">// select again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (nfds <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (u_int i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> read_set.fd_count; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//log(&#34;select return read count=%d\n&#34;, read_set.fd_count);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			SOCKET fd <span style="color:#f92672">=</span> read_set.fd_array[i];
</span></span><span style="display:flex;"><span>			CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket((net_handle_t)fd);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pSocket)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>OnRead();
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (u_int i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> write_set.fd_count; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//log(&#34;select return write count=%d\n&#34;, write_set.fd_count);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			SOCKET fd <span style="color:#f92672">=</span> write_set.fd_array[i];
</span></span><span style="display:flex;"><span>			CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket((net_handle_t)fd);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pSocket)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>OnWrite();
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (u_int i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> excep_set.fd_count; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//log(&#34;select return exception count=%d\n&#34;, excep_set.fd_count);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			SOCKET fd <span style="color:#f92672">=</span> excep_set.fd_array[i];
</span></span><span style="display:flex;"><span>			CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket((net_handle_t)fd);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pSocket)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>OnClose();
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数是整个服务程序的动力和消息泵。我把它简化成如下伪码来重点介绍一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#960050;background-color:#1e0010">退出条件</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//1. 遍历定时器队列，检测是否有定时器事件到期，有则执行定时器的回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//2. 遍历其他任务队列，检测是否有其他任务需要执行，有，执行之
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//3. 检测socket集合，分离可读、可写和异常事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//4. 处理socket可读事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//5. 处理socket可写事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//6. 处理socket异常事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>我们先不说1、2两点，当程序初始化后，socket集合中，也只有一个socket，就是上文中说的侦听socket。当有新连接来的时候，该socket被检测到可读。执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (u_int i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> read_set.fd_count; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//log(&#34;select return read count=%d\n&#34;, read_set.fd_count);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	SOCKET fd <span style="color:#f92672">=</span> read_set.fd_array[i];
</span></span><span style="display:flex;"><span>	CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket((net_handle_t)fd);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pSocket)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>OnRead();
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}	<span style="color:#75715e">//log(&#34;select return read count=%d\n&#34;, read_set.fd_count);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	SOCKET fd <span style="color:#f92672">=</span> read_set.fd_array[i];
</span></span><span style="display:flex;"><span>	CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket((net_handle_t)fd);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pSocket)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>OnRead();
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>FindBaseSocket()就是在上文提到的socket集合map中通过句柄查找socket：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CBaseSocket<span style="color:#f92672">*</span> <span style="color:#a6e22e">FindBaseSocket</span>(net_handle_t fd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	SocketMap<span style="color:#f92672">::</span>iterator iter <span style="color:#f92672">=</span> g_socket_map.find(fd);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (iter <span style="color:#f92672">!=</span> g_socket_map.end())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		pSocket <span style="color:#f92672">=</span> iter<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>AddRef();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> pSocket;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着执行pSocket-&gt;OnRead():</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CBaseSocket<span style="color:#f92672">::</span>OnRead()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_state <span style="color:#f92672">==</span> SOCKET_STATE_LISTENING)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		_AcceptNewSocket();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		u_long avail <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( (ioctlsocket(m_socket, FIONREAD, <span style="color:#f92672">&amp;</span>avail) <span style="color:#f92672">==</span> SOCKET_ERROR) <span style="color:#f92672">||</span> (avail <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为是侦听socket，其状态被设置成SOCKET_STATE_LISTENING(上文介绍了)。接着就接受新连接。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CBaseSocket<span style="color:#f92672">::</span>_AcceptNewSocket()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	SOCKET fd <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	sockaddr_in peer_addr;
</span></span><span style="display:flex;"><span>	socklen_t addr_len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(sockaddr_in);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> ip_str[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> ( (fd <span style="color:#f92672">=</span> accept(m_socket, (sockaddr<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>peer_addr, <span style="color:#f92672">&amp;</span>addr_len)) <span style="color:#f92672">!=</span> INVALID_SOCKET )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CBaseSocket();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint32_t</span> ip <span style="color:#f92672">=</span> ntohl(peer_addr.sin_addr.s_addr);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint16_t</span> port <span style="color:#f92672">=</span> ntohs(peer_addr.sin_port);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		snprintf(ip_str, <span style="color:#66d9ef">sizeof</span>(ip_str), <span style="color:#e6db74">&#34;%d.%d.%d.%d&#34;</span>, ip <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">24</span>, (ip <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFF</span>, (ip <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFF</span>, ip <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFF</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;AcceptNewSocket, socket=%d from %s:%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, fd, ip_str, port);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>SetSocket(fd);
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>SetCallback(m_callback);
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>SetCallbackData(m_callback_data);
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>SetState(SOCKET_STATE_CONNECTED);
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>SetRemoteIP(ip_str);
</span></span><span style="display:flex;"><span>		pSocket<span style="color:#f92672">-&gt;</span>SetRemotePort(port);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		_SetNoDelay(fd);
</span></span><span style="display:flex;"><span>		_SetNonblock(fd);
</span></span><span style="display:flex;"><span>		AddBaseSocket(pSocket);
</span></span><span style="display:flex;"><span>		CEventDispatch<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>AddEvent(fd, SOCKET_READ <span style="color:#f92672">|</span> SOCKET_EXCEP);
</span></span><span style="display:flex;"><span>		m_callback(m_callback_data, NETLIB_MSG_CONNECT, (net_handle_t)fd, NULL);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接收新连接，需要注意以下事项：</p>
<ol>
<li>
<p>产生一个新的socket和对应的CBaseSocket对象。</p>
</li>
<li>
<p>该socket和对应的CBaseSocket对象和侦听socket一样也被加入全局g_socket_map中进行管理。</p>
</li>
<li>
<p>新socket同样被设置成非阻塞的。</p>
</li>
<li>
<p>禁用该socket的nagle算法（_SetNoDelay(fd);）。</p>
</li>
<li>
<p>关注该socket的读和异常事件（CEventDispatch::Instance()-&gt;AddEvent(fd, SOCKET_READ | SOCKET_EXCEP);）。</p>
</li>
<li>
<p>将socket的状态设置成SOCKET_STATE_CONNECTED。</p>
</li>
<li>
<p>调用侦听socket的的回调函数m_callback(m_callback_data, NETLIB_MSG_CONNECT, (net_handle_t)fd, NULL)，并传入消息类型是NETLIB_MSG_CONNECT。</p>
</li>
</ol>
<p>这个回调函数在上面初始化侦听函数设置的，指向函数proxy_serv_callback。调用代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">proxy_serv_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (msg <span style="color:#f92672">==</span> NETLIB_MSG_CONNECT)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        CProxyConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CProxyConn();
</span></span><span style="display:flex;"><span>        pConn<span style="color:#f92672">-&gt;</span>OnConnect(handle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;!!!error msg: %d&#34;</span>, msg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着调用CProxyConn的OnConnect()函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CProxyConn<span style="color:#f92672">::</span>OnConnect(net_handle_t handle)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_handle <span style="color:#f92672">=</span> handle;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	g_proxy_conn_map.insert(make_pair(handle, <span style="color:#66d9ef">this</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	netlib_option(handle, NETLIB_OPT_SET_CALLBACK, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)imconn_callback);
</span></span><span style="display:flex;"><span>	netlib_option(handle, NETLIB_OPT_SET_CALLBACK_DATA, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>g_proxy_conn_map);
</span></span><span style="display:flex;"><span>	netlib_option(handle, NETLIB_OPT_GET_REMOTE_IP, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>m_peer_ip);
</span></span><span style="display:flex;"><span>	netlib_option(handle, NETLIB_OPT_GET_REMOTE_PORT, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>m_peer_port);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;connect from %s:%d, handle=%d&#34;</span>, m_peer_ip.c_str(), m_peer_port, m_handle);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意！这里，已经悄悄地将该新socket的回调函数由proxy_serv_callback偷偷地换成了imconn_callback。同时，将该连接对象放入一个全局map g_proxy_conn_map中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> hash_map<span style="color:#f92672">&lt;</span>net_handle_t, CImConn<span style="color:#f92672">*&gt;</span> ConnMap_t;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> ConnMap_t g_proxy_conn_map;
</span></span></code></pre></div><p>同样，该map的key是socket句柄，value是连接对象基类的指针。</p>
<p>至此，对于侦听socket，如果socket可读，则接收新连接，并置换其默认OnRead的回调函数为imconn_callback；而对于新socket，如果socket可读，则会调用imconn_callback。</p>
<p>我们接着看新socket可读的处理流程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CBaseSocket<span style="color:#f92672">::</span>OnRead()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_state <span style="color:#f92672">==</span> SOCKET_STATE_LISTENING)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		_AcceptNewSocket();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		u_long avail <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( (ioctlsocket(m_socket, FIONREAD, <span style="color:#f92672">&amp;</span>avail) <span style="color:#f92672">==</span> SOCKET_ERROR) <span style="color:#f92672">||</span> (avail <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述OnRead函数会走else分支，先调用ioctlsocket获得可读的数据字节数。如果出错或者字节数为0，则以消息NETLIB_MSG_CLOSE调用回调函数imconn_callback,</p>
<p>反之，以消息NETLIB_MSG_READ调用回调函数imconn_callback。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">imconn_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	NOTUSED_ARG(handle);
</span></span><span style="display:flex;"><span>	NOTUSED_ARG(pParam);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>callback_data)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ConnMap_t<span style="color:#f92672">*</span> conn_map <span style="color:#f92672">=</span> (ConnMap_t<span style="color:#f92672">*</span>)callback_data;
</span></span><span style="display:flex;"><span>	CImConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> FindImConn(conn_map, handle);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pConn)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//log(&#34;msg=%d, handle=%d &#34;, msg, handle);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (msg)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_CONFIRM:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnConfirm();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_READ:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnRead();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_WRITE:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnWrite();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_CLOSE:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnClose();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;!!!imconn_callback error msg: %d &#34;</span>, msg);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pConn<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>出错消息NETLIB_MSG_CLOSE没啥好看的，无非是关闭连接。我们来看NETLIB_MSG_READ消息，会调用pConn-&gt;OnRead()，pConn是一个CImConn指针，但根据上文介绍我们知道，其实际是一个CImConn的子类CProxyConn对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CProxyConn</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> CImConn {
</span></span></code></pre></div><p>所以pConn-&gt;OnRead()实际会调用CProxyConn的OnRead()：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CProxyConn<span style="color:#f92672">::</span>OnRead()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint32_t</span> free_buf_len <span style="color:#f92672">=</span> m_in_buf.GetAllocSize() <span style="color:#f92672">-</span> m_in_buf.GetWriteOffset();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (free_buf_len <span style="color:#f92672">&lt;</span> READ_BUF_SIZE)
</span></span><span style="display:flex;"><span>			m_in_buf.Extend(READ_BUF_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> netlib_recv(m_handle, m_in_buf.GetBuffer() <span style="color:#f92672">+</span> m_in_buf.GetWriteOffset(), READ_BUF_SIZE);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_recv_bytes <span style="color:#f92672">+=</span> ret;
</span></span><span style="display:flex;"><span>		m_in_buf.IncWriteOffset(ret);
</span></span><span style="display:flex;"><span>		m_last_recv_tick <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> pdu_len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> ( CImPdu<span style="color:#f92672">::</span>IsPduAvailable(m_in_buf.GetBuffer(), m_in_buf.GetWriteOffset(), pdu_len) ) {
</span></span><span style="display:flex;"><span>            HandlePduBuf(m_in_buf.GetBuffer(), pdu_len);
</span></span><span style="display:flex;"><span>            m_in_buf.Read(NULL, pdu_len);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (CPduException<span style="color:#f92672">&amp;</span> ex) {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;!!!catch exception, err_code=%u, err_msg=%s, close the connection &#34;</span>,
</span></span><span style="display:flex;"><span>            ex.GetErrorCode(), ex.GetErrorMsg());
</span></span><span style="display:flex;"><span>        OnClose();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>CImConn实际是代表一个连接，即每一个连接都有这样一个对象。具体被分化成它的各个子对象，如CProxyConn。每一个连接CImConn都存在一个读缓冲区和写缓冲区，读缓冲区用于存放从网络上收取的数据，写缓冲区用于存放即将发到网络中数据。CProxyConn::OnRead()先检测该对象的读缓冲区中还有多少可用空间，如果可用空间小于当前收到的字节数目，则将该读缓冲区的大小扩展到需要的大小READ_BUF_SIZE。接着收到的数据放入读缓冲区中。并记录下这次收取数据的时间到m_last_recv_tick变量中。接着开始解包，即调用CImPdu::IsPduAvailable()从读取缓冲区中取出数据处理，先判断现有数据是否大于一个包头的大小，如果不大于，退出。如果大于一个包头的大小，则接着根据包头中的信息得到整个包的大小：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> CImPdu<span style="color:#f92672">::</span>IsPduAvailable(uchar_t<span style="color:#f92672">*</span> buf, <span style="color:#66d9ef">uint32_t</span> len, <span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&amp;</span> pdu_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (len <span style="color:#f92672">&lt;</span> IM_PDU_HEADER_LEN)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pdu_len <span style="color:#f92672">=</span> CByteStream<span style="color:#f92672">::</span>ReadUint32(buf);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pdu_len <span style="color:#f92672">&gt;</span> len)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//log(&#34;pdu_len=%d, len=%d\n&#34;, pdu_len, len);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> pdu_len)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">CPduException</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;pdu_len is 0&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>得到包的大小就可以正式处理包了，调用HandlePduBuf(m_in_buf.GetBuffer(), pdu_len);</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CProxyConn<span style="color:#f92672">::</span>HandlePduBuf(uchar_t<span style="color:#f92672">*</span> pdu_buf, <span style="color:#66d9ef">uint32_t</span> pdu_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    CImPdu<span style="color:#f92672">*</span> pPdu <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    pPdu <span style="color:#f92672">=</span> CImPdu<span style="color:#f92672">::</span>ReadPdu(pdu_buf, pdu_len);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pPdu<span style="color:#f92672">-&gt;</span>GetCommandId() <span style="color:#f92672">==</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_OTHER_HEARTBEAT) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    pdu_handler_t handler <span style="color:#f92672">=</span> s_handler_map<span style="color:#f92672">-&gt;</span>GetHandler(pPdu<span style="color:#f92672">-&gt;</span>GetCommandId());
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (handler) {
</span></span><span style="display:flex;"><span>        CTask<span style="color:#f92672">*</span> pTask <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CProxyTask(m_uuid, handler, pPdu);
</span></span><span style="display:flex;"><span>        g_thread_pool.AddTask(pTask);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;no handler for packet type: %d&#34;</span>, pPdu<span style="color:#f92672">-&gt;</span>GetCommandId());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>包的数据结构是CImPdu（Im 即Instant Message即时通讯软件的意思，teamtalk本来就是一款即时通讯，pdu，Protocol Data Unit 协议数据单元，通俗的说就是一个包单位），该数据结构分为包头和包体两部分。类CImPdu的两个成员变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CSimpleBuffer	m_buf;
</span></span><span style="display:flex;"><span>PduHeader_t      m_pdu_header;
</span></span></code></pre></div><p>分别表示包头和包体，包头的定义PduHeader_t如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> 	length;		  <span style="color:#75715e">// the whole pdu length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span> 	version;	  <span style="color:#75715e">// pdu version number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span>	flag;		  <span style="color:#75715e">// not used
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span>	service_id;	  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span>	command_id;	  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span>	seq_num;     <span style="color:#75715e">// 包序号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span>    reversed;    <span style="color:#75715e">// 保留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} PduHeader_t;
</span></span></code></pre></div><p>通过包头的command_id就知道该包是什么数据了。接着根据对应的命令号调用在程序初始化阶段绑定的包处理函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>pdu_handler_t handler <span style="color:#f92672">=</span> s_handler_map<span style="color:#f92672">-&gt;</span>GetHandler(pPdu<span style="color:#f92672">-&gt;</span>GetCommandId());
</span></span></code></pre></div><p>执行处理函数不是直接调用该函数，而是包装成一个任务放入前面介绍的任务队列中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>du_handler_t handler <span style="color:#f92672">=</span> s_handler_map<span style="color:#f92672">-&gt;</span>GetHandler(pPdu<span style="color:#f92672">-&gt;</span>GetCommandId());
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (handler) {
</span></span><span style="display:flex;"><span>        CTask<span style="color:#f92672">*</span> pTask <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CProxyTask(m_uuid, handler, pPdu);
</span></span><span style="display:flex;"><span>        g_thread_pool.AddTask(pTask);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;no handler for packet type: %d&#34;</span>, pPdu<span style="color:#f92672">-&gt;</span>GetCommandId());
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>前面介绍过，处理任务的线程可能有多个，那么到底将任务加入到哪个工作线程呢？这里采取的策略是随机分配：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CThreadPool<span style="color:#f92672">::</span>AddTask(CTask<span style="color:#f92672">*</span> pTask)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * select a random thread to push task
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * we can also select a thread that has less task to do
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * but that will scan the whole thread list and use thread lock to get each task size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> thread_idx <span style="color:#f92672">=</span> random() <span style="color:#f92672">%</span> m_worker_size;
</span></span><span style="display:flex;"><span>	m_worker_list[thread_idx].PushTask(pTask);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当然需要注意的是。如果数据包是心跳包的话，就直接不处理了。因为心跳包只是来保活通信的，与具体业务无关：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (pPdu<span style="color:#f92672">-&gt;</span>GetCommandId() <span style="color:#f92672">==</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_OTHER_HEARTBEAT) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>该包处理完成以后，将该包的数据从连接的读缓冲区移除：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>m_in_buf.Read(NULL, pdu_len);
</span></span></code></pre></div><p>接着继续处理下一个包，因为收来的数据可能不够一个包大小，也可能是多个包的大小，所以要放在一个循环里面解包处理，直到读缓冲区中无数据或数据不够一个包的大小。</p>
<p>我们将这个流程抽象出来，这个流程也是现在所有网络通信库都要做的工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#960050;background-color:#1e0010">退出条件</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//1. 检测非侦听socket可读
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//2. 处理可读事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//3. 检测可读取的字节数，出错就关闭，不出错，将收取的字节放入连接的读缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//循环做以下处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//4. 检测可读缓冲区数据大小是否大于等于一个包头大小: 否，数据不够一个包，跳出该循环;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	  是，从包头中得到一个包体的大小，检测读缓冲区是否够一个包头+包体的大小；否，数据不够一个包，跳出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	  是，解包，根据包命令号，处理该包数据，可以产生一个任务，丢入任务队列。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	  从可读缓冲区中移除刚才处理的包数据的字节数目。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	  继续第4步。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>当加入任务后，任务队列线程被唤醒，从任务队列的头部拿出该任务执行。这个上文介绍过了。</p>
<p>到此，本文还没有完，因为上文只介绍了从客户端收取数据，然后解包。并没有介绍解完包，调用处理函数处理后如何应答客户端。下面以一个登录数据包的应答来叙述这个应答流程。登录任务从任务队列中取出来后，执行如下函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CHandlerMap<span style="color:#f92672">::</span>Init()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//DB_PROXY是命名空间，不是类名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Login validate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	m_handler_map.insert(make_pair(<span style="color:#66d9ef">uint32_t</span>(CID_OTHER_VALIDATE_REQ), DB_PROXY<span style="color:#f92672">::</span>doLogin));
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doLogin</span>(CImPdu<span style="color:#f92672">*</span> pPdu, <span style="color:#66d9ef">uint32_t</span> conn_uuid)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    CImPdu<span style="color:#f92672">*</span> pPduResp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CImPdu;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMValidateReq msg;
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMValidateRsp msgResp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(msg.ParseFromArray(pPdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pPdu<span style="color:#f92672">-&gt;</span>GetBodyLength()))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        string strDomain <span style="color:#f92672">=</span> msg.user_name();
</span></span><span style="display:flex;"><span>        string strPass <span style="color:#f92672">=</span> msg.password();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        msgResp.set_user_name(strDomain);
</span></span><span style="display:flex;"><span>        msgResp.set_attach_data(msg.attach_data());
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            CAutoLock cAutoLock(<span style="color:#f92672">&amp;</span>g_cLimitLock);
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;&amp;</span> lsErrorTime <span style="color:#f92672">=</span> g_hmLimits[strDomain];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">uint32_t</span> tmNow <span style="color:#f92672">=</span> time(NULL);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//清理超过30分钟的错误时间点记录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             清理放在这里还是放在密码错误后添加的时候呢？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             放在这里，每次都要遍历，会有一点点性能的损失。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             放在后面，可能会造成30分钟之前有10次错的，但是本次是对的就没办法再访问了。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> itTime<span style="color:#f92672">=</span>lsErrorTime.begin();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(; itTime<span style="color:#f92672">!=</span>lsErrorTime.end();<span style="color:#f92672">++</span>itTime)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(tmNow <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>itTime <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">30</span><span style="color:#f92672">*</span><span style="color:#ae81ff">60</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(itTime <span style="color:#f92672">!=</span> lsErrorTime.end())
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                lsErrorTime.erase(itTime, lsErrorTime.end());
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 判断30分钟内密码错误次数是否大于10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(lsErrorTime.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                itTime <span style="color:#f92672">=</span> lsErrorTime.begin();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(tmNow <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>itTime <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">30</span><span style="color:#f92672">*</span><span style="color:#ae81ff">60</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    msgResp.set_result_code(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>                    msgResp.set_result_string(<span style="color:#e6db74">&#34;用户名/密码错误次数太多&#34;</span>);
</span></span><span style="display:flex;"><span>                    pPduResp<span style="color:#f92672">-&gt;</span>SetPBMsg(<span style="color:#f92672">&amp;</span>msgResp);
</span></span><span style="display:flex;"><span>                    pPduResp<span style="color:#f92672">-&gt;</span>SetSeqNum(pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>                    pPduResp<span style="color:#f92672">-&gt;</span>SetServiceId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SID_OTHER);
</span></span><span style="display:flex;"><span>                    pPduResp<span style="color:#f92672">-&gt;</span>SetCommandId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_OTHER_VALIDATE_RSP);
</span></span><span style="display:flex;"><span>                    CProxyConn<span style="color:#f92672">::</span>AddResponsePdu(conn_uuid, pPduResp);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> ;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">while</span>(false);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;%s request login.&#34;</span>, strDomain.c_str());
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>UserInfo cUser;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(g_loginStrategy.doLogin(strDomain, strPass, cUser))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>UserInfo<span style="color:#f92672">*</span> pUser <span style="color:#f92672">=</span> msgResp.mutable_user_info();
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_user_id(cUser.user_id());
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_user_gender(cUser.user_gender());
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_department_id(cUser.department_id());
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_user_nick_name(cUser.user_nick_name());
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_user_domain(cUser.user_domain());
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_avatar_url(cUser.avatar_url());
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_email(cUser.email());
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_user_tel(cUser.user_tel());
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_user_real_name(cUser.user_real_name());
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_status(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            pUser<span style="color:#f92672">-&gt;</span>set_sign_info(cUser.sign_info());
</span></span><span style="display:flex;"><span>           
</span></span><span style="display:flex;"><span>            msgResp.set_result_code(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>            msgResp.set_result_string(<span style="color:#e6db74">&#34;成功&#34;</span>);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果登陆成功，则清除错误尝试限制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            CAutoLock cAutoLock(<span style="color:#f92672">&amp;</span>g_cLimitLock);
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;&amp;</span> lsErrorTime <span style="color:#f92672">=</span> g_hmLimits[strDomain];
</span></span><span style="display:flex;"><span>            lsErrorTime.clear();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//密码错误，记录一次登陆失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">uint32_t</span> tmCurrent <span style="color:#f92672">=</span> time(NULL);
</span></span><span style="display:flex;"><span>            CAutoLock cAutoLock(<span style="color:#f92672">&amp;</span>g_cLimitLock);
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;&amp;</span> lsErrorTime <span style="color:#f92672">=</span> g_hmLimits[strDomain];
</span></span><span style="display:flex;"><span>            lsErrorTime.push_front(tmCurrent);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;get result false&#34;</span>);
</span></span><span style="display:flex;"><span>            msgResp.set_result_code(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            msgResp.set_result_string(<span style="color:#e6db74">&#34;用户名/密码错误&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        msgResp.set_result_code(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        msgResp.set_result_string(<span style="color:#e6db74">&#34;服务端内部错误&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    pPduResp<span style="color:#f92672">-&gt;</span>SetPBMsg(<span style="color:#f92672">&amp;</span>msgResp);
</span></span><span style="display:flex;"><span>    pPduResp<span style="color:#f92672">-&gt;</span>SetSeqNum(pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>    pPduResp<span style="color:#f92672">-&gt;</span>SetServiceId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SID_OTHER);
</span></span><span style="display:flex;"><span>    pPduResp<span style="color:#f92672">-&gt;</span>SetCommandId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_OTHER_VALIDATE_RSP);
</span></span><span style="display:flex;"><span>    CProxyConn<span style="color:#f92672">::</span>AddResponsePdu(conn_uuid, pPduResp);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段代码有点复杂，下面分析之：</p>
<p>首先，将登录请求包数据通过函数参数（第一个参数）传入进来，其次是连接对象的id。前面已经介绍过了，每一个新的socket不仅对应一个CBaseSocket对象，同时也对应一个连接对象CImConn（可能会被具体化成对应的子类，如CProxyConn）。这些连接对象被放在另外一个全局map g_proxy_conn_map里面进行管理。</p>
<p>通过包数据，我们能得到登录的用户名和密码等信息。接着检测30分钟之内，尝试登录的次数，如果30分钟之内密码错误次数超过10此。则不允许登录。组成一个提示“用户名或密码错误此时太多”的包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>msgResp.set_result_code(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>msgResp.set_result_string(<span style="color:#e6db74">&#34;用户名/密码错误次数太多&#34;</span>);
</span></span><span style="display:flex;"><span>pPduResp<span style="color:#f92672">-&gt;</span>SetPBMsg(<span style="color:#f92672">&amp;</span>msgResp);
</span></span><span style="display:flex;"><span>pPduResp<span style="color:#f92672">-&gt;</span>SetSeqNum(pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>pPduResp<span style="color:#f92672">-&gt;</span>SetServiceId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SID_OTHER);
</span></span><span style="display:flex;"><span>pPduResp<span style="color:#f92672">-&gt;</span>SetCommandId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_OTHER_VALIDATE_RSP);
</span></span><span style="display:flex;"><span>CProxyConn<span style="color:#f92672">::</span>AddResponsePdu(conn_uuid, pPduResp);
</span></span></code></pre></div><p>如果不存在这种情况，则接着调用g_loginStrategy.doLogin(strDomain, strPass, cUser)连接数据库进行用户名和密码校验：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> CInterLoginStrategy<span style="color:#f92672">::</span>doLogin(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>strName, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>strPass, IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>UserInfo<span style="color:#f92672">&amp;</span> user)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> bRet <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    CDBManager<span style="color:#f92672">*</span> pDBManger <span style="color:#f92672">=</span> CDBManager<span style="color:#f92672">::</span>getInstance();
</span></span><span style="display:flex;"><span>    CDBConn<span style="color:#f92672">*</span> pDBConn <span style="color:#f92672">=</span> pDBManger<span style="color:#f92672">-&gt;</span>GetDBConn(<span style="color:#e6db74">&#34;teamtalk_slave&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pDBConn) {
</span></span><span style="display:flex;"><span>        string strSql <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select * from IMUser where name=&#39;&#34;</span> <span style="color:#f92672">+</span> strName <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39; and status=0&#34;</span>;
</span></span><span style="display:flex;"><span>        CResultSet<span style="color:#f92672">*</span> pResultSet <span style="color:#f92672">=</span> pDBConn<span style="color:#f92672">-&gt;</span>ExecuteQuery(strSql.c_str());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pResultSet)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            string strResult, strSalt;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">uint32_t</span> nId, nGender, nDeptId, nStatus;
</span></span><span style="display:flex;"><span>            string strNick, strAvatar, strEmail, strRealName, strTel, strDomain,strSignInfo;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (pResultSet<span style="color:#f92672">-&gt;</span>Next()) {
</span></span><span style="display:flex;"><span>                nId <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetInt(<span style="color:#e6db74">&#34;id&#34;</span>);
</span></span><span style="display:flex;"><span>                strResult <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;password&#34;</span>);
</span></span><span style="display:flex;"><span>                strSalt <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;salt&#34;</span>);
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                strNick <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;nick&#34;</span>);
</span></span><span style="display:flex;"><span>                nGender <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetInt(<span style="color:#e6db74">&#34;sex&#34;</span>);
</span></span><span style="display:flex;"><span>                strRealName <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;name&#34;</span>);
</span></span><span style="display:flex;"><span>                strDomain <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;domain&#34;</span>);
</span></span><span style="display:flex;"><span>                strTel <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;phone&#34;</span>);
</span></span><span style="display:flex;"><span>                strEmail <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;email&#34;</span>);
</span></span><span style="display:flex;"><span>                strAvatar <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;avatar&#34;</span>);
</span></span><span style="display:flex;"><span>                nDeptId <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetInt(<span style="color:#e6db74">&#34;departId&#34;</span>);
</span></span><span style="display:flex;"><span>                nStatus <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetInt(<span style="color:#e6db74">&#34;status&#34;</span>);
</span></span><span style="display:flex;"><span>                strSignInfo <span style="color:#f92672">=</span> pResultSet<span style="color:#f92672">-&gt;</span>GetString(<span style="color:#e6db74">&#34;sign_info&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            string strInPass <span style="color:#f92672">=</span> strPass <span style="color:#f92672">+</span> strSalt;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> szMd5[<span style="color:#ae81ff">33</span>];
</span></span><span style="display:flex;"><span>            CMd5<span style="color:#f92672">::</span>MD5_Calculate(strInPass.c_str(), strInPass.length(), szMd5);
</span></span><span style="display:flex;"><span>            string <span style="color:#a6e22e">strOutPass</span>(szMd5);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//去掉密码校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//if(strOutPass == strResult)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                bRet <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                user.set_user_id(nId);
</span></span><span style="display:flex;"><span>                user.set_user_nick_name(strNick);
</span></span><span style="display:flex;"><span>                user.set_user_gender(nGender);
</span></span><span style="display:flex;"><span>                user.set_user_real_name(strRealName);
</span></span><span style="display:flex;"><span>                user.set_user_domain(strDomain);
</span></span><span style="display:flex;"><span>                user.set_user_tel(strTel);
</span></span><span style="display:flex;"><span>                user.set_email(strEmail);
</span></span><span style="display:flex;"><span>                user.set_avatar_url(strAvatar);
</span></span><span style="display:flex;"><span>                user.set_department_id(nDeptId);
</span></span><span style="display:flex;"><span>                user.set_status(nStatus);
</span></span><span style="display:flex;"><span>  	        user.set_sign_info(strSignInfo);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span>  pResultSet;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pDBManger<span style="color:#f92672">-&gt;</span>RelDBConn(pDBConn);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bRet;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里也需要一个mysql连接，这个连接的分配方式在前面介绍过了。即在连接池中随机拿一个，如果池中不存在，则新建一个。用完还回去：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>pDBManger<span style="color:#f92672">-&gt;</span>RelDBConn(pDBConn);
</span></span></code></pre></div><p>接着通过用户名从数据库中取出该用户信息，如果记录存在，则接着校验密码。密码在数据库里面的存储形式是：密码+用户的salt值 组成的字符串的md5值。密码如果也校验正确，组装成一个正确应答数据包（附上命令号、序列号、提示信息等）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>pPduResp<span style="color:#f92672">-&gt;</span>SetPBMsg(<span style="color:#f92672">&amp;</span>msgResp);
</span></span><span style="display:flex;"><span>    pPduResp<span style="color:#f92672">-&gt;</span>SetSeqNum(pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>    pPduResp<span style="color:#f92672">-&gt;</span>SetServiceId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SID_OTHER);
</span></span><span style="display:flex;"><span>    pPduResp<span style="color:#f92672">-&gt;</span>SetCommandId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_OTHER_VALIDATE_RSP);
</span></span><span style="display:flex;"><span>    CProxyConn<span style="color:#f92672">::</span>AddResponsePdu(conn_uuid, pPduResp);
</span></span></code></pre></div><p>现在不管登录成功与否，登录应答包也已经组装好了。接下来，就是如何发出去了？上述代码最后一行：</p>
<pre tabindex="0"><code>CProxyConn::AddResponsePdu(conn_uuid, pPduResp)
</code></pre><p>其调用如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CProxyConn<span style="color:#f92672">::</span>AddResponsePdu(<span style="color:#66d9ef">uint32_t</span> conn_uuid, CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	ResponsePdu_t<span style="color:#f92672">*</span> pResp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ResponsePdu_t;
</span></span><span style="display:flex;"><span>	pResp<span style="color:#f92672">-&gt;</span>conn_uuid <span style="color:#f92672">=</span> conn_uuid;
</span></span><span style="display:flex;"><span>	pResp<span style="color:#f92672">-&gt;</span>pPdu <span style="color:#f92672">=</span> pPdu;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	s_list_lock.lock();
</span></span><span style="display:flex;"><span>	s_response_pdu_list.push_back(pResp);
</span></span><span style="display:flex;"><span>	s_list_lock.unlock();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们这里并没有直接将应答数据包通过连接对象CProxyConn发出去。因为直接发出去，未必能发出去。这会导致程序阻塞。（原因是：对方的tcp窗口太小，导致tcp窗口太小的常见原因是：对方无法收包或不及时收包，数据积压在对方网络协议栈里面）。我们这里是将应答数据包放入连接对象的一个应答链表s_response_pdu_list中。这是一个stl list容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> list<span style="color:#f92672">&lt;</span>ResponsePdu_t<span style="color:#f92672">*&gt;</span>	s_response_pdu_list;	<span style="color:#75715e">// 主线程发送回复消息
</span></span></span></code></pre></div><p>那么，包在这个链表中，何时被发出去呢？我们在介绍该服务的消息泵时介绍到如下流程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#960050;background-color:#1e0010">退出条件</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//1. 遍历定时器队列，检测是否有定时器事件到期，有则执行定时器的回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//2. 遍历其他任务队列，检测是否有其他任务需要执行，有，执行之
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//3. 检测socket集合，分离可读、可写和异常事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//4. 处理socket可读事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//5. 处理socket可写事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//6. 处理socket异常事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>注意第2步：遍历其他任务队列，检测是否有其他任务需要执行，有，执行之。我们来看看这步具体做了什么。</p>
<p>在main函数里面初始化任务队列线程时，同时也创建了一个其他任务：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>init_proxy_conn(thread_num);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">init_proxy_conn</span>(<span style="color:#66d9ef">uint32_t</span> thread_num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	s_handler_map <span style="color:#f92672">=</span> CHandlerMap<span style="color:#f92672">::</span>getInstance();
</span></span><span style="display:flex;"><span>	g_thread_pool.Init(thread_num);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	netlib_add_loop(proxy_loop_callback, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	signal(SIGTERM, sig_handler);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> netlib_register_timer(proxy_timer_callback, NULL, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意代码netlib_add_loop(proxy_loop_callback, NULL);该行加入了一个其他任务到其他任务队列。这样在主线程的消息泵中：2. 遍历其他任务队列，检测是否有其他任务需要执行，有，执行之。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>_CheckLoop();
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CEventDispatch<span style="color:#f92672">::</span>_CheckLoop()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span>TimerItem<span style="color:#f92672">*&gt;::</span>iterator it <span style="color:#f92672">=</span> m_loop_list.begin(); it <span style="color:#f92672">!=</span> m_loop_list.end(); it<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        TimerItem<span style="color:#f92672">*</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it;
</span></span><span style="display:flex;"><span>        pItem<span style="color:#f92672">-&gt;</span>callback(pItem<span style="color:#f92672">-&gt;</span>user_data, NETLIB_MSG_LOOP, <span style="color:#ae81ff">0</span>, NULL);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其他任务的回调函数目前只有一个，就是上面设置的proxy_loop_callback：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">proxy_loop_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CProxyConn<span style="color:#f92672">::</span>SendResponsePduList();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CProxyConn<span style="color:#f92672">::</span>SendResponsePduList()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	s_list_lock.lock();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>s_response_pdu_list.empty()) {
</span></span><span style="display:flex;"><span>		ResponsePdu_t<span style="color:#f92672">*</span> pResp <span style="color:#f92672">=</span> s_response_pdu_list.front();
</span></span><span style="display:flex;"><span>		s_response_pdu_list.pop_front();
</span></span><span style="display:flex;"><span>		s_list_lock.unlock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		CProxyConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> get_proxy_conn_by_uuid(pResp<span style="color:#f92672">-&gt;</span>conn_uuid);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (pConn) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pResp<span style="color:#f92672">-&gt;</span>pPdu) {
</span></span><span style="display:flex;"><span>				pConn<span style="color:#f92672">-&gt;</span>SendPdu(pResp<span style="color:#f92672">-&gt;</span>pPdu);
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				log(<span style="color:#e6db74">&#34;close connection uuid=%d by parse pdu error</span><span style="color:#ae81ff">\b</span><span style="color:#e6db74">&#34;</span>, pResp<span style="color:#f92672">-&gt;</span>conn_uuid);
</span></span><span style="display:flex;"><span>				pConn<span style="color:#f92672">-&gt;</span>Close();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (pResp<span style="color:#f92672">-&gt;</span>pPdu)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">delete</span> pResp<span style="color:#f92672">-&gt;</span>pPdu;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">delete</span> pResp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		s_list_lock.lock();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	s_list_lock.unlock();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>看到这里，你应该明白了。原来应答数据包在这里从list中取出来。然后调用pConn-&gt;SendPdu(pResp-&gt;pPdu)“发出去”。这里需要解释两个问题：第一个就是一般服务器端会有多个连接对象，那么如何定位某个应答数据包对应的连接对象呢？这里就通过数据包本身的conn_uuid来确定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CProxyConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> get_proxy_conn_by_uuid(pResp<span style="color:#f92672">-&gt;</span>conn_uuid);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CProxyConn<span style="color:#f92672">*</span> <span style="color:#a6e22e">get_proxy_conn_by_uuid</span>(<span style="color:#66d9ef">uint32_t</span> uuid)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CProxyConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	UserMap_t<span style="color:#f92672">::</span>iterator it <span style="color:#f92672">=</span> g_uuid_conn_map.find(uuid);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> g_uuid_conn_map.end()) {
</span></span><span style="display:flex;"><span>		pConn <span style="color:#f92672">=</span> (CProxyConn <span style="color:#f92672">*</span>)it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> pConn;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>全局对象g_uuid_conn_map里面存的是uuid与连接对象的对应关系。这个关系何时存入到这个全局g_uuid_conn_map对象的呢？在CProxyConn的构造函数中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CProxyConn<span style="color:#f92672">::</span>CProxyConn()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_uuid <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>CProxyConn<span style="color:#f92672">::</span>s_uuid_alloctor;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_uuid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		m_uuid <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>CProxyConn<span style="color:#f92672">::</span>s_uuid_alloctor;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	g_uuid_conn_map.insert(make_pair(m_uuid, <span style="color:#66d9ef">this</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个uuid的基数是一个CProxyConn的静态变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">uint32_t</span>	s_uuid_alloctor;
</span></span></code></pre></div><p>默认是0：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">uint32_t</span> CProxyConn<span style="color:#f92672">::</span>s_uuid_alloctor <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><p>以后每产生一个新连接对象CProxyConn，在此基础上递增，因为没有用锁保护，所以只能在一个线程里面调用。而CProxyConn正好就是在主线程里面产生的，前面介绍过了，再次贴一下代码吧：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">proxy_serv_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (msg <span style="color:#f92672">==</span> NETLIB_MSG_CONNECT)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        CProxyConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CProxyConn();
</span></span><span style="display:flex;"><span>        pConn<span style="color:#f92672">-&gt;</span>OnConnect(handle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;!!!error msg: %d&#34;</span>, msg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样uuid和连接对象CProxyConn还有CBaseSocket这三者的关系就唯一绑定了。</p>
<p>接着说，通过uuid获得对应数据包的连接对象后，调用其方法pConn-&gt;SendPdu(pResp-&gt;pPdu); “发出去”？但是，还是不行，因为这还没有解决上文提出的该连接上对端的tcp窗口太小导致数据发不出的问题。所以pConn-&gt;SendPdu()方法中一定不是调用send函数直接发送数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">SendPdu</span>(CImPdu<span style="color:#f92672">*</span> pPdu) { <span style="color:#66d9ef">return</span> Send(pPdu<span style="color:#f92672">-&gt;</span>GetBuffer(), pPdu<span style="color:#f92672">-&gt;</span>GetLength()); }
</span></span></code></pre></div><p>实际上是调用其基类CImConn类的Send方法，发送数据的时候，先记录一下发送数据的时间：m_last_send_tick = get_tick_count();</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CImConn<span style="color:#f92672">::</span>Send(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> data, <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    m_last_send_tick <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//	++g_send_pkt_cnt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (m_busy)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        m_out_buf.Write(data, len);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> remain <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (remain <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> send_size <span style="color:#f92672">=</span> remain;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (send_size <span style="color:#f92672">&gt;</span> NETLIB_MAX_SOCKET_BUF_SIZE) {
</span></span><span style="display:flex;"><span>            send_size <span style="color:#f92672">=</span> NETLIB_MAX_SOCKET_BUF_SIZE;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> netlib_send(m_handle, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)data <span style="color:#f92672">+</span> offset, send_size);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">+=</span> ret;
</span></span><span style="display:flex;"><span>        remain <span style="color:#f92672">-=</span> ret;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (remain <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        m_out_buf.Write((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)data <span style="color:#f92672">+</span> offset, remain);
</span></span><span style="display:flex;"><span>        m_busy <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;send busy, remain=%d &#34;</span>, m_out_buf.GetWriteOffset());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        OnWriteCompelete();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意这段代码，也是特别的讲究：</p>
<p>先试着调用底层send方法去发送，能发多少是多少，剩下发不完的，写入该连接的发送缓冲区中，并将忙碌标志m_busy置位（设置为ture）。反之，如果数据一次性发送完成，则调用数据发送完成函数OnWriteComplete（），这个函数目前为空，即不做任何事情。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> netlib_send(m_handle, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)data <span style="color:#f92672">+</span> offset , send_size);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">netlib_send</span>(net_handle_t handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> buf, <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket(handle);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pSocket)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_ERROR;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> pSocket<span style="color:#f92672">-&gt;</span>Send(buf, len);
</span></span><span style="display:flex;"><span>	pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码通过socket句柄找到具体的CBaseSocket对象。接着调用CBaseSocket::Send()方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CBaseSocket<span style="color:#f92672">::</span>Send(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> buf, <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_state <span style="color:#f92672">!=</span> SOCKET_STATE_CONNECTED)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NETLIB_ERROR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> send(m_socket, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)buf, len, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> SOCKET_ERROR)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> err_code <span style="color:#f92672">=</span> _GetErrorCode();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (_IsBlock(err_code))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if ((defined _WIN32) || (defined __APPLE__))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			CEventDispatch<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>AddEvent(m_socket, SOCKET_WRITE);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//log(&#34;socket send block fd=%d&#34;, m_socket);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			log(<span style="color:#e6db74">&#34;!!!send failed, error code: %d&#34;</span>, err_code);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该方法发送指定长度的数据，因为socket在创建的时候被设置成非阻塞的（上文介绍过）。所以，如果发送不了，底层send函数会立刻返回，并返回错误码EINPROGRESS（EWOULDBLOCK），表明对端tcp窗口太小，当前已经无法发出去：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> CBaseSocket<span style="color:#f92672">::</span>_IsBlock(<span style="color:#66d9ef">int</span> error_code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> ( (error_code <span style="color:#f92672">==</span> WSAEINPROGRESS) <span style="color:#f92672">||</span> (error_code <span style="color:#f92672">==</span> WSAEWOULDBLOCK) );
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> ( (error_code <span style="color:#f92672">==</span> EINPROGRESS) <span style="color:#f92672">||</span> (error_code <span style="color:#f92672">==</span> EWOULDBLOCK) );
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>这个时候，我们再设置关注该socket的可写事件。这样，下次对端tcp窗口大小增大时，本端的socket可写时，我们就能接着发送数据了。会在服务的消息泵中检测可写事件，接着调用CBaseSocket::OnWrite()， 该函数首先移除该socket的可写事件（这里为啥只有win32平台和mac机器移除可写事件，linux平台不需要吗？个人觉得是程序作者的疏忽）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CBaseSocket<span style="color:#f92672">::</span>OnWrite()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if ((defined _WIN32) || (defined __APPLE__))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	CEventDispatch<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>RemoveEvent(m_socket, SOCKET_WRITE);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_state <span style="color:#f92672">==</span> SOCKET_STATE_CONNECTING)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		socklen_t len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(error);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>error, <span style="color:#f92672">&amp;</span>len);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>error, <span style="color:#f92672">&amp;</span>len);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (error) {
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			m_state <span style="color:#f92672">=</span> SOCKET_STATE_CONNECTED;
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_CONFIRM, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		m_callback(m_callback_data, NETLIB_MSG_WRITE, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>走else分支，调用设置的回调函数imconn_callback：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">imconn_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	NOTUSED_ARG(handle);
</span></span><span style="display:flex;"><span>	NOTUSED_ARG(pParam);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>callback_data)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ConnMap_t<span style="color:#f92672">*</span> conn_map <span style="color:#f92672">=</span> (ConnMap_t<span style="color:#f92672">*</span>)callback_data;
</span></span><span style="display:flex;"><span>	CImConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> FindImConn(conn_map, handle);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pConn)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//log(&#34;msg=%d, handle=%d &#34;, msg, handle);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (msg)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_CONFIRM:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnConfirm();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_READ:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnRead();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_WRITE:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnWrite();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_CLOSE:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnClose();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;!!!imconn_callback error msg: %d &#34;</span>, msg);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pConn<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为这次传入的消息是NETLIB_MSG_WRITE，所以走pConn-&gt;OnWrite分支，接着由于多态调用CImConn的子类CProxyConn的OnWrite()函数，但由于子类CProxyConn并没有改写OnWrite()方法，所以调用CImConn的OnWrite():</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CImConn<span style="color:#f92672">::</span>OnWrite()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_busy)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (m_out_buf.GetWriteOffset() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> send_size <span style="color:#f92672">=</span> m_out_buf.GetWriteOffset();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (send_size <span style="color:#f92672">&gt;</span> NETLIB_MAX_SOCKET_BUF_SIZE) {
</span></span><span style="display:flex;"><span>			send_size <span style="color:#f92672">=</span> NETLIB_MAX_SOCKET_BUF_SIZE;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> netlib_send(m_handle, m_out_buf.GetBuffer(), send_size);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_out_buf.Read(NULL, ret);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_out_buf.GetWriteOffset() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		m_busy <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;onWrite, remain=%d &#34;</span>, m_out_buf.GetWriteOffset());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着继续从写缓冲区取出数据继续发送，如果还是只能发送出去，继续监听该socket可写事件，每次发送出去多少，就从写缓冲区中移除该部分字节。如果全部发送完了。将忙碌标志m_busy清零（false）。</p>
<p>至此，应答数据包的流程也介绍完了。我们来总结下该流程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>//1. 主消息泵检测到有其他任务需要做，做之。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//2. 该任务是从全局的链表中取出应答包数据，找到对应的连接对象，然后尝试直接发出去；
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//3. 如果发不出，则将该数据存入该连接的发送缓冲区（写缓冲区），并监听该连接的socket可写事件。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//4. 下次该socket触发可写事件时，接着发送该连接的写缓冲区中剩余的数据。如此循环直到所有数据都发送成功。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//5. 取消监听该socket可写事件，以避免无数据的情况下触发写事件（该事件大多数情况下很频繁）
</span></span></code></pre></div><p>上面的流程从第2步到第5步也是主流网络库的发数据的逻辑。总而言之，就是说，先试着发送数据，如果发不出去，存起来，监听可写事件，下次触发可写事件后接着发。一直到数据全部发出去后，移除监听可写事件。通常只要可写事件是不断会触发的，所以默认不监听可写事件，只有数据发不出的时候才会监听可写事件。这个原则，千万要记住。</p>
<p>最后一个问题，是关于心跳包的，即db_proxy_server是如何发送心跳包的：</p>
<p>程序初始化的时候，注册一个定时器函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>init_proxy_conn(thread_num);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">init_proxy_conn</span>(<span style="color:#66d9ef">uint32_t</span> thread_num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	s_handler_map <span style="color:#f92672">=</span> CHandlerMap<span style="color:#f92672">::</span>getInstance();
</span></span><span style="display:flex;"><span>	g_thread_pool.Init(thread_num);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	netlib_add_loop(proxy_loop_callback, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	signal(SIGTERM, sig_handler);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> netlib_register_timer(proxy_timer_callback, NULL, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后一行：return netlib_register_timer(proxy_timer_callback, NULL, 1000);</p>
<p>然后在消息泵里面检测定时器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>_CheckTimer();
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CEventDispatch<span style="color:#f92672">::</span>_CheckTimer()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> curr_tick <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>	list<span style="color:#f92672">&lt;</span>TimerItem<span style="color:#f92672">*&gt;::</span>iterator it;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (it <span style="color:#f92672">=</span> m_timer_list.begin(); it <span style="color:#f92672">!=</span> m_timer_list.end(); )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		TimerItem<span style="color:#f92672">*</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it;
</span></span><span style="display:flex;"><span>		it<span style="color:#f92672">++</span>;		<span style="color:#75715e">// iterator maybe deleted in the callback, so we should increment it before callback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (curr_tick <span style="color:#f92672">&gt;=</span> pItem<span style="color:#f92672">-&gt;</span>next_tick)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			pItem<span style="color:#f92672">-&gt;</span>next_tick <span style="color:#f92672">+=</span> pItem<span style="color:#f92672">-&gt;</span>interval;
</span></span><span style="display:flex;"><span>			pItem<span style="color:#f92672">-&gt;</span>callback(pItem<span style="color:#f92672">-&gt;</span>user_data, NETLIB_MSG_TIMER, <span style="color:#ae81ff">0</span>, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">uint64_t</span> <span style="color:#a6e22e">get_tick_count</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	LARGE_INTEGER liCounter; 
</span></span><span style="display:flex;"><span>	LARGE_INTEGER liCurrent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>QueryPerformanceFrequency(<span style="color:#f92672">&amp;</span>liCounter))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> GetTickCount();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	QueryPerformanceCounter(<span style="color:#f92672">&amp;</span>liCurrent);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">uint64_t</span>)(liCurrent.QuadPart <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span> <span style="color:#f92672">/</span> liCounter.QuadPart);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span> tval;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> ret_tick;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	gettimeofday(<span style="color:#f92672">&amp;</span>tval, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret_tick <span style="color:#f92672">=</span> tval.tv_sec <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000L</span> <span style="color:#f92672">+</span> tval.tv_usec <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000L</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret_tick;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>由上面的函数可以看出来定时器的单位是毫秒，当定时器时间到了后，调用回调函数proxy_timer_callback：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">proxy_timer_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> cur_time <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (ConnMap_t<span style="color:#f92672">::</span>iterator it <span style="color:#f92672">=</span> g_proxy_conn_map.begin(); it <span style="color:#f92672">!=</span> g_proxy_conn_map.end(); ) {
</span></span><span style="display:flex;"><span>		ConnMap_t<span style="color:#f92672">::</span>iterator it_old <span style="color:#f92672">=</span> it;
</span></span><span style="display:flex;"><span>		it<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		CProxyConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> (CProxyConn<span style="color:#f92672">*</span>)it_old<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnTimer(cur_time);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CProxyConn<span style="color:#f92672">::</span>OnTimer(<span style="color:#66d9ef">uint64_t</span> curr_tick)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (curr_tick <span style="color:#f92672">&gt;</span> m_last_send_tick <span style="color:#f92672">+</span> SERVER_HEARTBEAT_INTERVAL) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        CImPdu cPdu;
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>Other<span style="color:#f92672">::</span>IMHeartBeat msg;
</span></span><span style="display:flex;"><span>        cPdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>        cPdu.SetServiceId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SID_OTHER);
</span></span><span style="display:flex;"><span>        cPdu.SetCommandId(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_OTHER_HEARTBEAT);
</span></span><span style="display:flex;"><span>		SendPdu(<span style="color:#f92672">&amp;</span>cPdu);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (curr_tick <span style="color:#f92672">&gt;</span> m_last_recv_tick <span style="color:#f92672">+</span> SERVER_TIMEOUT) {
</span></span><span style="display:flex;"><span>		log(<span style="color:#e6db74">&#34;proxy connection timeout %s:%d&#34;</span>, m_peer_ip.c_str(), m_peer_port);
</span></span><span style="display:flex;"><span>		Close();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>m_last_send_tick是上一次发送数据的时间，我们上文中介绍过，如果当前时间距上一次发送数据的时间已经超过了指定的时间间隔，则发送一个心跳包（这里的时间间隔是5000毫秒）。</p>
<p>m_last_recv_tick是上一次收取数据的时间，我们上文也介绍过，如果当前时间举例上一次接收时间已经超过了指定的时间间隔（相当于一段时间内，对端没有给当前服务发送任何数据），这个时候就关闭该连接（这里设置的时间间隔是30000毫秒，也就是30秒）。</p>
<p>这种心跳包机制特别值得推崇，也是常见的心跳包策略。</p>
<p>至此，db_proxy_server的框架和原理也就介绍完了。剩下的就是一些业务逻辑了。如果你感兴趣，可以自己查看对应的命令号绑定的处理函数的处理流程。</p>
<p>文中如果有说错的地方，欢迎提出留言指正。</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/blog/74f8790b79af42ab856a668b8927b38a/">
    <span class="title">« Prev</span>
    <br>
    <span>03 服务器端的程序架构介绍</span>
  </a>
  <a class="next" href="https://haokiu.com/blog/27deab1b64f24c839058b60bd3826f79/">
    <span class="title">Next »</span>
    <br>
    <span>05 服务器端msg_server源码分析</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
