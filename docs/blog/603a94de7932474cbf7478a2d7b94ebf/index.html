<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>leveldb源码分析10 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="leveldb源码分析10 本系列《leveldb源码分析》共有22篇文章，这是第十篇
6.SSTable之四 6.6 遍历Table 6.6.1 遍历接口 Table导出了一个返回Iterator的接口，通过Iterator对象，调用者就可以遍历Table的内容，它简单的返回了一个TwoLevelIterator对象。见函数实现：
Iterator* NewIterator(const ReadOptions&amp;options) const; { return NewTwoLevelIterator(rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator), &amp;Table::BlockReader,const_cast&lt;Table*&gt;(this), options); } // 函数NewTwoLevelIterator创建了一个TwoLevelIterator对象： Iterator* NewTwoLevelIterator(Iterator* index_iter,BlockFunction block_function, void* arg, constReadOptions&amp; options) { return newTwoLevelIterator(index_iter, block_function, arg, options); } 这里有一个函数指针BlockFunction，类型为：
typedef Iterator* (*BlockFunction)(void*, const ReadOptions&amp;, constSlice&amp;); 为什么叫TwoLevelIterator呢，下面就来看看。
6.6.2 TwoLevelIterator 它也是Iterator的子类，之所以叫two level应该是不仅可以迭代其中存储的对象，它还接受了一个函数BlockFunction，可以遍历存储的对象，可见它是专门为Table定制的。 我们已经知道各种Block的存储格式都是相同的，但是各自block data存储的k/v又互不相同，于是我们就需要一个途径，能够在使用同一个方式遍历不同的block时，又能解析这些k/v。这就是BlockFunction，它又返回了一个针对block data的Iterator。Block和block data存储的k/v对的key是统一的。 先来看类的主要成员变量：
BlockFunction block_function_; // block操作函数 void* arg_; // BlockFunction的自定义参数 const ReadOptions options_; // BlockFunction的read option参数 Status status_; // 当前状态 IteratorWrapper index_iter_; // 遍历block的迭代器 IteratorWrapper data_iter_; // May be NULL-遍历block data的迭代器 // 如果data_iter_ != NULL，data_block_handle_保存的是传递给 // block_function_的index value，以用来创建data_iter_ std::string data_block_handle_; 下面分析一下对于Iterator几个接口的实现。
S1 对于其Key和Value接口都是返回的data_iter_对应的key和value： virtual bool Valid() const { return data_iter_.Valid(); } virtual Slice key() const { assert(Valid()); return data_iter_.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/blog/603a94de7932474cbf7478a2d7b94ebf/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="leveldb源码分析10" />
<meta property="og:description" content="leveldb源码分析10 本系列《leveldb源码分析》共有22篇文章，这是第十篇
6.SSTable之四 6.6 遍历Table 6.6.1 遍历接口 Table导出了一个返回Iterator的接口，通过Iterator对象，调用者就可以遍历Table的内容，它简单的返回了一个TwoLevelIterator对象。见函数实现：
Iterator* NewIterator(const ReadOptions&amp;options) const; { return NewTwoLevelIterator(rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator), &amp;Table::BlockReader,const_cast&lt;Table*&gt;(this), options); } // 函数NewTwoLevelIterator创建了一个TwoLevelIterator对象： Iterator* NewTwoLevelIterator(Iterator* index_iter,BlockFunction block_function, void* arg, constReadOptions&amp; options) { return newTwoLevelIterator(index_iter, block_function, arg, options); } 这里有一个函数指针BlockFunction，类型为：
typedef Iterator* (*BlockFunction)(void*, const ReadOptions&amp;, constSlice&amp;); 为什么叫TwoLevelIterator呢，下面就来看看。
6.6.2 TwoLevelIterator 它也是Iterator的子类，之所以叫two level应该是不仅可以迭代其中存储的对象，它还接受了一个函数BlockFunction，可以遍历存储的对象，可见它是专门为Table定制的。 我们已经知道各种Block的存储格式都是相同的，但是各自block data存储的k/v又互不相同，于是我们就需要一个途径，能够在使用同一个方式遍历不同的block时，又能解析这些k/v。这就是BlockFunction，它又返回了一个针对block data的Iterator。Block和block data存储的k/v对的key是统一的。 先来看类的主要成员变量：
BlockFunction block_function_; // block操作函数 void* arg_; // BlockFunction的自定义参数 const ReadOptions options_; // BlockFunction的read option参数 Status status_; // 当前状态 IteratorWrapper index_iter_; // 遍历block的迭代器 IteratorWrapper data_iter_; // May be NULL-遍历block data的迭代器 // 如果data_iter_ != NULL，data_block_handle_保存的是传递给 // block_function_的index value，以用来创建data_iter_ std::string data_block_handle_; 下面分析一下对于Iterator几个接口的实现。
S1 对于其Key和Value接口都是返回的data_iter_对应的key和value： virtual bool Valid() const { return data_iter_.Valid(); } virtual Slice key() const { assert(Valid()); return data_iter_." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/blog/603a94de7932474cbf7478a2d7b94ebf/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="leveldb源码分析10"/>
<meta name="twitter:description" content="leveldb源码分析10 本系列《leveldb源码分析》共有22篇文章，这是第十篇
6.SSTable之四 6.6 遍历Table 6.6.1 遍历接口 Table导出了一个返回Iterator的接口，通过Iterator对象，调用者就可以遍历Table的内容，它简单的返回了一个TwoLevelIterator对象。见函数实现：
Iterator* NewIterator(const ReadOptions&amp;options) const; { return NewTwoLevelIterator(rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator), &amp;Table::BlockReader,const_cast&lt;Table*&gt;(this), options); } // 函数NewTwoLevelIterator创建了一个TwoLevelIterator对象： Iterator* NewTwoLevelIterator(Iterator* index_iter,BlockFunction block_function, void* arg, constReadOptions&amp; options) { return newTwoLevelIterator(index_iter, block_function, arg, options); } 这里有一个函数指针BlockFunction，类型为：
typedef Iterator* (*BlockFunction)(void*, const ReadOptions&amp;, constSlice&amp;); 为什么叫TwoLevelIterator呢，下面就来看看。
6.6.2 TwoLevelIterator 它也是Iterator的子类，之所以叫two level应该是不仅可以迭代其中存储的对象，它还接受了一个函数BlockFunction，可以遍历存储的对象，可见它是专门为Table定制的。 我们已经知道各种Block的存储格式都是相同的，但是各自block data存储的k/v又互不相同，于是我们就需要一个途径，能够在使用同一个方式遍历不同的block时，又能解析这些k/v。这就是BlockFunction，它又返回了一个针对block data的Iterator。Block和block data存储的k/v对的key是统一的。 先来看类的主要成员变量：
BlockFunction block_function_; // block操作函数 void* arg_; // BlockFunction的自定义参数 const ReadOptions options_; // BlockFunction的read option参数 Status status_; // 当前状态 IteratorWrapper index_iter_; // 遍历block的迭代器 IteratorWrapper data_iter_; // May be NULL-遍历block data的迭代器 // 如果data_iter_ != NULL，data_block_handle_保存的是传递给 // block_function_的index value，以用来创建data_iter_ std::string data_block_handle_; 下面分析一下对于Iterator几个接口的实现。
S1 对于其Key和Value接口都是返回的data_iter_对应的key和value： virtual bool Valid() const { return data_iter_.Valid(); } virtual Slice key() const { assert(Valid()); return data_iter_."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "leveldb源码分析10",
      "item": "https://haokiu.com/blog/603a94de7932474cbf7478a2d7b94ebf/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "leveldb源码分析10",
  "name": "leveldb源码分析10",
  "description": "leveldb源码分析10 本系列《leveldb源码分析》共有22篇文章，这是第十篇\n6.SSTable之四 6.6 遍历Table 6.6.1 遍历接口 Table导出了一个返回Iterator的接口，通过Iterator对象，调用者就可以遍历Table的内容，它简单的返回了一个TwoLevelIterator对象。见函数实现：\nIterator* NewIterator(const ReadOptions\u0026amp;options) const; { return NewTwoLevelIterator(rep_-\u0026gt;index_block-\u0026gt;NewIterator(rep_-\u0026gt;options.comparator), \u0026amp;Table::BlockReader,const_cast\u0026lt;Table*\u0026gt;(this), options); } // 函数NewTwoLevelIterator创建了一个TwoLevelIterator对象： Iterator* NewTwoLevelIterator(Iterator* index_iter,BlockFunction block_function, void* arg, constReadOptions\u0026amp; options) { return newTwoLevelIterator(index_iter, block_function, arg, options); } 这里有一个函数指针BlockFunction，类型为：\ntypedef Iterator* (*BlockFunction)(void*, const ReadOptions\u0026amp;, constSlice\u0026amp;); 为什么叫TwoLevelIterator呢，下面就来看看。\n6.6.2 TwoLevelIterator 它也是Iterator的子类，之所以叫two level应该是不仅可以迭代其中存储的对象，它还接受了一个函数BlockFunction，可以遍历存储的对象，可见它是专门为Table定制的。 我们已经知道各种Block的存储格式都是相同的，但是各自block data存储的k/v又互不相同，于是我们就需要一个途径，能够在使用同一个方式遍历不同的block时，又能解析这些k/v。这就是BlockFunction，它又返回了一个针对block data的Iterator。Block和block data存储的k/v对的key是统一的。 先来看类的主要成员变量：\nBlockFunction block_function_; // block操作函数 void* arg_; // BlockFunction的自定义参数 const ReadOptions options_; // BlockFunction的read option参数 Status status_; // 当前状态 IteratorWrapper index_iter_; // 遍历block的迭代器 IteratorWrapper data_iter_; // May be NULL-遍历block data的迭代器 // 如果data_iter_ != NULL，data_block_handle_保存的是传递给 // block_function_的index value，以用来创建data_iter_ std::string data_block_handle_; 下面分析一下对于Iterator几个接口的实现。\nS1 对于其Key和Value接口都是返回的data_iter_对应的key和value： virtual bool Valid() const { return data_iter_.Valid(); } virtual Slice key() const { assert(Valid()); return data_iter_.",
  "keywords": [
    
  ],
  "articleBody": "leveldb源码分析10 本系列《leveldb源码分析》共有22篇文章，这是第十篇\n6.SSTable之四 6.6 遍历Table 6.6.1 遍历接口 Table导出了一个返回Iterator的接口，通过Iterator对象，调用者就可以遍历Table的内容，它简单的返回了一个TwoLevelIterator对象。见函数实现：\nIterator* NewIterator(const ReadOptions\u0026options) const; { return NewTwoLevelIterator(rep_-\u003eindex_block-\u003eNewIterator(rep_-\u003eoptions.comparator), \u0026Table::BlockReader,const_cast(this), options); } // 函数NewTwoLevelIterator创建了一个TwoLevelIterator对象： Iterator* NewTwoLevelIterator(Iterator* index_iter,BlockFunction block_function, void* arg, constReadOptions\u0026 options) { return newTwoLevelIterator(index_iter, block_function, arg, options); } 这里有一个函数指针BlockFunction，类型为：\ntypedef Iterator* (*BlockFunction)(void*, const ReadOptions\u0026, constSlice\u0026); 为什么叫TwoLevelIterator呢，下面就来看看。\n6.6.2 TwoLevelIterator 它也是Iterator的子类，之所以叫two level应该是不仅可以迭代其中存储的对象，它还接受了一个函数BlockFunction，可以遍历存储的对象，可见它是专门为Table定制的。 我们已经知道各种Block的存储格式都是相同的，但是各自block data存储的k/v又互不相同，于是我们就需要一个途径，能够在使用同一个方式遍历不同的block时，又能解析这些k/v。这就是BlockFunction，它又返回了一个针对block data的Iterator。Block和block data存储的k/v对的key是统一的。 先来看类的主要成员变量：\nBlockFunction block_function_; // block操作函数 void* arg_; // BlockFunction的自定义参数 const ReadOptions options_; // BlockFunction的read option参数 Status status_; // 当前状态 IteratorWrapper index_iter_; // 遍历block的迭代器 IteratorWrapper data_iter_; // May be NULL-遍历block data的迭代器 // 如果data_iter_ != NULL，data_block_handle_保存的是传递给 // block_function_的index value，以用来创建data_iter_ std::string data_block_handle_; 下面分析一下对于Iterator几个接口的实现。\nS1 对于其Key和Value接口都是返回的data_iter_对应的key和value： virtual bool Valid() const { return data_iter_.Valid(); } virtual Slice key() const { assert(Valid()); return data_iter_.key(); } virtual Slice value() const { assert(Valid()); return data_iter_.value(); } S2 在分析Seek系函数之前，有必要先了解下面这几个函数的用途。\nvoid InitDataBlock(); void SetDataIterator(Iterator*data_iter); //设置date_iter_ = data_iter voidSkipEmptyDataBlocksForward(); voidSkipEmptyDataBlocksBackward(); S2.1首先是InitDataBlock()，它是根据index_iter来初始化data_iter，当定位到新的block时，需要更新data Iterator，指向该block中k/v对的合适位置，函数如下： if (!index_iter_.Valid()) SetDataIterator(NULL); // index_iter非法 else { Slice handle =index_iter_.value(); if (data_iter_.iter() != NULL\u0026\u0026 handle.compare(data_block_handle_) == 0) { //data_iter已经在该block data上了，无须改变 } else { // 根据handle数据定位data iter Iterator* iter =(*block_function_)(arg_, options_, handle); data_block_handle_.assign(handle.data(), handle.size()); SetDataIterator(iter); } } S2.2 SkipEmptyDataBlocksForward，向前跳过空的datablock，函数实现如下： while (data_iter_.iter() == NULL|| !data_iter_.Valid()) { // 跳到下一个block if (!index_iter_.Valid()) { // 如果index iter非法，设置data iteration为NULL SetDataIterator(NULL); return; } index_iter_.Next(); InitDataBlock(); if (data_iter_.iter() != NULL)data_iter_.SeekToFirst(); // 跳转到开始 } S2.3 SkipEmptyDataBlocksBackward，向后跳过空的datablock，函数实现如下： while (data_iter_.iter() == NULL|| !data_iter_.Valid()) { // 跳到前一个block if (!index_iter_.Valid()) { // 如果index iter非法，设置data iteration为NULL SetDataIterator(NULL); return; } index_iter_.Prev(); InitDataBlock(); if (data_iter_.iter() != NULL)data_iter_.SeekToLast(); // 跳转到开始 } S3 了解了几个跳转的辅助函数，再来看Seek系接口。 void TwoLevelIterator::Seek(const Slice\u0026 target) { index_iter_.Seek(target); InitDataBlock(); // 根据index iter设置data iter if (data_iter_.iter() != NULL)data_iter_.Seek(target); // 调整data iter跳转到target SkipEmptyDataBlocksForward(); // 调整iter，跳过空的block } void TwoLevelIterator::SeekToFirst() { index_iter_.SeekToFirst(); InitDataBlock(); // 根据index iter设置data iter if (data_iter_.iter() != NULL)data_iter_.SeekToFirst(); SkipEmptyDataBlocksForward(); // 调整iter，跳过空的block } void TwoLevelIterator::SeekToLast() { index_iter_.SeekToLast(); InitDataBlock(); // 根据index iter设置data iter if (data_iter_.iter() != NULL)data_iter_.SeekToLast(); SkipEmptyDataBlocksBackward();// 调整iter，跳过空的block } void TwoLevelIterator::Next() { assert(Valid()); data_iter_.Next(); SkipEmptyDataBlocksForward(); // 调整iter，跳过空的block } void TwoLevelIterator::Prev() { assert(Valid()); data_iter_.Prev(); SkipEmptyDataBlocksBackward();// 调整iter，跳过空的block } 6.6.3 BlockReader() 上面传递给twolevel Iterator的函数是Table::BlockReader函数，声明如下：\nstatic Iterator* Table::BlockReader(void* arg, const ReadOptions\u0026options, constSlice\u0026 index_value); 它根据参数指明的blockdata，返回一个iterator对象，调用者就可以通过这个iterator对象遍历blockdata存储的k/v对，这其中用到了LRUCache。 函数实现逻辑如下：\nS1 从参数中解析出BlockHandle对象，其中arg就是Table对象，index_value存储的是BlockHandle对象，读取Block的索引。 Table* table =reinterpret_cast(arg); Block* block = NULL; Cache::Handle* cache_handle =NULL; BlockHandle handle; Slice input = index_value; Status s =handle.DecodeFrom(\u0026input); S2 根据block handle，首先尝试从cache中直接取出block，不在cache中则调用ReadBlock从文件读取，读取成功后，根据option尝试将block加入到LRU cache中。并在Insert的时候注册了释放函数DeleteCachedBlock。 Cache* block_cache =table-\u003erep_-\u003eoptions.block_cache; BlockContents contents; if (block_cache != NULL) { char cache_key_buffer[16]; // cache key的格式为table.cache_id + offset EncodeFixed64(cache_key_buffer, table-\u003erep_-\u003ecache_id); EncodeFixed64(cache_key_buffer+8, handle.offset()); Slice key(cache_key_buffer,sizeof(cache_key_buffer)); cache_handle =block_cache-\u003eLookup(key); // 尝试从LRU cache中查找 if (cache_handle != NULL) { // 找到则直接取值 block =reinterpret_cast(block_cache-\u003eValue(cache_handle)); } else { // 否则直接从文件读取 s =ReadBlock(table-\u003erep_-\u003efile, options, handle, \u0026contents); if (s.ok()) { block = new Block(contents); if (contents.cachable\u0026\u0026 options.fill_cache) // 尝试加到cache中 cache_handle =block_cache-\u003eInsert(key, block,block-\u003esize(), \u0026DeleteCachedBlock); } } } else { s =ReadBlock(table-\u003erep_-\u003efile, options, handle, \u0026contents); if (s.ok()) block = newBlock(contents); } S3 如果读取到了block，调用Block::NewIterator接口创建Iterator，如果cache handle为NULL，则注册DeleteBlock，否则注册ReleaseBlock，事后清理。 Iterator* iter; if (block != NULL) { iter =block-\u003eNewIterator(table-\u003erep_-\u003eoptions.comparator); if (cache_handle == NULL) iter-\u003eRegisterCleanup(\u0026DeleteBlock,block, NULL); else iter-\u003eRegisterCleanup(\u0026ReleaseBlock,block_cache, cache_handle); } else iter = NewErrorIterator(s); 处理结束，最后返回iter。这里简单列下这几个静态函数，都很简单：\nstatic void DeleteBlock(void* arg, void* ignored) { deletereinterpret_cast(arg); } static void DeleteCachedBlock(const Slice\u0026 key, void* value) { Block* block =reinterpret_cast(value); delete block; } static void ReleaseBlock(void* arg, void* h) { Cache* cache =reinterpret_cast(arg); Cache::Handle* handle =reinterpret_cast(h); cache-\u003eRelease(handle); } 6.7 定位key 这里并不是精确的定位，而是在Table中找到第一个\u003e=指定key的k/v对，然后返回其value在sstable文件中的偏移。也是Table类的一个接口：\nuint64_t ApproximateOffsetOf(const Slice\u0026 key) const; 函数实现比较简单：\nS1 调用Block::Iter的Seek函数定位 Iterator* index_iter=rep_-\u003eindex_block-\u003eNewIterator(rep_-\u003eoptions.comparator); index_iter-\u003eSeek(key); uint64_t result; S2 如果index_iter是合法的值，并且Decode成功，返回结果offset。 BlockHandle handle; handle.DecodeFrom(\u0026index_iter-\u003evalue()); result = handle.offset(); S3 其它情况，设置result为rep_-\u003emetaindex_handle.offset()，metaindex的偏移在文件结尾附近。 6.8 获取Key—InternalGet() InternalGet，这是为TableCache开的一个口子。这是一个private函数，声明为：\nStatus Table::InternalGet(const ReadOptions\u0026 options, constSlice\u0026 k, void*arg, void (*saver)(void*, const Slice\u0026, const Slice\u0026)) 其中又有函数指针，在找到数据后，就调用传入的函数指针saver执行调用者的自定义处理逻辑，并且TableCache可能会做缓存。 函数逻辑如下：\nS1 首先根据传入的key定位数据，这需要indexblock的Iterator。 Iterator* iiter =rep_-\u003eindex_block-\u003eNewIterator(rep_-\u003eoptions.comparator); iiter-\u003eSeek(k); S2 如果key是合法的，取出其filter指针，如果使用了filter，则检查key是否存在，这可以快速判断，提升效率。 Status s; Slice handle_value =iiter-\u003evalue(); FilterBlockReader* filter = rep_-\u003efilter; BlockHandle handle; if (filter != NULL \u0026\u0026 handle.DecodeFrom(\u0026handle_value).ok() \u0026\u0026 !filter-\u003eKeyMayMatch(handle.offset(),k)) { // key不存在 } else { // 否则就要读取block，并查找其k/v对 Slice handle = iiter-\u003evalue(); Iterator* block_iter =BlockReader(this, options, iiter-\u003evalue()); block_iter-\u003eSeek(k); if (block_iter-\u003eValid())(*saver)(arg, block_iter-\u003ekey(), block_iter-\u003evalue()); s = block_iter-\u003estatus(); delete block_iter; } S3 最后返回结果，删除临时变量。 if (s.ok()) s =iiter-\u003estatus(); delete iiter; return s; 随着有关sstable文件读取的结束，sstable的源码也就分析完了，其中我们还遗漏了一些功课要做，那就是Filter和TableCache部分。\n",
  "wordCount" : "593",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/blog/603a94de7932474cbf7478a2d7b94ebf/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      leveldb源码分析10
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#leveldb%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%9010" aria-label="leveldb源码分析10">leveldb源码分析10</a><ul>
                        
                <li>
                    <a href="#6sstable%e4%b9%8b%e5%9b%9b" aria-label="6.SSTable之四">6.SSTable之四</a><ul>
                        
                <li>
                    <a href="#66-%e9%81%8d%e5%8e%86table" aria-label="6.6 遍历Table">6.6 遍历Table</a><ul>
                        
                <li>
                    <a href="#661-%e9%81%8d%e5%8e%86%e6%8e%a5%e5%8f%a3" aria-label="6.6.1 遍历接口">6.6.1 遍历接口</a></li>
                <li>
                    <a href="#662-twoleveliterator" aria-label="6.6.2 TwoLevelIterator">6.6.2 TwoLevelIterator</a><ul>
                        
                <li>
                    <a href="#s1-%e5%af%b9%e4%ba%8e%e5%85%b6key%e5%92%8cvalue%e6%8e%a5%e5%8f%a3%e9%83%bd%e6%98%af%e8%bf%94%e5%9b%9e%e7%9a%84data_iter_%e5%af%b9%e5%ba%94%e7%9a%84key%e5%92%8cvalue" aria-label="S1 对于其Key和Value接口都是返回的data_iter_对应的key和value：">S1 对于其Key和Value接口都是返回的data_iter_对应的key和value：</a><ul>
                        
                <li>
                    <a href="#s21%e9%a6%96%e5%85%88%e6%98%afinitdatablock%e5%ae%83%e6%98%af%e6%a0%b9%e6%8d%aeindex_iter%e6%9d%a5%e5%88%9d%e5%a7%8b%e5%8c%96data_iter%e5%bd%93%e5%ae%9a%e4%bd%8d%e5%88%b0%e6%96%b0%e7%9a%84block%e6%97%b6%e9%9c%80%e8%a6%81%e6%9b%b4%e6%96%b0data-iterator%e6%8c%87%e5%90%91%e8%af%a5block%e4%b8%adkv%e5%af%b9%e7%9a%84%e5%90%88%e9%80%82%e4%bd%8d%e7%bd%ae%e5%87%bd%e6%95%b0%e5%a6%82%e4%b8%8b" aria-label="S2.1首先是InitDataBlock()，它是根据index_iter来初始化data_iter，当定位到新的block时，需要更新data Iterator，指向该block中k/v对的合适位置，函数如下：">S2.1首先是InitDataBlock()，它是根据index_iter来初始化data_iter，当定位到新的block时，需要更新data Iterator，指向该block中k/v对的合适位置，函数如下：</a></li>
                <li>
                    <a href="#s22-skipemptydatablocksforward%e5%90%91%e5%89%8d%e8%b7%b3%e8%bf%87%e7%a9%ba%e7%9a%84datablock%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0%e5%a6%82%e4%b8%8b" aria-label="S2.2 SkipEmptyDataBlocksForward，向前跳过空的datablock，函数实现如下：">S2.2 SkipEmptyDataBlocksForward，向前跳过空的datablock，函数实现如下：</a></li>
                <li>
                    <a href="#s23-skipemptydatablocksbackward%e5%90%91%e5%90%8e%e8%b7%b3%e8%bf%87%e7%a9%ba%e7%9a%84datablock%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0%e5%a6%82%e4%b8%8b" aria-label="S2.3 SkipEmptyDataBlocksBackward，向后跳过空的datablock，函数实现如下：">S2.3 SkipEmptyDataBlocksBackward，向后跳过空的datablock，函数实现如下：</a></li></ul>
                </li>
                <li>
                    <a href="#s3-%e4%ba%86%e8%a7%a3%e4%ba%86%e5%87%a0%e4%b8%aa%e8%b7%b3%e8%bd%ac%e7%9a%84%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0%e5%86%8d%e6%9d%a5%e7%9c%8bseek%e7%b3%bb%e6%8e%a5%e5%8f%a3" aria-label="S3 了解了几个跳转的辅助函数，再来看Seek系接口。">S3 了解了几个跳转的辅助函数，再来看Seek系接口。</a></li></ul>
                </li>
                <li>
                    <a href="#663-blockreader" aria-label="6.6.3 BlockReader()">6.6.3 BlockReader()</a><ul>
                        
                <li>
                    <a href="#s1-%e4%bb%8e%e5%8f%82%e6%95%b0%e4%b8%ad%e8%a7%a3%e6%9e%90%e5%87%bablockhandle%e5%af%b9%e8%b1%a1%e5%85%b6%e4%b8%adarg%e5%b0%b1%e6%98%aftable%e5%af%b9%e8%b1%a1index_value%e5%ad%98%e5%82%a8%e7%9a%84%e6%98%afblockhandle%e5%af%b9%e8%b1%a1%e8%af%bb%e5%8f%96block%e7%9a%84%e7%b4%a2%e5%bc%95" aria-label="S1 从参数中解析出BlockHandle对象，其中arg就是Table对象，index_value存储的是BlockHandle对象，读取Block的索引。">S1 从参数中解析出BlockHandle对象，其中arg就是Table对象，index_value存储的是BlockHandle对象，读取Block的索引。</a></li>
                <li>
                    <a href="#s2-%e6%a0%b9%e6%8d%aeblock-handle%e9%a6%96%e5%85%88%e5%b0%9d%e8%af%95%e4%bb%8ecache%e4%b8%ad%e7%9b%b4%e6%8e%a5%e5%8f%96%e5%87%bablock%e4%b8%8d%e5%9c%a8cache%e4%b8%ad%e5%88%99%e8%b0%83%e7%94%a8readblock%e4%bb%8e%e6%96%87%e4%bb%b6%e8%af%bb%e5%8f%96%e8%af%bb%e5%8f%96%e6%88%90%e5%8a%9f%e5%90%8e%e6%a0%b9%e6%8d%aeoption%e5%b0%9d%e8%af%95%e5%b0%86block%e5%8a%a0%e5%85%a5%e5%88%b0lru-cache%e4%b8%ad%e5%b9%b6%e5%9c%a8insert%e7%9a%84%e6%97%b6%e5%80%99%e6%b3%a8%e5%86%8c%e4%ba%86%e9%87%8a%e6%94%be%e5%87%bd%e6%95%b0deletecachedblock" aria-label="S2 根据block handle，首先尝试从cache中直接取出block，不在cache中则调用ReadBlock从文件读取，读取成功后，根据option尝试将block加入到LRU cache中。并在Insert的时候注册了释放函数DeleteCachedBlock。">S2 根据block handle，首先尝试从cache中直接取出block，不在cache中则调用ReadBlock从文件读取，读取成功后，根据option尝试将block加入到LRU cache中。并在Insert的时候注册了释放函数DeleteCachedBlock。</a></li>
                <li>
                    <a href="#s3-%e5%a6%82%e6%9e%9c%e8%af%bb%e5%8f%96%e5%88%b0%e4%ba%86block%e8%b0%83%e7%94%a8blocknewiterator%e6%8e%a5%e5%8f%a3%e5%88%9b%e5%bb%baiterator%e5%a6%82%e6%9e%9ccache-handle%e4%b8%banull%e5%88%99%e6%b3%a8%e5%86%8cdeleteblock%e5%90%a6%e5%88%99%e6%b3%a8%e5%86%8creleaseblock%e4%ba%8b%e5%90%8e%e6%b8%85%e7%90%86" aria-label="S3 如果读取到了block，调用Block::NewIterator接口创建Iterator，如果cache handle为NULL，则注册DeleteBlock，否则注册ReleaseBlock，事后清理。">S3 如果读取到了block，调用Block::NewIterator接口创建Iterator，如果cache handle为NULL，则注册DeleteBlock，否则注册ReleaseBlock，事后清理。</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#67-%e5%ae%9a%e4%bd%8dkey" aria-label="6.7 定位key">6.7 定位key</a><ul>
                        <ul>
                        
                <li>
                    <a href="#s1-%e8%b0%83%e7%94%a8blockiter%e7%9a%84seek%e5%87%bd%e6%95%b0%e5%ae%9a%e4%bd%8d" aria-label="S1 调用Block::Iter的Seek函数定位">S1 调用Block::Iter的Seek函数定位</a></li>
                <li>
                    <a href="#s2-%e5%a6%82%e6%9e%9cindex_iter%e6%98%af%e5%90%88%e6%b3%95%e7%9a%84%e5%80%bc%e5%b9%b6%e4%b8%94decode%e6%88%90%e5%8a%9f%e8%bf%94%e5%9b%9e%e7%bb%93%e6%9e%9coffset" aria-label="S2 如果index_iter是合法的值，并且Decode成功，返回结果offset。">S2 如果index_iter是合法的值，并且Decode成功，返回结果offset。</a></li>
                <li>
                    <a href="#s3-%e5%85%b6%e5%ae%83%e6%83%85%e5%86%b5%e8%ae%be%e7%bd%aeresult%e4%b8%barep_-metaindex_handleoffsetmetaindex%e7%9a%84%e5%81%8f%e7%a7%bb%e5%9c%a8%e6%96%87%e4%bb%b6%e7%bb%93%e5%b0%be%e9%99%84%e8%bf%91" aria-label="S3 其它情况，设置result为rep_-&amp;gt;metaindex_handle.offset()，metaindex的偏移在文件结尾附近。">S3 其它情况，设置result为rep_-&gt;metaindex_handle.offset()，metaindex的偏移在文件结尾附近。</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#68-%e8%8e%b7%e5%8f%96keyinternalget" aria-label="6.8 获取Key—InternalGet()">6.8 获取Key—InternalGet()</a><ul>
                        <ul>
                        
                <li>
                    <a href="#s1-%e9%a6%96%e5%85%88%e6%a0%b9%e6%8d%ae%e4%bc%a0%e5%85%a5%e7%9a%84key%e5%ae%9a%e4%bd%8d%e6%95%b0%e6%8d%ae%e8%bf%99%e9%9c%80%e8%a6%81indexblock%e7%9a%84iterator" aria-label="S1 首先根据传入的key定位数据，这需要indexblock的Iterator。">S1 首先根据传入的key定位数据，这需要indexblock的Iterator。</a></li>
                <li>
                    <a href="#s2-%e5%a6%82%e6%9e%9ckey%e6%98%af%e5%90%88%e6%b3%95%e7%9a%84%e5%8f%96%e5%87%ba%e5%85%b6filter%e6%8c%87%e9%92%88%e5%a6%82%e6%9e%9c%e4%bd%bf%e7%94%a8%e4%ba%86filter%e5%88%99%e6%a3%80%e6%9f%a5key%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e8%bf%99%e5%8f%af%e4%bb%a5%e5%bf%ab%e9%80%9f%e5%88%a4%e6%96%ad%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87" aria-label="S2 如果key是合法的，取出其filter指针，如果使用了filter，则检查key是否存在，这可以快速判断，提升效率。">S2 如果key是合法的，取出其filter指针，如果使用了filter，则检查key是否存在，这可以快速判断，提升效率。</a></li>
                <li>
                    <a href="#s3-%e6%9c%80%e5%90%8e%e8%bf%94%e5%9b%9e%e7%bb%93%e6%9e%9c%e5%88%a0%e9%99%a4%e4%b8%b4%e6%97%b6%e5%8f%98%e9%87%8f" aria-label="S3 最后返回结果，删除临时变量。">S3 最后返回结果，删除临时变量。</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="leveldb源码分析10">leveldb源码分析10</h1>
<p>本系列《leveldb源码分析》共有22篇文章，这是第十篇</p>
<h2 id="6sstable之四">6.SSTable之四</h2>
<h3 id="66-遍历table">6.6 遍历Table</h3>
<h4 id="661-遍历接口">6.6.1 遍历接口</h4>
<p>Table导出了一个返回<strong>Iterator</strong>的接口，通过Iterator对象，调用者就可以<strong>遍历</strong>Table的内容，它简单的返回了一个<strong>TwoLevelIterator</strong>对象。见函数实现：</p>
<pre tabindex="0"><code>Iterator* NewIterator(const ReadOptions&amp;options) const;  
{  
     return NewTwoLevelIterator(rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),  
                                &amp;Table::BlockReader,const_cast&lt;Table*&gt;(this), options);  
}  
// 函数NewTwoLevelIterator创建了一个TwoLevelIterator对象：  
Iterator* NewTwoLevelIterator(Iterator* index_iter,BlockFunction block_function,  
                              void* arg, constReadOptions&amp; options) 
{  
     return newTwoLevelIterator(index_iter, block_function, arg, options);  
}  
</code></pre><p>这里有一个函数指针BlockFunction，类型为：</p>
<pre tabindex="0"><code>typedef Iterator* (*BlockFunction)(void*, const ReadOptions&amp;, constSlice&amp;);
</code></pre><p><strong>为什么叫TwoLevelIterator呢</strong>，下面就来看看。</p>
<h4 id="662-twoleveliterator">6.6.2 TwoLevelIterator</h4>
<p>它也是<strong>Iterator的子类</strong>，之所以叫two level应该是不仅可以迭代其中存储的对象，它还接受了一个函数<strong>BlockFunction</strong>，可以遍历存储的对象，可见它是专门为<strong>Table定制</strong>的。
我们已经知道各种Block的<strong>存储格式</strong>都是<strong>相同</strong>的，但是各自block data存储的<strong>k/v</strong>又<strong>互不相同</strong>，于是我们就需要一个途径，能够在使用同一个方式<strong>遍历</strong>不同的block时，又能<strong>解析</strong>这些k/v。这就是<strong>BlockFunction</strong>，它又返回了一个针对block data的Iterator。<strong>Block和block data</strong>存储的k/v对的key是统一的。
先来看类的主要成员变量：</p>
<pre tabindex="0"><code>BlockFunction block_function_; // block操作函数  
void* arg_;                    // BlockFunction的自定义参数  
const ReadOptions options_;    // BlockFunction的read option参数  
Status status_;                // 当前状态  
IteratorWrapper index_iter_;   // 遍历block的迭代器  
IteratorWrapper data_iter_;    // May be NULL-遍历block data的迭代器  
// 如果data_iter_ != NULL，data_block_handle_保存的是传递给  
// block_function_的index value，以用来创建data_iter_  
std::string data_block_handle_; 
</code></pre><p>下面<strong>分析一下对于Iterator几个接口的实现。</strong></p>
<h5 id="s1-对于其key和value接口都是返回的data_iter_对应的key和value">S1 对于其Key和Value接口都是返回的data_iter_对应的key和value：</h5>
<pre tabindex="0"><code>virtual bool Valid() const 
{  
      return data_iter_.Valid();  
} 

virtual Slice key() const 
{   
       assert(Valid());  
       return data_iter_.key();  
}

virtual Slice value() const 
{  
       assert(Valid());  
       return data_iter_.value();  
} 
</code></pre><p><strong>S2 在分析Seek系函数之前</strong>，有必要先了解下面这几个函数的用途。</p>
<pre tabindex="0"><code>void InitDataBlock();  
void SetDataIterator(Iterator*data_iter); 
//设置date_iter_ = data_iter  
voidSkipEmptyDataBlocksForward();  
voidSkipEmptyDataBlocksBackward(); 
</code></pre><h6 id="s21首先是initdatablock它是根据index_iter来初始化data_iter当定位到新的block时需要更新data-iterator指向该block中kv对的合适位置函数如下">S2.1首先是InitDataBlock()，它是根据index_iter来初始化data_iter，当定位到新的block时，需要更新data Iterator，指向该block中k/v对的合适位置，函数如下：</h6>
<pre tabindex="0"><code>if (!index_iter_.Valid()) SetDataIterator(NULL);
// index_iter非法  
else 
{  
      Slice handle =index_iter_.value();  
      if (data_iter_.iter() != NULL&amp;&amp; handle.compare(data_block_handle_) == 0)
      {  
           //data_iter已经在该block data上了，无须改变  
         } 
      else 
      { 
           // 根据handle数据定位data iter  
           Iterator* iter =(*block_function_)(arg_, options_, handle);  
           data_block_handle_.assign(handle.data(), handle.size());  
           SetDataIterator(iter);  
      }  
}
</code></pre><h6 id="s22-skipemptydatablocksforward向前跳过空的datablock函数实现如下">S2.2 SkipEmptyDataBlocksForward，向前跳过空的datablock，函数实现如下：</h6>
<pre tabindex="0"><code>while (data_iter_.iter() == NULL|| !data_iter_.Valid()) 
{   
      // 跳到下一个block  
      if (!index_iter_.Valid()) 
      { 
           // 如果index iter非法，设置data iteration为NULL  
           SetDataIterator(NULL);  
           return;  
         }  
      index_iter_.Next();  
      InitDataBlock();  
      if (data_iter_.iter() != NULL)data_iter_.SeekToFirst();
      // 跳转到开始  
}  
</code></pre><h6 id="s23-skipemptydatablocksbackward向后跳过空的datablock函数实现如下">S2.3 SkipEmptyDataBlocksBackward，向后跳过空的datablock，函数实现如下：</h6>
<pre tabindex="0"><code>while (data_iter_.iter() == NULL|| !data_iter_.Valid()) 
{ 
     // 跳到前一个block  
     if (!index_iter_.Valid()) 
     { 
          // 如果index iter非法，设置data iteration为NULL  
          SetDataIterator(NULL);  
          return;  
        }  
        index_iter_.Prev();  
      InitDataBlock();  
      if (data_iter_.iter() != NULL)data_iter_.SeekToLast();
      // 跳转到开始  
} 
</code></pre><h5 id="s3-了解了几个跳转的辅助函数再来看seek系接口">S3 了解了几个跳转的辅助函数，再来看Seek系接口。</h5>
<pre tabindex="0"><code>void TwoLevelIterator::Seek(const Slice&amp; target) 
{  
    index_iter_.Seek(target);  
    InitDataBlock(); 
    // 根据index iter设置data iter  
    if (data_iter_.iter() != NULL)data_iter_.Seek(target); 
    // 调整data iter跳转到target  
    SkipEmptyDataBlocksForward(); 
    // 调整iter，跳过空的block  
}  

void TwoLevelIterator::SeekToFirst() 
{  
    index_iter_.SeekToFirst();  
    InitDataBlock();              // 根据index iter设置data iter  
    if (data_iter_.iter() != NULL)data_iter_.SeekToFirst();  
    SkipEmptyDataBlocksForward(); // 调整iter，跳过空的block  
} 

void TwoLevelIterator::SeekToLast() 
{  
    index_iter_.SeekToLast();  
    InitDataBlock();              // 根据index iter设置data iter  
    if (data_iter_.iter() != NULL)data_iter_.SeekToLast();  
    SkipEmptyDataBlocksBackward();// 调整iter，跳过空的block  
}

void TwoLevelIterator::Next() 
{  
     assert(Valid());  
     data_iter_.Next();  
     SkipEmptyDataBlocksForward(); // 调整iter，跳过空的block  
}  

void TwoLevelIterator::Prev()
{  
     assert(Valid());  
     data_iter_.Prev();  
     SkipEmptyDataBlocksBackward();// 调整iter，跳过空的block  
}  
</code></pre><h4 id="663-blockreader">6.6.3 BlockReader()</h4>
<p>上面<strong>传递给twolevel Iterator的函数是Table::BlockReader函数</strong>，声明如下：</p>
<pre tabindex="0"><code>static Iterator* Table::BlockReader(void* arg, const ReadOptions&amp;options,
                                  constSlice&amp; index_value);
</code></pre><p>它根据参数指明的<strong>blockdata</strong>，返回一个iterator对象，调用者就可以通过这个iterator对象遍历blockdata存储的k/v对，这其中用到了<strong>LRUCache</strong>。
函数实现逻辑如下：</p>
<h5 id="s1-从参数中解析出blockhandle对象其中arg就是table对象index_value存储的是blockhandle对象读取block的索引">S1 从参数中解析出BlockHandle对象，其中arg就是Table对象，index_value存储的是BlockHandle对象，读取Block的索引。</h5>
<pre tabindex="0"><code>Table* table =reinterpret_cast&lt;Table*&gt;(arg);  
Block* block = NULL;  
Cache::Handle* cache_handle =NULL;  
BlockHandle handle;  
Slice input = index_value;  
Status s =handle.DecodeFrom(&amp;input);
</code></pre><h5 id="s2-根据block-handle首先尝试从cache中直接取出block不在cache中则调用readblock从文件读取读取成功后根据option尝试将block加入到lru-cache中并在insert的时候注册了释放函数deletecachedblock">S2 根据block handle，首先尝试从cache中直接取出block，不在cache中则调用ReadBlock从文件读取，读取成功后，根据option尝试将block加入到LRU cache中。并在Insert的时候注册了释放函数DeleteCachedBlock。</h5>
<pre tabindex="0"><code>Cache* block_cache =table-&gt;rep_-&gt;options.block_cache;  
BlockContents contents;  
if (block_cache != NULL)
{  
     char cache_key_buffer[16]; 
     // cache key的格式为table.cache_id + offset  
     EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);  
     EncodeFixed64(cache_key_buffer+8, handle.offset());  
     Slice key(cache_key_buffer,sizeof(cache_key_buffer));  
     cache_handle =block_cache-&gt;Lookup(key); // 尝试从LRU cache中查找  
     if (cache_handle != NULL)
     { 
          // 找到则直接取值  
          block =reinterpret_cast&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));  
     } 
     else 
     { 
          // 否则直接从文件读取  
          s =ReadBlock(table-&gt;rep_-&gt;file, 
                       options, handle, &amp;contents);  
          if (s.ok()) 
          {  
               block = new Block(contents);  
               if (contents.cachable&amp;&amp; options.fill_cache) 
               // 尝试加到cache中  
              cache_handle =block_cache-&gt;Insert(key, block,block-&gt;size(), &amp;DeleteCachedBlock);  
         }  
     }  
} 
else
{  
     s =ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);  
     if (s.ok()) block = newBlock(contents);  
}
</code></pre><h5 id="s3-如果读取到了block调用blocknewiterator接口创建iterator如果cache-handle为null则注册deleteblock否则注册releaseblock事后清理">S3 如果读取到了block，调用Block::NewIterator接口创建Iterator，如果cache handle为NULL，则注册DeleteBlock，否则注册ReleaseBlock，事后清理。</h5>
<pre tabindex="0"><code>Iterator* iter;  
if (block != NULL)
{  
    iter =block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);  
    if (cache_handle == NULL)  iter-&gt;RegisterCleanup(&amp;DeleteBlock,block, NULL);  
    else iter-&gt;RegisterCleanup(&amp;ReleaseBlock,block_cache, cache_handle);  
} 
else iter = NewErrorIterator(s); 
</code></pre><p>处理结束，最后<strong>返回iter</strong>。这里简单列下这几个<strong>静态函数</strong>，都很简单：</p>
<pre tabindex="0"><code>static void DeleteBlock(void* arg, void* ignored) 
{ 
     deletereinterpret_cast&lt;Block*&gt;(arg);
} 

static void DeleteCachedBlock(const Slice&amp; key, void* value)   
{  
      Block* block =reinterpret_cast&lt;Block*&gt;(value);  
      delete block;  
} 

static void ReleaseBlock(void* arg, void* h) 
{  
      Cache* cache =reinterpret_cast&lt;Cache*&gt;(arg);  
      Cache::Handle* handle =reinterpret_cast&lt;Cache::Handle*&gt;(h);  
      cache-&gt;Release(handle);  
} 
</code></pre><h3 id="67-定位key">6.7 定位key</h3>
<p>这里并不是精确的定位，而是在Table中找到<strong>第一个&gt;=指定key的k/v对</strong>，然后返回其value在sstable文件中的偏移。也是Table类的一个接口：</p>
<pre tabindex="0"><code>uint64_t ApproximateOffsetOf(const Slice&amp; key) const;
</code></pre><p>函数实现比较简单：</p>
<h5 id="s1-调用blockiter的seek函数定位">S1 调用Block::Iter的Seek函数定位</h5>
<pre tabindex="0"><code>Iterator* index_iter=rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);  
index_iter-&gt;Seek(key);  
uint64_t result; 
</code></pre><h5 id="s2-如果index_iter是合法的值并且decode成功返回结果offset">S2 如果index_iter是合法的值，并且Decode成功，返回结果offset。</h5>
<pre tabindex="0"><code>BlockHandle handle;  
handle.DecodeFrom(&amp;index_iter-&gt;value());  
result = handle.offset(); 
</code></pre><h5 id="s3-其它情况设置result为rep_-metaindex_handleoffsetmetaindex的偏移在文件结尾附近">S3 其它情况，设置result为rep_-&gt;metaindex_handle.offset()，metaindex的偏移在文件结尾附近。</h5>
<h3 id="68-获取keyinternalget">6.8 获取Key—InternalGet()</h3>
<p><strong>InternalGet</strong>，这是为TableCache开的一个口子。这是一个<strong>private函数</strong>，声明为：</p>
<pre tabindex="0"><code>Status Table::InternalGet(const ReadOptions&amp; options, constSlice&amp; k,
                          void*arg, void (*saver)(void*, const Slice&amp;, const Slice&amp;))
</code></pre><p>其中又有函数指针，在找到数据后，就调用传入的<strong>函数指针save</strong>r执行调用者的自定义处理逻辑，并且<strong>TableCache</strong>可能会做缓存。
函数逻辑如下：</p>
<h5 id="s1-首先根据传入的key定位数据这需要indexblock的iterator">S1 首先根据传入的key定位数据，这需要indexblock的Iterator。</h5>
<pre tabindex="0"><code>Iterator* iiter =rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);  
iiter-&gt;Seek(k); 
</code></pre><h5 id="s2-如果key是合法的取出其filter指针如果使用了filter则检查key是否存在这可以快速判断提升效率">S2 如果key是合法的，取出其filter指针，如果使用了filter，则检查key是否存在，这可以快速判断，提升效率。</h5>
<pre tabindex="0"><code>Status s;  
Slice handle_value =iiter-&gt;value();  
FilterBlockReader* filter = rep_-&gt;filter;  
BlockHandle handle;  
if (filter != NULL &amp;&amp; handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp; !filter-&gt;KeyMayMatch(handle.offset(),k)) 
{ 
    // key不存在  
} 
else
{
    // 否则就要读取block，并查找其k/v对  
    Slice handle = iiter-&gt;value();  
    Iterator* block_iter =BlockReader(this, options, iiter-&gt;value());  
    block_iter-&gt;Seek(k);  
    if (block_iter-&gt;Valid())(*saver)(arg, block_iter-&gt;key(), block_iter-&gt;value());  
    s = block_iter-&gt;status();  
    delete block_iter;  
}
</code></pre><h5 id="s3-最后返回结果删除临时变量">S3 最后返回结果，删除临时变量。</h5>
<pre tabindex="0"><code>if (s.ok()) s =iiter-&gt;status();  
delete iiter;  
return s; 
</code></pre><p>随着有关<strong>sstable文件读取</strong>的结束，sstable的源码也就分析完了，其中我们还遗漏了一些功课要做，那就是<strong>Filter和TableCache</strong>部分。</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/blog/1776ae3c50104b7ea0c90cf31322958a/">
    <span class="title">« Prev</span>
    <br>
    <span>leveldb源码分析1</span>
  </a>
  <a class="next" href="https://haokiu.com/blog/0159e326ba0e4917878529ee1ae3af48/">
    <span class="title">Next »</span>
    <br>
    <span>leveldb源码分析11</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
