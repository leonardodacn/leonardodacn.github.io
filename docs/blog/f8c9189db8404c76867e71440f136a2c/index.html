<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>从零开发一个WebSocket服务器 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="从零开发一个WebSocket服务器 WebSocket 协议是为了解决 http 协议的无状态、短连接（通常是）和服务端无法主动给客户端推送数据等问题而开发的新型协议，其通信基础也是基于 TCP。由于较旧的浏览器可能不支持 WebSocket 协议，所以使用 WebSocket 协议的通信双方在进行 TCP 三次握手之后，还要再额外地进行一次握手，这一次的握手通信双方的报文格式是基于 HTTP 协议改造的。
WebSocket 握手过程 TCP 三次握手的过程我们就不在这里赘述了，任何一本网络通信书籍上都有详细的介绍。我们这里来介绍一下 WebSocket 通信最后一次的握手过程。
握手开始后，一方给另外一方发送一个 http 协议格式的报文，这个报文格式大致如下：
GET /realtime HTTP/1.1\r\n Host: 127.0.0.1:9989\r\n Connection: Upgrade\r\n Pragma: no-cache\r\n Cache-Control: no-cache\r\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\r\n Upgrade: websocket\r\n Origin: http://xyz.com\r\n Sec-WebSocket-Version: 13\r\n Accept-Encoding: gzip, deflate, br\r\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n Sec-WebSocket-Key: IqcAWodjyPDJuhGgZwkpKg==\r\n Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n \r\n 对这个格式有如下要求：
握手必须是一个有效的 HTTP 请求； 请求的方法必须为 GET，且 HTTP 版本必须是 1.1； 请求必须包含 Host 字段信息； 请求必须包含 Upgrade字段信息，值必须为 websocket； 请求必须包含 Connection 字段信息，值必须为 Upgrade； 请求必须包含 Sec-WebSocket-Key 字段，该字段值是客户端的标识编码成 base64 格式； 请求必须包含 Sec-WebSocket-Version 字段信息，值必须为 13； 请求必须包含 Origin 字段； 请求可能包含 Sec-WebSocket-Protocol 字段，规定子协议； 请求可能包含 Sec-WebSocket-Extensions字段规定协议扩展； 请求可能包含其他字段，如 cookie 等。 对端收到该数据包后如果支持 WebSocket 协议，会回复一个 http 格式的应答，这个应答报文的格式大致如下：">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/blog/f8c9189db8404c76867e71440f136a2c/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="从零开发一个WebSocket服务器" />
<meta property="og:description" content="从零开发一个WebSocket服务器 WebSocket 协议是为了解决 http 协议的无状态、短连接（通常是）和服务端无法主动给客户端推送数据等问题而开发的新型协议，其通信基础也是基于 TCP。由于较旧的浏览器可能不支持 WebSocket 协议，所以使用 WebSocket 协议的通信双方在进行 TCP 三次握手之后，还要再额外地进行一次握手，这一次的握手通信双方的报文格式是基于 HTTP 协议改造的。
WebSocket 握手过程 TCP 三次握手的过程我们就不在这里赘述了，任何一本网络通信书籍上都有详细的介绍。我们这里来介绍一下 WebSocket 通信最后一次的握手过程。
握手开始后，一方给另外一方发送一个 http 协议格式的报文，这个报文格式大致如下：
GET /realtime HTTP/1.1\r\n Host: 127.0.0.1:9989\r\n Connection: Upgrade\r\n Pragma: no-cache\r\n Cache-Control: no-cache\r\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\r\n Upgrade: websocket\r\n Origin: http://xyz.com\r\n Sec-WebSocket-Version: 13\r\n Accept-Encoding: gzip, deflate, br\r\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n Sec-WebSocket-Key: IqcAWodjyPDJuhGgZwkpKg==\r\n Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n \r\n 对这个格式有如下要求：
握手必须是一个有效的 HTTP 请求； 请求的方法必须为 GET，且 HTTP 版本必须是 1.1； 请求必须包含 Host 字段信息； 请求必须包含 Upgrade字段信息，值必须为 websocket； 请求必须包含 Connection 字段信息，值必须为 Upgrade； 请求必须包含 Sec-WebSocket-Key 字段，该字段值是客户端的标识编码成 base64 格式； 请求必须包含 Sec-WebSocket-Version 字段信息，值必须为 13； 请求必须包含 Origin 字段； 请求可能包含 Sec-WebSocket-Protocol 字段，规定子协议； 请求可能包含 Sec-WebSocket-Extensions字段规定协议扩展； 请求可能包含其他字段，如 cookie 等。 对端收到该数据包后如果支持 WebSocket 协议，会回复一个 http 格式的应答，这个应答报文的格式大致如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/blog/f8c9189db8404c76867e71440f136a2c/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="从零开发一个WebSocket服务器"/>
<meta name="twitter:description" content="从零开发一个WebSocket服务器 WebSocket 协议是为了解决 http 协议的无状态、短连接（通常是）和服务端无法主动给客户端推送数据等问题而开发的新型协议，其通信基础也是基于 TCP。由于较旧的浏览器可能不支持 WebSocket 协议，所以使用 WebSocket 协议的通信双方在进行 TCP 三次握手之后，还要再额外地进行一次握手，这一次的握手通信双方的报文格式是基于 HTTP 协议改造的。
WebSocket 握手过程 TCP 三次握手的过程我们就不在这里赘述了，任何一本网络通信书籍上都有详细的介绍。我们这里来介绍一下 WebSocket 通信最后一次的握手过程。
握手开始后，一方给另外一方发送一个 http 协议格式的报文，这个报文格式大致如下：
GET /realtime HTTP/1.1\r\n Host: 127.0.0.1:9989\r\n Connection: Upgrade\r\n Pragma: no-cache\r\n Cache-Control: no-cache\r\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\r\n Upgrade: websocket\r\n Origin: http://xyz.com\r\n Sec-WebSocket-Version: 13\r\n Accept-Encoding: gzip, deflate, br\r\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n Sec-WebSocket-Key: IqcAWodjyPDJuhGgZwkpKg==\r\n Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n \r\n 对这个格式有如下要求：
握手必须是一个有效的 HTTP 请求； 请求的方法必须为 GET，且 HTTP 版本必须是 1.1； 请求必须包含 Host 字段信息； 请求必须包含 Upgrade字段信息，值必须为 websocket； 请求必须包含 Connection 字段信息，值必须为 Upgrade； 请求必须包含 Sec-WebSocket-Key 字段，该字段值是客户端的标识编码成 base64 格式； 请求必须包含 Sec-WebSocket-Version 字段信息，值必须为 13； 请求必须包含 Origin 字段； 请求可能包含 Sec-WebSocket-Protocol 字段，规定子协议； 请求可能包含 Sec-WebSocket-Extensions字段规定协议扩展； 请求可能包含其他字段，如 cookie 等。 对端收到该数据包后如果支持 WebSocket 协议，会回复一个 http 格式的应答，这个应答报文的格式大致如下："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "从零开发一个WebSocket服务器",
      "item": "https://haokiu.com/blog/f8c9189db8404c76867e71440f136a2c/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从零开发一个WebSocket服务器",
  "name": "从零开发一个WebSocket服务器",
  "description": "从零开发一个WebSocket服务器 WebSocket 协议是为了解决 http 协议的无状态、短连接（通常是）和服务端无法主动给客户端推送数据等问题而开发的新型协议，其通信基础也是基于 TCP。由于较旧的浏览器可能不支持 WebSocket 协议，所以使用 WebSocket 协议的通信双方在进行 TCP 三次握手之后，还要再额外地进行一次握手，这一次的握手通信双方的报文格式是基于 HTTP 协议改造的。\nWebSocket 握手过程 TCP 三次握手的过程我们就不在这里赘述了，任何一本网络通信书籍上都有详细的介绍。我们这里来介绍一下 WebSocket 通信最后一次的握手过程。\n握手开始后，一方给另外一方发送一个 http 协议格式的报文，这个报文格式大致如下：\nGET /realtime HTTP/1.1\\r\\n Host: 127.0.0.1:9989\\r\\n Connection: Upgrade\\r\\n Pragma: no-cache\\r\\n Cache-Control: no-cache\\r\\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\\r\\n Upgrade: websocket\\r\\n Origin: http://xyz.com\\r\\n Sec-WebSocket-Version: 13\\r\\n Accept-Encoding: gzip, deflate, br\\r\\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n Sec-WebSocket-Key: IqcAWodjyPDJuhGgZwkpKg==\\r\\n Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\\r\\n \\r\\n 对这个格式有如下要求：\n握手必须是一个有效的 HTTP 请求； 请求的方法必须为 GET，且 HTTP 版本必须是 1.1； 请求必须包含 Host 字段信息； 请求必须包含 Upgrade字段信息，值必须为 websocket； 请求必须包含 Connection 字段信息，值必须为 Upgrade； 请求必须包含 Sec-WebSocket-Key 字段，该字段值是客户端的标识编码成 base64 格式； 请求必须包含 Sec-WebSocket-Version 字段信息，值必须为 13； 请求必须包含 Origin 字段； 请求可能包含 Sec-WebSocket-Protocol 字段，规定子协议； 请求可能包含 Sec-WebSocket-Extensions字段规定协议扩展； 请求可能包含其他字段，如 cookie 等。 对端收到该数据包后如果支持 WebSocket 协议，会回复一个 http 格式的应答，这个应答报文的格式大致如下：",
  "keywords": [
    
  ],
  "articleBody": "从零开发一个WebSocket服务器 WebSocket 协议是为了解决 http 协议的无状态、短连接（通常是）和服务端无法主动给客户端推送数据等问题而开发的新型协议，其通信基础也是基于 TCP。由于较旧的浏览器可能不支持 WebSocket 协议，所以使用 WebSocket 协议的通信双方在进行 TCP 三次握手之后，还要再额外地进行一次握手，这一次的握手通信双方的报文格式是基于 HTTP 协议改造的。\nWebSocket 握手过程 TCP 三次握手的过程我们就不在这里赘述了，任何一本网络通信书籍上都有详细的介绍。我们这里来介绍一下 WebSocket 通信最后一次的握手过程。\n握手开始后，一方给另外一方发送一个 http 协议格式的报文，这个报文格式大致如下：\nGET /realtime HTTP/1.1\\r\\n Host: 127.0.0.1:9989\\r\\n Connection: Upgrade\\r\\n Pragma: no-cache\\r\\n Cache-Control: no-cache\\r\\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\\r\\n Upgrade: websocket\\r\\n Origin: http://xyz.com\\r\\n Sec-WebSocket-Version: 13\\r\\n Accept-Encoding: gzip, deflate, br\\r\\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n Sec-WebSocket-Key: IqcAWodjyPDJuhGgZwkpKg==\\r\\n Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\\r\\n \\r\\n 对这个格式有如下要求：\n握手必须是一个有效的 HTTP 请求； 请求的方法必须为 GET，且 HTTP 版本必须是 1.1； 请求必须包含 Host 字段信息； 请求必须包含 Upgrade字段信息，值必须为 websocket； 请求必须包含 Connection 字段信息，值必须为 Upgrade； 请求必须包含 Sec-WebSocket-Key 字段，该字段值是客户端的标识编码成 base64 格式； 请求必须包含 Sec-WebSocket-Version 字段信息，值必须为 13； 请求必须包含 Origin 字段； 请求可能包含 Sec-WebSocket-Protocol 字段，规定子协议； 请求可能包含 Sec-WebSocket-Extensions字段规定协议扩展； 请求可能包含其他字段，如 cookie 等。 对端收到该数据包后如果支持 WebSocket 协议，会回复一个 http 格式的应答，这个应答报文的格式大致如下：\nHTTP/1.1 101 Switching Protocols\\r\\n Upgrade: websocket\\r\\n Connection: Upgrade\\r\\n Sec-WebSocket-Accept: 5wC5L6joP6tl31zpj9OlCNv9Jy4=\\r\\n \\r\\n 上面列出了应答报文中必须包含的几个字段和对应的值，即 Upgrade、Connection、Sec-WebSocket-Accept，注意：第一行必须是 HTTP/1.1 101 Switching Protocols\\r\\n。\n对于字段 Sec-WebSocket-Accept 字段，其值是根据对端传过来的 Sec-WebSocket-Key 的值经过一定的算法计算出来的，这样应答的双方才能匹配。算法如下：\n将 Sec-WebSocket-Key 值与固定字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 进行拼接； 将拼接后的字符串进行 SHA-1 处理，然后将结果再进行 base64 编码。 算法公式：\nmask = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"; // 这是算法中要用到的固定字符串 accept = base64( sha1( Sec-WebSocket-Key + mask ) ); 我用 C++ 实现了该算法：\nnamespace uWS { struct WebSocketHandshake { template struct static_for { void operator()(uint32_t *a, uint32_t *b) { static_for()(a, b); T::template f(a, b); } }; template struct static_for\u003c0, T\u003e { void operator()(uint32_t *a, uint32_t *hash) {} }; template struct Sha1Loop { static inline uint32_t rol(uint32_t value, size_t bits) {return (value \u003c\u003c bits) | (value \u003e\u003e (32 - bits));} static inline uint32_t blk(uint32_t b[16], size_t i) { return rol(b[(i + 13) \u0026 15] ^ b[(i + 8) \u0026 15] ^ b[(i + 2) \u0026 15] ^ b[i], 1); } template static inline void f(uint32_t *a, uint32_t *b) { switch (state) { case 1: a[i % 5] += ((a[(3 + i) % 5] \u0026 (a[(2 + i) % 5] ^ a[(1 + i) % 5])) ^ a[(1 + i) % 5]) + b[i] + 0x5a827999 + rol(a[(4 + i) % 5], 5); a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30); break; case 2: b[i] = blk(b, i); a[(1 + i) % 5] += ((a[(4 + i) % 5] \u0026 (a[(3 + i) % 5] ^ a[(2 + i) % 5])) ^ a[(2 + i) % 5]) + b[i] + 0x5a827999 + rol(a[(5 + i) % 5], 5); a[(4 + i) % 5] = rol(a[(4 + i) % 5], 30); break; case 3: b[(i + 4) % 16] = blk(b, (i + 4) % 16); a[i % 5] += (a[(3 + i) % 5] ^ a[(2 + i) % 5] ^ a[(1 + i) % 5]) + b[(i + 4) % 16] + 0x6ed9eba1 + rol(a[(4 + i) % 5], 5); a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30); break; case 4: b[(i + 8) % 16] = blk(b, (i + 8) % 16); a[i % 5] += (((a[(3 + i) % 5] | a[(2 + i) % 5]) \u0026 a[(1 + i) % 5]) | (a[(3 + i) % 5] \u0026 a[(2 + i) % 5])) + b[(i + 8) % 16] + 0x8f1bbcdc + rol(a[(4 + i) % 5], 5); a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30); break; case 5: b[(i + 12) % 16] = blk(b, (i + 12) % 16); a[i % 5] += (a[(3 + i) % 5] ^ a[(2 + i) % 5] ^ a[(1 + i) % 5]) + b[(i + 12) % 16] + 0xca62c1d6 + rol(a[(4 + i) % 5], 5); a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30); break; case 6: b[i] += a[4 - i]; } } }; /** * sha1 函数的实现 */ static inline void sha1(uint32_t hash[5], uint32_t b[16]) { uint32_t a[5] = {hash[4], hash[3], hash[2], hash[1], hash[0]}; static_for\u003c16, Sha1Loop\u003c1\u003e\u003e()(a, b); static_for\u003c4, Sha1Loop\u003c2\u003e\u003e()(a, b); static_for\u003c20, Sha1Loop\u003c3\u003e\u003e()(a, b); static_for\u003c20, Sha1Loop\u003c4\u003e\u003e()(a, b); static_for\u003c20, Sha1Loop\u003c5\u003e\u003e()(a, b); static_for\u003c5, Sha1Loop\u003c6\u003e\u003e()(a, hash); } /** * base64 编码函数 */ static inline void base64(unsigned char *src, char *dst) { const char *b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; for (int i = 0; i \u003c 18; i += 3) { *dst++ = b64[(src[i] \u003e\u003e 2) \u0026 63]; *dst++ = b64[((src[i] \u0026 3) \u003c\u003c 4) | ((src[i + 1] \u0026 240) \u003e\u003e 4)]; *dst++ = b64[((src[i + 1] \u0026 15) \u003c\u003c 2) | ((src[i + 2] \u0026 192) \u003e\u003e 6)]; *dst++ = b64[src[i + 2] \u0026 63]; } *dst++ = b64[(src[18] \u003e\u003e 2) \u0026 63]; *dst++ = b64[((src[18] \u0026 3) \u003c\u003c 4) | ((src[19] \u0026 240) \u003e\u003e 4)]; *dst++ = b64[((src[19] \u0026 15) \u003c\u003c 2)]; *dst++ = '='; } public: /** * 生成 Sec-WebSocket-Accept 算法 * @param input 对端传过来的Sec-WebSocket-Key值 * @param output 存放生成的 Sec-WebSocket-Accept 值 */ static inline void generate(const char input[24], char output[28]) { uint32_t b_output[5] = { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 }; uint32_t b_input[16] = { 0, 0, 0, 0, 0, 0, 0x32353845, 0x41464135, 0x2d453931, 0x342d3437, 0x44412d39, 0x3543412d, 0x43354142, 0x30444338, 0x35423131, 0x80000000 }; for (int i = 0; i \u003c 6; i++) { b_input[i] = (input[4 * i + 3] \u0026 0xff) | (input[4 * i + 2] \u0026 0xff) \u003c\u003c 8 | (input[4 * i + 1] \u0026 0xff) \u003c\u003c 16 | (input[4 * i + 0] \u0026 0xff) \u003c\u003c 24; } sha1(b_output, b_input); uint32_t last_b[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480}; sha1(b_output, last_b); for (int i = 0; i \u003c 5; i++) { uint32_t tmp = b_output[i]; char *bytes = (char *) \u0026b_output[i]; bytes[3] = tmp \u0026 0xff; bytes[2] = (tmp \u003e\u003e 8) \u0026 0xff; bytes[1] = (tmp \u003e\u003e 16) \u0026 0xff; bytes[0] = (tmp \u003e\u003e 24) \u0026 0xff; } base64((unsigned char *) b_output, output); } }; 握手完成之后，通信双方就可以保持连接并相互发送数据了。\nWebSocket 协议格式 WebSocket 协议格式的 RFC 文档可以参见：[]https://tools.ietf.org/html/rfc6455。\n常听人说 WebSocket 协议是基于 http 协议的，因此我在刚接触 WebSocket 协议时总以为每个 WebSocket 数据包都是 http 格式，其实不然，WebSocket 协议除了上文中提到的这次握手过程中使用的数据格式是 http 协议格式，之后的通信双方使用的是另外一种自定义格式。每一个 WebSocket 数据包我们称之为一个 Frame（帧），其格式图如下：\n我们来逐一介绍一下上文中各字段的含义：\n第一个字节内容：\nFIN 标志，占第一个字节中的第一位（bit），即一字节中的最高位（一字节等于 8 位），该标志置 0 时表示当前包未结束后续有该包的分片，置 1 时表示当前包已结束后续无该包的分片。我们在解包时，如果发现该标志为 1，则需要将当前包的“包体”数据（即图中 Payload Data）缓存起来，与后续包分片组装在一起，才是一个完整的包体数据。\nRSV1、RSV2、RSV3 每个占一位，一共三位，这三个位是保留字段（默认都是 0），你可以用它们作为通信的双方协商好的一些特殊标志；\nopCode 操作类型，占四位，目前操作类型及其取值如下：\n// 4 bits enum OpCode { //表示后续还有新的 Frame CONTINUATION_FRAME = 0x0, //包体是文本类型的Frame TEXT_FRAME = 0x1, //包体是二进制类型的 Frame BINARY_FRAME = 0x2, //保留值 RESERVED1 = 0x3, RESERVED2 = 0x4, RESERVED3 = 0x5, RESERVED4 = 0x6, RESERVED5 = 0x7, //建议对端关闭的 Frame CLOSE = 0x8, //心跳包中的 ping Frame PING = 0x9, //心跳包中的 pong Frame PONG = 0xA, //保留值 RESERVED6 = 0xB, RESERVED7 = 0xC, RESERVED8 = 0xD, RESERVED9 = 0xE, RESERVED10 = 0xF }; 第二个字节内容：\nmask 标志，占一位，该标志为 1 时，表明该 Frame 在包体长度字段后面携带 4 个字节的 masking-key 信息，为 0 时则没有 masking-key 信息。masking-key 信息下文会介绍。\nPayload len，占七位，该字段表示包体的长度信息。由于 Payload length 值使用了一个字节的低七位（7 bit），因此其能表示的长度范围是 0 ~ 127，其中 126 和 127 被当做特殊标志使用。\n当该字段值是 0~125 时，表示跟在 masking-key 字段后面的就是包体内容长度；当该值是 126 时，接下来的 2 个字节内容表示跟在 masking-key 字段后面的包体内容的长度（即图中的 Extended Payload Length）。由于 2 个字节最大表示的无符号整数是 0xFFFF（十进制是 65535， 编译器提供了一个宏 UINT16_MAX 来表示这个值）。如果包体长度超过 65535，包长度就记录不下了，此时应该将 Payload length 设置为 127，以使用更多的字节数来表示包体长度。\n当 Payload length 是 127 时，接下来则用 8 个字节内容表示跟在 masking-key 字段后面的包体内容的长度（Extended Payload Length）。\n总结起来，Payload length = 0 ~ 125，Extended Payload Length 不存在， 0 字节；Payload length = 126, Extended Payload Length 占 2 字节；Payload length = 127 时，Extended Payload Length 占 8 字节。\n另外需要注意的是，当 Payload length = 125 或 126 时接下来存储实际包长的 2 字节或 8 字节，其值必须转换为网络字节序（Big Endian）。\nMasking-key ，如果前面的 mask 标志设置成 1，则该字段存在，占 4 个字节；反之，则 Frame 中不存在存储 masking-key 字段的字节。 网络上一些资料说，客户端（主动发起握手请求的一方）给服务器（被动接受握手的另一方）发的 frame 信息（包信息），mask 标志必须是 1，而服务器给客户端发送的 frame 信息中 mask 标志是 0。因此，客户端发给服务器端的数据帧中存在 4 字节的 masking-key，而服务器端发给客户端的数据帧中不存在 masking-key 信息。\n我在 Websocket 协议的 RFC 文档中并没有看到有这种强行规定，另外在研究了一些 websocket 库的实现后发现，此结论并不一定成立，客户端发送的数据也可能没有设置 mask 标志。\n如果存在 masking-key 信息，则数据帧中的数据（图中 Payload Data）都是经过与 masking-key 进行运算后的内容。无论是将原始数据与 masking-key 运算后得到传输的数据，还是将传输的数据还原成原始数据，其算法都是一样的。算法如下：\n假设： original-octet-i：为原始数据的第 i 字节。 transformed-octet-i：为转换后的数据的第 i 字节。 j：为i mod 4的结果。 masking-key-octet-j：为 mask key 第 j 字节。 算法描述为：original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。\nj = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j 我用 C++ 实现了该算法：\n/** * @param src 函数调用前是原始需要传输的数据，函数调用后是mask或者unmask后的内容 * @param maskingKey 四字节 */ void maskAndUnmaskData(std::string\u0026 src, const char* maskingKey) { char j; for (size_t n = 0; n \u003c src.length(); ++n) { j = n % 4; src[n] = src[n] ^ maskingKey[j]; } } 使用上面的描述可能还不是太清楚，我们举个例子，假设有一个客户端发送给服务器的数据包，那么 mask = 1，即存在 4 字节的 masking-key，当包体数据长度在 0 ~ 125 之间时，该包的结构：\n第 1 个字节第 0 位 =\u003e FIN 第 1 个字节第 1 ~ 3位 =\u003e RSV1 + RSV2 + RSV3 第 1 个字节第 4 ~ 7位 =\u003e opcode 第 2 个字节第 0 位 =\u003e mask(等于 1) 第 2 个字节第 1 ~ 7位 =\u003e 包体长度 第 3 ~ 6 个字节 =\u003e masking-key 第 7 个字节及以后 =\u003e 包体内容 这种情形，包头总共 6 个字节。\n当包体数据长度大于125 且小于等于 UINT16_MAX 时，该包的结构：\n第 1 个字节第 0 位 =\u003e FIN 第 1 个字节第 1 ~ 3位 =\u003e RSV1 + RSV2 + RSV3 第 1 个字节第 4 ~ 7位 =\u003e opcode 第 2 个字节第 0 位 =\u003e mask(等于 1) 第 2 个字节第 1 ~ 7位 =\u003e 开启扩展包头长度标志，值为 126 第 3 ~ 4 个字节 =\u003e 包头长度 第 5 ~ 8 个字节 =\u003e masking-key 第 9 个字节及以后 =\u003e 包体内容 这种情形，包头总共 8 个字节。\n当包体数据长度大于 UINT16_MAX 时，该包的结构：\n第 1 个字节第 0 位 =\u003e FIN 第 1 个字节第 1 ~ 3位 =\u003e RSV1 + RSV2 + RSV3 第 1 个字节第 4 ~ 7位 =\u003e opcode 第 2 个字节第 0 位 =\u003e mask(等于 1) 第 2 个字节第 1 ~ 7位 =\u003e 开启扩展包头长度标志，值为 127 第 3 ~ 10 个字节 =\u003e 包头长度 第 11 ~ 14 个字节 =\u003e masking-key 第 15 个字节及以后 =\u003e 包体内容 这种情形，包头总共 14 个字节。由于存储包体长度使用 8 字节存储（无符号），因此最大包体长度是 0xFFFFFFFFFFFFFFFF，这是一个非常大的数字，但实际开发中，我们用不到这么长的包体，且当包体超过一定值时，我们就应该分包（分片）了。\n分包的逻辑经过前面的分析也很简单，假设将一个包分成 3 片，那么应将第一个和第二个包片的第一个字节的第一位 FIN 设置为 0，OpCode 设置为 CONTINUATION_FRAME（也是 0）；第三个包片 FIN 设置为 1，表示该包至此就结束了，OpCode 设置为想要的类型（如 TEXT_FRAME、BINARY_FRAME 等）。对端收到该包时，如果发现标志 FIN = 0 或 OpCode = 0，将该包包体的数据暂存起来，直到收到 FIN = 1，OpCode ≠ 0 的包，将该包的数据与前面收到的数据放在一起，组装成一个完整的业务数据。示例代码如下：\n//某次解包后得到包体 payloadData，根据 FIN 标志判断， //如果 FIN = true，则说明一个完整的业务数据包已经收完整， //调用 processPackage() 函数处理该业务数据 //否则，暂存于 m_strParsedData 中 //每次处理完一个完整的业务包数据，即将暂存区m_strParsedData中的数据清空 if (FIN) { m_strParsedData.append(payloadData); processPackage(m_strParsedData); m_strParsedData.clear(); } else { m_strParsedData.append(payloadData); } WebSocket 压缩格式 WebSocket 对于包体也支持压缩的，是否需要开启压缩需要通信双方在握手时进行协商。让我们再看一下握手时主动发起一方的包内容：\nGET /realtime HTTP/1.1\\r\\n Host: 127.0.0.1:9989\\r\\n Connection: Upgrade\\r\\n Pragma: no-cache\\r\\n Cache-Control: no-cache\\r\\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\\r\\n Upgrade: websocket\\r\\n Origin: http://xyz.com\\r\\n Sec-WebSocket-Version: 13\\r\\n Accept-Encoding: gzip, deflate, br\\r\\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n Sec-WebSocket-Key: IqcAWodjyPDJuhGgZwkpKg==\\r\\n Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\\r\\n \\r\\n 在该包中 Sec-WebSocket-Extensions 字段中有一个值 permessage-deflate，如果发起方支持压缩，在发起握手时将包中带有该标志，对端收到后，如果也支持压缩，则在应答的包也带有该字段，反之不带该标志即表示不支持压缩。例如：\nHTTP/1.1 101 Switching Protocols\\r\\n Upgrade: websocket\\r\\n Connection: Upgrade\\r\\n Sec-WebSocket-Accept: 5wC5L6joP6tl31zpj9OlCNv9Jy4=\\r\\n Sec-WebSocket-Extensions: permessage-deflate; client_no_context_takeover \\r\\n 如果双方都支持压缩，此后通信的包中的包体部分都是经过压缩后的，反之是未压缩过的。在解完包得到包体（即 Payload Data） 后，如果有握手时有压缩标志并且乙方也回复了支持压缩，则需要对该包体进行解压；同理，在发数据组装 WebSocket 包时，需要先将包体（即 Payload Data）进行压缩。\n收到包需要解压示例代码：\nbool MyWebSocketSession::processPackage(const std::string\u0026 data) { std::string out; //m_bClientCompressed在握手确定是否支持压缩 if (m_bClientCompressed) { //解压 if (!ZlibUtil::inflate(data, out)) { LOGE(\"uncompress failed, dataLength: %d\", data.length()); return false; } } else out = data; //如果不需要解压，则out=data，反之则out是解压后的数据 LOGI(\"receid data: %s\", out.c_str()); return Process(out); } 对包进行压缩的算法：\nsize_t dataLength = data.length(); std::string destbuf; if (m_bClientCompressed) { //按需压缩 if (!ZlibUtil::deflate(data, destbuf)) { LOGE(\"compress buf error, data: %s\", data.c_str()); return; } } else destbuf = data; LOGI(\"destbuf.length(): %d\", destbuf.length()); 压缩和解压算法即 gzip 压缩算法。\n由于公众号文章最大是 5000 字数限制，本文原文一共有 12000 字，公众号发文时有省略。如果想获取完整的文章请在【高性能服务器开发】公众号后台回复 关键字【websocket协议分析】。获取文中完整源码，请在公众号后台回复关键字【websocket源码】。\n",
  "wordCount" : "1670",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/blog/f8c9189db8404c76867e71440f136a2c/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      从零开发一个WebSocket服务器
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%8f%91%e4%b8%80%e4%b8%aawebsocket%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="从零开发一个WebSocket服务器">从零开发一个WebSocket服务器</a><ul>
                        <ul>
                        
                <li>
                    <a href="#websocket-%e6%8f%a1%e6%89%8b%e8%bf%87%e7%a8%8b" aria-label="WebSocket 握手过程">WebSocket 握手过程</a></li>
                <li>
                    <a href="#websocket-%e5%8d%8f%e8%ae%ae%e6%a0%bc%e5%bc%8f" aria-label="WebSocket 协议格式">WebSocket 协议格式</a></li>
                <li>
                    <a href="#websocket-%e5%8e%8b%e7%bc%a9%e6%a0%bc%e5%bc%8f" aria-label="WebSocket 压缩格式">WebSocket 压缩格式</a>
                </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="从零开发一个websocket服务器">从零开发一个WebSocket服务器</h2>
<p>WebSocket 协议是为了解决 http 协议的无状态、短连接（通常是）和服务端无法主动给客户端推送数据等问题而开发的新型协议，其通信基础也是基于 TCP。由于较旧的浏览器可能不支持 WebSocket 协议，所以使用 WebSocket 协议的通信双方在进行 TCP 三次握手之后，还要再额外地进行一次握手，这一次的握手通信双方的报文格式是基于 HTTP 协议改造的。</p>
<h4 id="websocket-握手过程">WebSocket 握手过程</h4>
<p>TCP 三次握手的过程我们就不在这里赘述了，任何一本网络通信书籍上都有详细的介绍。我们这里来介绍一下 WebSocket 通信最后一次的握手过程。</p>
<p>握手开始后，一方给另外一方发送一个 http 协议格式的报文，这个报文格式大致如下：</p>
<pre tabindex="0"><code>GET /realtime HTTP/1.1\r\n
Host: 127.0.0.1:9989\r\n
Connection: Upgrade\r\n
Pragma: no-cache\r\n
Cache-Control: no-cache\r\n
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\r\n
Upgrade: websocket\r\n
Origin: http://xyz.com\r\n
Sec-WebSocket-Version: 13\r\n
Accept-Encoding: gzip, deflate, br\r\n
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n
Sec-WebSocket-Key: IqcAWodjyPDJuhGgZwkpKg==\r\n
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n
\r\n
</code></pre><p>对这个格式有如下要求：</p>
<ul>
<li>握手必须是一个有效的 HTTP 请求；</li>
<li>请求的方法必须为 GET，且 HTTP 版本必须是 1.1；</li>
<li>请求必须包含 Host 字段信息；</li>
<li>请求必须包含 Upgrade字段信息，值必须为 websocket；</li>
<li>请求必须包含 Connection 字段信息，值必须为 Upgrade；</li>
<li><strong>请求必须包含 Sec-WebSocket-Key 字段，该字段值是客户端的标识编码成 base64 格式</strong>；</li>
<li>请求必须包含 Sec-WebSocket-Version 字段信息，值必须为 13；</li>
<li>请求必须包含 Origin 字段；</li>
<li>请求可能包含 Sec-WebSocket-Protocol 字段，规定子协议；</li>
<li>请求可能包含 Sec-WebSocket-Extensions字段规定协议扩展；</li>
<li>请求可能包含其他字段，如 cookie 等。</li>
</ul>
<p>对端收到该数据包后如果支持 WebSocket 协议，会回复一个 http 格式的应答，这个应答报文的格式大致如下：</p>
<pre tabindex="0"><code>HTTP/1.1 101 Switching Protocols\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
Sec-WebSocket-Accept: 5wC5L6joP6tl31zpj9OlCNv9Jy4=\r\n
\r\n
</code></pre><p>上面列出了应答报文中必须包含的几个字段和对应的值，即 <strong>Upgrade</strong>、<strong>Connection</strong>、<strong>Sec-WebSocket-Accept</strong>，注意：第一行必须是 <strong>HTTP/1.1 101 Switching Protocols\r\n</strong>。</p>
<p>对于字段 <strong>Sec-WebSocket-Accept</strong> 字段，其值是根据对端传过来的 <strong>Sec-WebSocket-Key</strong> 的值经过一定的算法计算出来的，这样应答的双方才能匹配。算法如下：</p>
<ol>
<li>将 Sec-WebSocket-Key 值与固定字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 进行拼接；</li>
<li>将拼接后的字符串进行 SHA-1 处理，然后将结果再进行 base64 编码。</li>
</ol>
<p>算法公式：</p>
<pre tabindex="0"><code>mask  = &#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34;;  // 这是算法中要用到的固定字符串
accept = base64( sha1( Sec-WebSocket-Key + mask ) );
</code></pre><p>我用 C++ 实现了该算法：</p>
<pre tabindex="0"><code>namespace uWS {

struct WebSocketHandshake {
    template &lt;int N, typename T&gt;
    struct static_for {
        void operator()(uint32_t *a, uint32_t *b) {
            static_for&lt;N - 1, T&gt;()(a, b);
            T::template f&lt;N - 1&gt;(a, b);
        }
    };

    template &lt;typename T&gt;
    struct static_for&lt;0, T&gt; {
        void operator()(uint32_t *a, uint32_t *hash) {}
    };

    template &lt;int state&gt;
    struct Sha1Loop {
        static inline uint32_t rol(uint32_t value, size_t bits) {return (value &lt;&lt; bits) | (value &gt;&gt; (32 - bits));}
        static inline uint32_t blk(uint32_t b[16], size_t i) {
            return rol(b[(i + 13) &amp; 15] ^ b[(i + 8) &amp; 15] ^ b[(i + 2) &amp; 15] ^ b[i], 1);
        }

        template &lt;int i&gt;
        static inline void f(uint32_t *a, uint32_t *b) {
            switch (state) {
            case 1:
                a[i % 5] += ((a[(3 + i) % 5] &amp; (a[(2 + i) % 5] ^ a[(1 + i) % 5])) ^ a[(1 + i) % 5]) + b[i] + 0x5a827999 + rol(a[(4 + i) % 5], 5);
                a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30);
                break;
            case 2:
                b[i] = blk(b, i);
                a[(1 + i) % 5] += ((a[(4 + i) % 5] &amp; (a[(3 + i) % 5] ^ a[(2 + i) % 5])) ^ a[(2 + i) % 5]) + b[i] + 0x5a827999 + rol(a[(5 + i) % 5], 5);
                a[(4 + i) % 5] = rol(a[(4 + i) % 5], 30);
                break;
            case 3:
                b[(i + 4) % 16] = blk(b, (i + 4) % 16);
                a[i % 5] += (a[(3 + i) % 5] ^ a[(2 + i) % 5] ^ a[(1 + i) % 5]) + b[(i + 4) % 16] + 0x6ed9eba1 + rol(a[(4 + i) % 5], 5);
                a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30);
                break;
            case 4:
                b[(i + 8) % 16] = blk(b, (i + 8) % 16);
                a[i % 5] += (((a[(3 + i) % 5] | a[(2 + i) % 5]) &amp; a[(1 + i) % 5]) | (a[(3 + i) % 5] &amp; a[(2 + i) % 5])) + b[(i + 8) % 16] + 0x8f1bbcdc + rol(a[(4 + i) % 5], 5);
                a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30);
                break;
            case 5:
                b[(i + 12) % 16] = blk(b, (i + 12) % 16);
                a[i % 5] += (a[(3 + i) % 5] ^ a[(2 + i) % 5] ^ a[(1 + i) % 5]) + b[(i + 12) % 16] + 0xca62c1d6 + rol(a[(4 + i) % 5], 5);
                a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30);
                break;
            case 6:
                b[i] += a[4 - i];
            }
        }
    };

    /**
     * sha1 函数的实现
     */
    static inline void sha1(uint32_t hash[5], uint32_t b[16]) {
        uint32_t a[5] = {hash[4], hash[3], hash[2], hash[1], hash[0]};
        static_for&lt;16, Sha1Loop&lt;1&gt;&gt;()(a, b);
        static_for&lt;4, Sha1Loop&lt;2&gt;&gt;()(a, b);
        static_for&lt;20, Sha1Loop&lt;3&gt;&gt;()(a, b);
        static_for&lt;20, Sha1Loop&lt;4&gt;&gt;()(a, b);
        static_for&lt;20, Sha1Loop&lt;5&gt;&gt;()(a, b);
        static_for&lt;5, Sha1Loop&lt;6&gt;&gt;()(a, hash);
    }

    /**
     * base64 编码函数
     */
    static inline void base64(unsigned char *src, char *dst) {
        const char *b64 = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#34;;
        for (int i = 0; i &lt; 18; i += 3) {
            *dst++ = b64[(src[i] &gt;&gt; 2) &amp; 63];
            *dst++ = b64[((src[i] &amp; 3) &lt;&lt; 4) | ((src[i + 1] &amp; 240) &gt;&gt; 4)];
            *dst++ = b64[((src[i + 1] &amp; 15) &lt;&lt; 2) | ((src[i + 2] &amp; 192) &gt;&gt; 6)];
            *dst++ = b64[src[i + 2] &amp; 63];
        }
        *dst++ = b64[(src[18] &gt;&gt; 2) &amp; 63];
        *dst++ = b64[((src[18] &amp; 3) &lt;&lt; 4) | ((src[19] &amp; 240) &gt;&gt; 4)];
        *dst++ = b64[((src[19] &amp; 15) &lt;&lt; 2)];
        *dst++ = &#39;=&#39;;
    }

public:
    /** 
     * 生成 Sec-WebSocket-Accept 算法
     * @param input 对端传过来的Sec-WebSocket-Key值
     * @param output 存放生成的 Sec-WebSocket-Accept 值
     */
    static inline void generate(const char input[24], char output[28]) {
        uint32_t b_output[5] = {
            0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0
        };
        uint32_t b_input[16] = {
            0, 0, 0, 0, 0, 0, 0x32353845, 0x41464135, 0x2d453931, 0x342d3437, 0x44412d39,
            0x3543412d, 0x43354142, 0x30444338, 0x35423131, 0x80000000
        };

        for (int i = 0; i &lt; 6; i++) {
            b_input[i] = (input[4 * i + 3] &amp; 0xff) | (input[4 * i + 2] &amp; 0xff) &lt;&lt; 8 | (input[4 * i + 1] &amp; 0xff) &lt;&lt; 16 | (input[4 * i + 0] &amp; 0xff) &lt;&lt; 24;
        }
        sha1(b_output, b_input);
        uint32_t last_b[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480};
        sha1(b_output, last_b);
        for (int i = 0; i &lt; 5; i++) {
            uint32_t tmp = b_output[i];
            char *bytes = (char *) &amp;b_output[i];
            bytes[3] = tmp &amp; 0xff;
            bytes[2] = (tmp &gt;&gt; 8) &amp; 0xff;
            bytes[1] = (tmp &gt;&gt; 16) &amp; 0xff;
            bytes[0] = (tmp &gt;&gt; 24) &amp; 0xff;
        }
        base64((unsigned char *) b_output, output);
    }
};
</code></pre><p>握手完成之后，通信双方就可以保持连接并相互发送数据了。</p>
<h4 id="websocket-协议格式">WebSocket 协议格式</h4>
<p>WebSocket 协议格式的 RFC 文档可以参见：[]https://tools.ietf.org/html/rfc6455。</p>
<p>常听人说 WebSocket 协议是基于 http 协议的，因此我在刚接触 WebSocket 协议时总以为每个 WebSocket 数据包都是 http 格式，其实不然，WebSocket 协议除了上文中提到的这次握手过程中使用的数据格式是 http 协议格式，之后的通信双方使用的是另外一种自定义格式。每一个 WebSocket 数据包我们称之为一个 Frame（帧），其格式图如下：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/3569b76b730d514be3d215ddf6287db0.webp" alt=""  />
</p>
<p>我们来逐一介绍一下上文中各字段的含义：</p>
<p><strong>第一个字节</strong>内容：</p>
<ul>
<li>
<p><strong>FIN</strong> 标志，占第一个字节中的第一位（bit），即一字节中的最高位（一字节等于 8 位），该标志置 0 时表示当前包未结束后续有该包的分片，置 1 时表示当前包已结束后续无该包的分片。我们在解包时，如果发现该标志为 1，则需要将当前包的“包体”数据（即图中 <strong>Payload Data</strong>）缓存起来，与后续包分片组装在一起，才是一个完整的包体数据。</p>
</li>
<li>
<p><strong>RSV1</strong>、<strong>RSV2</strong>、<strong>RSV3</strong> 每个占一位，一共三位，这三个位是保留字段（默认都是 0），你可以用它们作为通信的双方协商好的一些特殊标志；</p>
</li>
<li>
<p><strong>opCode</strong> 操作类型，占四位，目前操作类型及其取值如下：</p>
<pre tabindex="0"><code>// 4 bits
enum OpCode
{
    //表示后续还有新的 Frame
    CONTINUATION_FRAME  = 0x0,
    //包体是文本类型的Frame
    TEXT_FRAME          = 0x1,
    //包体是二进制类型的 Frame
    BINARY_FRAME        = 0x2,
    //保留值
    RESERVED1           = 0x3,
    RESERVED2           = 0x4,
    RESERVED3           = 0x5,
    RESERVED4           = 0x6,
    RESERVED5           = 0x7,
    //建议对端关闭的 Frame
    CLOSE               = 0x8,
    //心跳包中的 ping Frame
    PING                = 0x9,
    //心跳包中的 pong Frame
    PONG                = 0xA,
    //保留值
    RESERVED6           = 0xB,
    RESERVED7           = 0xC,
    RESERVED8           = 0xD,
    RESERVED9           = 0xE,
    RESERVED10          = 0xF
};
</code></pre></li>
</ul>
<p><strong>第二个字节</strong>内容：</p>
<ul>
<li>
<p><strong>mask</strong> 标志，占一位，该标志为 1 时，表明该 Frame 在包体长度字段后面携带 4 个字节的 <strong>masking-key</strong> 信息，为 0 时则没有 <strong>masking-key</strong> 信息。<strong>masking-key</strong> 信息下文会介绍。</p>
</li>
<li>
<p><strong>Payload len</strong>，占七位，该字段表示包体的长度信息。由于 <strong>Payload length</strong> 值使用了一个字节的低七位（<strong>7 bit</strong>），因此其能表示的长度范围是 0 ~ 127，其中 <strong>126</strong> 和 <strong>127</strong> 被当做特殊标志使用。</p>
<p>当该字段值是 <strong>0~125</strong> 时，表示跟在 masking-key 字段后面的就是包体内容长度；当该值是 <strong>126</strong> 时，接下来的 <strong>2</strong> 个字节内容表示跟在 masking-key 字段后面的包体内容的长度（即图中的 <strong>Extended Payload Length</strong>）。由于 2 个字节最大表示的无符号整数是 <strong>0xFFFF</strong>（十进制是 65535， 编译器提供了一个宏 <strong>UINT16_MAX</strong> 来表示这个值）。如果包体长度超过 65535，包长度就记录不下了，此时应该将 <strong>Payload length</strong> 设置为 127，以使用更多的字节数来表示包体长度。</p>
<p>当 <strong>Payload length</strong> 是 <strong>127</strong> 时，接下来则用 <strong>8</strong> 个字节内容表示跟在 masking-key 字段后面的包体内容的长度（<strong>Extended Payload Length</strong>）。</p>
</li>
</ul>
<blockquote>
<p>总结起来，Payload length = 0 ~ 125，<strong>Extended Payload Length</strong> 不存在， 0 字节；Payload length = 126, Extended Payload Length 占 2 字节；Payload length = 127 时，Extended Payload Length 占 8 字节。</p>
<p>另外需要注意的是，当 Payload length = 125 或 126 时接下来存储实际包长的 2 字节或 8 字节，其值必须转换为网络字节序（Big Endian）。</p>
</blockquote>
<ul>
<li><strong>Masking-key</strong> ，如果前面的 mask 标志设置成 1，则该字段存在，占 4 个字节；反之，则 Frame 中不存在存储 <strong>masking-key</strong> 字段的字节。</li>
</ul>
<blockquote>
<p>网络上一些资料说，<strong>客户端（主动发起握手请求的一方）给服务器（被动接受握手的另一方）发的 frame 信息（包信息），mask 标志必须是 1</strong>，而服务器给客户端发送的 frame 信息中 mask 标志是 0。因此，客户端发给服务器端的数据帧中存在 4 字节的 masking-key，而服务器端发给客户端的数据帧中不存在 masking-key 信息。</p>
<p>我在 Websocket 协议的 RFC 文档中并没有看到有这种强行规定，另外在研究了一些 websocket 库的实现后发现，此结论并不一定成立，客户端发送的数据也可能没有设置 mask 标志。</p>
</blockquote>
<p>如果存在 <strong>masking-key</strong> 信息，则数据帧中的数据（图中 Payload Data）都是经过与 masking-key 进行运算后的内容。无论是将原始数据与 masking-key 运算后得到传输的数据，还是将传输的数据还原成原始数据，其算法都是一样的。算法如下：</p>
<pre tabindex="0"><code>假设：
original-octet-i：为原始数据的第 i 字节。
transformed-octet-i：为转换后的数据的第 i 字节。
j：为i mod 4的结果。
masking-key-octet-j：为 mask key 第 j 字节。
</code></pre><p>算法描述为：original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>
<pre tabindex="0"><code>j  = i MOD 4
transformed-octet-i = original-octet-i XOR masking-key-octet-j
</code></pre><p>我用 C++ 实现了该算法：</p>
<pre tabindex="0"><code>/**
 * @param src 函数调用前是原始需要传输的数据，函数调用后是mask或者unmask后的内容
 * @param maskingKey 四字节
 */
void maskAndUnmaskData(std::string&amp; src, const char* maskingKey)
{
    char j;
    for (size_t n = 0; n &lt; src.length(); ++n)
    {
        j = n % 4;
        src[n] = src[n] ^ maskingKey[j];
    }
}
</code></pre><p>使用上面的描述可能还不是太清楚，我们举个例子，假设有一个客户端发送给服务器的数据包，那么 mask = 1，即存在 4 字节的 masking-key，当包体数据长度在 0 ~ 125 之间时，该包的结构：</p>
<pre tabindex="0"><code>第 1 个字节第 0 位    =&gt; FIN
第 1 个字节第 1 ~ 3位 =&gt; RSV1 + RSV2 + RSV3
第 1 个字节第 4 ~ 7位 =&gt; opcode
第 2 个字节第 0 位    =&gt; mask(等于 1)
第 2 个字节第 1 ~ 7位 =&gt; 包体长度
第 3 ~ 6 个字节      =&gt;  masking-key
第 7 个字节及以后     =&gt;  包体内容
</code></pre><p>这种情形，包头总共 6 个字节。</p>
<p>当包体数据长度大于125 且小于等于 UINT16_MAX 时，该包的结构：</p>
<pre tabindex="0"><code>第 1 个字节第 0 位    =&gt; FIN
第 1 个字节第 1 ~ 3位 =&gt; RSV1 + RSV2 + RSV3
第 1 个字节第 4 ~ 7位 =&gt; opcode
第 2 个字节第 0 位    =&gt; mask(等于 1)
第 2 个字节第 1 ~ 7位 =&gt; 开启扩展包头长度标志，值为 126
第 3 ~ 4 个字节      =&gt;  包头长度
第 5 ~ 8 个字节      =&gt;  masking-key
第 9 个字节及以后     =&gt;  包体内容
</code></pre><p>这种情形，包头总共 8 个字节。</p>
<p>当包体数据长度大于 UINT16_MAX 时，该包的结构：</p>
<pre tabindex="0"><code>第 1 个字节第 0 位    =&gt; FIN
第 1 个字节第 1 ~ 3位 =&gt; RSV1 + RSV2 + RSV3
第 1 个字节第 4 ~ 7位 =&gt; opcode
第 2 个字节第 0 位    =&gt; mask(等于 1)
第 2 个字节第 1 ~ 7位 =&gt; 开启扩展包头长度标志，值为 127
第 3 ~ 10 个字节      =&gt;  包头长度
第 11 ~ 14 个字节     =&gt;  masking-key
第 15 个字节及以后     =&gt;  包体内容
</code></pre><p>这种情形，包头总共 14 个字节。由于存储包体长度使用 8 字节存储（无符号），因此最大包体长度是 0xFFFFFFFFFFFFFFFF，这是一个非常大的数字，但实际开发中，我们用不到这么长的包体，且当包体超过一定值时，我们就应该分包（分片）了。</p>
<p>分包的逻辑经过前面的分析也很简单，假设将一个包分成 3 片，那么应将第一个和第二个包片的第一个字节的第一位 FIN 设置为 0，OpCode 设置为 CONTINUATION_FRAME（也是 0）；第三个包片 FIN 设置为 1，表示该包至此就结束了，OpCode 设置为想要的类型（如 TEXT_FRAME、BINARY_FRAME 等）。对端收到该包时，如果发现标志 FIN = 0 或 OpCode = 0，将该包包体的数据暂存起来，直到收到 FIN = 1，OpCode ≠ 0 的包，将该包的数据与前面收到的数据放在一起，组装成一个完整的业务数据。示例代码如下：</p>
<pre tabindex="0"><code>//某次解包后得到包体 payloadData，根据 FIN 标志判断，
//如果 FIN = true，则说明一个完整的业务数据包已经收完整，
//调用 processPackage() 函数处理该业务数据
//否则，暂存于 m_strParsedData 中
//每次处理完一个完整的业务包数据，即将暂存区m_strParsedData中的数据清空
if (FIN)
{
    m_strParsedData.append(payloadData);
    processPackage(m_strParsedData);
    m_strParsedData.clear();
}
else
{
    m_strParsedData.append(payloadData);
}
</code></pre><h4 id="websocket-压缩格式">WebSocket 压缩格式</h4>
<p>WebSocket 对于包体也支持压缩的，是否需要开启压缩需要通信双方在握手时进行协商。让我们再看一下握手时主动发起一方的包内容：</p>
<pre tabindex="0"><code>GET /realtime HTTP/1.1\r\n
Host: 127.0.0.1:9989\r\n
Connection: Upgrade\r\n
Pragma: no-cache\r\n
Cache-Control: no-cache\r\n
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\r\n
Upgrade: websocket\r\n
Origin: http://xyz.com\r\n
Sec-WebSocket-Version: 13\r\n
Accept-Encoding: gzip, deflate, br\r\n
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n
Sec-WebSocket-Key: IqcAWodjyPDJuhGgZwkpKg==\r\n
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n
\r\n
</code></pre><p>在该包中 <strong>Sec-WebSocket-Extensions</strong> 字段中有一个值 <strong>permessage-deflate</strong>，如果发起方支持压缩，在发起握手时将包中带有该标志，对端收到后，如果也支持压缩，则在应答的包也带有该字段，反之不带该标志即表示不支持压缩。例如：</p>
<pre tabindex="0"><code>HTTP/1.1 101 Switching Protocols\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
Sec-WebSocket-Accept: 5wC5L6joP6tl31zpj9OlCNv9Jy4=\r\n
Sec-WebSocket-Extensions: permessage-deflate; client_no_context_takeover
\r\n
</code></pre><p>如果双方都支持压缩，此后通信的包中的包体部分都是经过压缩后的，反之是未压缩过的。在解完包得到包体（即 Payload Data） 后，如果有握手时有压缩标志并且乙方也回复了支持压缩，则需要对该包体进行解压；同理，在发数据组装 WebSocket 包时，需要先将包体（即 Payload Data）进行压缩。</p>
<p>收到包需要解压示例代码：</p>
<pre tabindex="0"><code>bool MyWebSocketSession::processPackage(const std::string&amp; data)
{
    std::string out;
    //m_bClientCompressed在握手确定是否支持压缩
    if (m_bClientCompressed)
    {
        //解压
        if (!ZlibUtil::inflate(data, out))
        {
            LOGE(&#34;uncompress failed, dataLength: %d&#34;, data.length());
            return false;
        }

    }
    else
        out = data;

    //如果不需要解压，则out=data，反之则out是解压后的数据
    LOGI(&#34;receid data: %s&#34;, out.c_str());


    return Process(out);
}
</code></pre><p>对包进行压缩的算法：</p>
<pre tabindex="0"><code>size_t dataLength = data.length();
std::string destbuf;
if (m_bClientCompressed)
{
    //按需压缩
    if (!ZlibUtil::deflate(data, destbuf))
    {
        LOGE(&#34;compress buf error, data: %s&#34;, data.c_str());
        return;
    }
}
else
    destbuf = data;

LOGI(&#34;destbuf.length(): %d&#34;, destbuf.length());    
</code></pre><p>压缩和解压算法即 gzip 压缩算法。</p>
<blockquote>
<p>由于公众号文章最大是 5000 字数限制，本文原文一共有 12000 字，公众号发文时有省略。如果想获取完整的文章请在【高性能服务器开发】公众号后台回复 关键字【websocket协议分析】。获取文中完整源码，请在公众号后台回复关键字【websocket源码】。</p>
</blockquote>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/blog/42f423476e5d4262bcb032f3cf4c40d3/">
    <span class="title">« Prev</span>
    <br>
    <span>从零实现一款12306刷票软件</span>
  </a>
  <a class="next" href="https://haokiu.com/blog/745f468dc9234e4f95ac9d848e64fa0b/">
    <span class="title">Next »</span>
    <br>
    <span>作者的故事</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
