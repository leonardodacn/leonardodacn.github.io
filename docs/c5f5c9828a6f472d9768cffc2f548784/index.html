<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>08 服务器端file_server源码分析 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="08 服务器端file_server源码分析 这篇文章我们来介绍file_server服务的功能和源码实现。TeamTalk支持离线在线文件和离线文件两种传送文件的方式。单纯地研究file_server的程序结构没多大意义，因为其程序结构和其他几个服务结构基本上一模一样，前面几篇文章已经介绍过了。 我们研究teamtalk的file_server是为了学习和借鉴teamtalk的文件传输功能实现思路，以内化为自己的知识，并加以应用。
所以这篇文章，我们将pc客户端的文件传输功能、msg_server转发消息、file_server处理文件数据三个方面结合起来一起介绍。
下面开始啦。
一、连接状况介绍
fileserver开始并不是和客户端连接的，客户端是按需连接file_server的。但是file_server与msg_server却是长连接。先启动file_server，再启动msg_server。msg_server初始化的时候，会去尝试连接file_server的8601端口。连接成功以后，会给file_server发送一个发包询问file_server侦听客户端连接的ip和端口号信息：
void CFileServConn::OnConfirm() { log(&#34;connect to file server success &#34;); m_bOpen = true; m_connect_time = get_tick_count(); g_file_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2; //连上file_server以后，给file_server发送获取ip地址的数据包 IM::Server::IMFileServerIPReq msg; CImPdu pdu; pdu.SetPBMsg(&amp;msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ); SendPdu(&amp;pdu); } file_server收到该数据包后，将自己的侦听客户端连接的ip地址和端口号发包告诉msg_server：
void FileMsgServerConn::_HandleGetServerAddressReq(CImPdu* pPdu) { IM::Server::IMFileServerIPRsp msg; const std::list&lt;IM::BaseDefine::IpAddr&gt;&amp; addrs = ConfigUtil::GetInstance()-&gt;GetAddressList(); for (std::list&lt;IM::BaseDefine::IpAddr&gt;::const_iterator it=addrs.begin(); it!=addrs.end(); &#43;&#43;it) { IM::BaseDefine::IpAddr* addr = msg.add_ip_addr_list(); *addr = *it; log(&#34;Upload file_client_conn addr info, ip=%s, port=%d&#34;, addr-&gt;ip().c_str(), addr-&gt;port()); } SendMessageLite(this, SID_OTHER, CID_OTHER_FILE_SERVER_IP_RSP, pPdu-&gt;GetSeqNum(), &amp;msg); } 得到的信息是file_server侦听的ip地址和端口号，默认配置的端口号是8600。也就是说file_server的8600用于客户端连接，8601端口用于msg_server连接。这样，客户端需要传输文件（注意：不是聊天图片，聊天图片使用另外一个服务msfs进行传输），会先告诉msg_server它需要进行文件传输，msg_server收到消息后告诉客户端，你连file_server来传输文件吧，并把file_server的地址和端口号告诉客户端。客户端这个时候连接file_server进行文件传输。我们来具体看一看这个流程的细节信息：
客户端发包给msg_server说要进行文件发送 然后选择一个文件：
pc客户端发送文件逻辑：
//pc客户端代码(Modules工程SessionLayout.cpp) void SessionLayout::Notify(TNotifyUI&amp; msg) { ... //省略无关代码 else if (msg.pSender == m_pBtnsendfile) //文件传输 { module::UserInfoEntity userInfo; if (!module::getUserListModule()-&gt;getUserInfoBySId(m_sId, userInfo)) { LOG__(ERR, _T(&#34;SendFile can&#39;t find the sid&#34;)); return; } CFileDialog	fileDlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST , _T(&#34;文件|*.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/c5f5c9828a6f472d9768cffc2f548784/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="08 服务器端file_server源码分析" />
<meta property="og:description" content="08 服务器端file_server源码分析 这篇文章我们来介绍file_server服务的功能和源码实现。TeamTalk支持离线在线文件和离线文件两种传送文件的方式。单纯地研究file_server的程序结构没多大意义，因为其程序结构和其他几个服务结构基本上一模一样，前面几篇文章已经介绍过了。 我们研究teamtalk的file_server是为了学习和借鉴teamtalk的文件传输功能实现思路，以内化为自己的知识，并加以应用。
所以这篇文章，我们将pc客户端的文件传输功能、msg_server转发消息、file_server处理文件数据三个方面结合起来一起介绍。
下面开始啦。
一、连接状况介绍
fileserver开始并不是和客户端连接的，客户端是按需连接file_server的。但是file_server与msg_server却是长连接。先启动file_server，再启动msg_server。msg_server初始化的时候，会去尝试连接file_server的8601端口。连接成功以后，会给file_server发送一个发包询问file_server侦听客户端连接的ip和端口号信息：
void CFileServConn::OnConfirm() { log(&#34;connect to file server success &#34;); m_bOpen = true; m_connect_time = get_tick_count(); g_file_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2; //连上file_server以后，给file_server发送获取ip地址的数据包 IM::Server::IMFileServerIPReq msg; CImPdu pdu; pdu.SetPBMsg(&amp;msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ); SendPdu(&amp;pdu); } file_server收到该数据包后，将自己的侦听客户端连接的ip地址和端口号发包告诉msg_server：
void FileMsgServerConn::_HandleGetServerAddressReq(CImPdu* pPdu) { IM::Server::IMFileServerIPRsp msg; const std::list&lt;IM::BaseDefine::IpAddr&gt;&amp; addrs = ConfigUtil::GetInstance()-&gt;GetAddressList(); for (std::list&lt;IM::BaseDefine::IpAddr&gt;::const_iterator it=addrs.begin(); it!=addrs.end(); &#43;&#43;it) { IM::BaseDefine::IpAddr* addr = msg.add_ip_addr_list(); *addr = *it; log(&#34;Upload file_client_conn addr info, ip=%s, port=%d&#34;, addr-&gt;ip().c_str(), addr-&gt;port()); } SendMessageLite(this, SID_OTHER, CID_OTHER_FILE_SERVER_IP_RSP, pPdu-&gt;GetSeqNum(), &amp;msg); } 得到的信息是file_server侦听的ip地址和端口号，默认配置的端口号是8600。也就是说file_server的8600用于客户端连接，8601端口用于msg_server连接。这样，客户端需要传输文件（注意：不是聊天图片，聊天图片使用另外一个服务msfs进行传输），会先告诉msg_server它需要进行文件传输，msg_server收到消息后告诉客户端，你连file_server来传输文件吧，并把file_server的地址和端口号告诉客户端。客户端这个时候连接file_server进行文件传输。我们来具体看一看这个流程的细节信息：
客户端发包给msg_server说要进行文件发送 然后选择一个文件：
pc客户端发送文件逻辑：
//pc客户端代码(Modules工程SessionLayout.cpp) void SessionLayout::Notify(TNotifyUI&amp; msg) { ... //省略无关代码 else if (msg.pSender == m_pBtnsendfile) //文件传输 { module::UserInfoEntity userInfo; if (!module::getUserListModule()-&gt;getUserInfoBySId(m_sId, userInfo)) { LOG__(ERR, _T(&#34;SendFile can&#39;t find the sid&#34;)); return; } CFileDialog	fileDlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST , _T(&#34;文件|*." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/c5f5c9828a6f472d9768cffc2f548784/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="08 服务器端file_server源码分析"/>
<meta name="twitter:description" content="08 服务器端file_server源码分析 这篇文章我们来介绍file_server服务的功能和源码实现。TeamTalk支持离线在线文件和离线文件两种传送文件的方式。单纯地研究file_server的程序结构没多大意义，因为其程序结构和其他几个服务结构基本上一模一样，前面几篇文章已经介绍过了。 我们研究teamtalk的file_server是为了学习和借鉴teamtalk的文件传输功能实现思路，以内化为自己的知识，并加以应用。
所以这篇文章，我们将pc客户端的文件传输功能、msg_server转发消息、file_server处理文件数据三个方面结合起来一起介绍。
下面开始啦。
一、连接状况介绍
fileserver开始并不是和客户端连接的，客户端是按需连接file_server的。但是file_server与msg_server却是长连接。先启动file_server，再启动msg_server。msg_server初始化的时候，会去尝试连接file_server的8601端口。连接成功以后，会给file_server发送一个发包询问file_server侦听客户端连接的ip和端口号信息：
void CFileServConn::OnConfirm() { log(&#34;connect to file server success &#34;); m_bOpen = true; m_connect_time = get_tick_count(); g_file_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2; //连上file_server以后，给file_server发送获取ip地址的数据包 IM::Server::IMFileServerIPReq msg; CImPdu pdu; pdu.SetPBMsg(&amp;msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ); SendPdu(&amp;pdu); } file_server收到该数据包后，将自己的侦听客户端连接的ip地址和端口号发包告诉msg_server：
void FileMsgServerConn::_HandleGetServerAddressReq(CImPdu* pPdu) { IM::Server::IMFileServerIPRsp msg; const std::list&lt;IM::BaseDefine::IpAddr&gt;&amp; addrs = ConfigUtil::GetInstance()-&gt;GetAddressList(); for (std::list&lt;IM::BaseDefine::IpAddr&gt;::const_iterator it=addrs.begin(); it!=addrs.end(); &#43;&#43;it) { IM::BaseDefine::IpAddr* addr = msg.add_ip_addr_list(); *addr = *it; log(&#34;Upload file_client_conn addr info, ip=%s, port=%d&#34;, addr-&gt;ip().c_str(), addr-&gt;port()); } SendMessageLite(this, SID_OTHER, CID_OTHER_FILE_SERVER_IP_RSP, pPdu-&gt;GetSeqNum(), &amp;msg); } 得到的信息是file_server侦听的ip地址和端口号，默认配置的端口号是8600。也就是说file_server的8600用于客户端连接，8601端口用于msg_server连接。这样，客户端需要传输文件（注意：不是聊天图片，聊天图片使用另外一个服务msfs进行传输），会先告诉msg_server它需要进行文件传输，msg_server收到消息后告诉客户端，你连file_server来传输文件吧，并把file_server的地址和端口号告诉客户端。客户端这个时候连接file_server进行文件传输。我们来具体看一看这个流程的细节信息：
客户端发包给msg_server说要进行文件发送 然后选择一个文件：
pc客户端发送文件逻辑：
//pc客户端代码(Modules工程SessionLayout.cpp) void SessionLayout::Notify(TNotifyUI&amp; msg) { ... //省略无关代码 else if (msg.pSender == m_pBtnsendfile) //文件传输 { module::UserInfoEntity userInfo; if (!module::getUserListModule()-&gt;getUserInfoBySId(m_sId, userInfo)) { LOG__(ERR, _T(&#34;SendFile can&#39;t find the sid&#34;)); return; } CFileDialog	fileDlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST , _T(&#34;文件|*."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "08 服务器端file_server源码分析",
      "item": "https://haokiu.com/c5f5c9828a6f472d9768cffc2f548784/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "08 服务器端file_server源码分析",
  "name": "08 服务器端file_server源码分析",
  "description": "08 服务器端file_server源码分析 这篇文章我们来介绍file_server服务的功能和源码实现。TeamTalk支持离线在线文件和离线文件两种传送文件的方式。单纯地研究file_server的程序结构没多大意义，因为其程序结构和其他几个服务结构基本上一模一样，前面几篇文章已经介绍过了。 我们研究teamtalk的file_server是为了学习和借鉴teamtalk的文件传输功能实现思路，以内化为自己的知识，并加以应用。\n所以这篇文章，我们将pc客户端的文件传输功能、msg_server转发消息、file_server处理文件数据三个方面结合起来一起介绍。\n下面开始啦。\n一、连接状况介绍\nfileserver开始并不是和客户端连接的，客户端是按需连接file_server的。但是file_server与msg_server却是长连接。先启动file_server，再启动msg_server。msg_server初始化的时候，会去尝试连接file_server的8601端口。连接成功以后，会给file_server发送一个发包询问file_server侦听客户端连接的ip和端口号信息：\nvoid CFileServConn::OnConfirm() { log(\u0026#34;connect to file server success \u0026#34;); m_bOpen = true; m_connect_time = get_tick_count(); g_file_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2; //连上file_server以后，给file_server发送获取ip地址的数据包 IM::Server::IMFileServerIPReq msg; CImPdu pdu; pdu.SetPBMsg(\u0026amp;msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ); SendPdu(\u0026amp;pdu); } file_server收到该数据包后，将自己的侦听客户端连接的ip地址和端口号发包告诉msg_server：\nvoid FileMsgServerConn::_HandleGetServerAddressReq(CImPdu* pPdu) { IM::Server::IMFileServerIPRsp msg; const std::list\u0026lt;IM::BaseDefine::IpAddr\u0026gt;\u0026amp; addrs = ConfigUtil::GetInstance()-\u0026gt;GetAddressList(); for (std::list\u0026lt;IM::BaseDefine::IpAddr\u0026gt;::const_iterator it=addrs.begin(); it!=addrs.end(); ++it) { IM::BaseDefine::IpAddr* addr = msg.add_ip_addr_list(); *addr = *it; log(\u0026#34;Upload file_client_conn addr info, ip=%s, port=%d\u0026#34;, addr-\u0026gt;ip().c_str(), addr-\u0026gt;port()); } SendMessageLite(this, SID_OTHER, CID_OTHER_FILE_SERVER_IP_RSP, pPdu-\u0026gt;GetSeqNum(), \u0026amp;msg); } 得到的信息是file_server侦听的ip地址和端口号，默认配置的端口号是8600。也就是说file_server的8600用于客户端连接，8601端口用于msg_server连接。这样，客户端需要传输文件（注意：不是聊天图片，聊天图片使用另外一个服务msfs进行传输），会先告诉msg_server它需要进行文件传输，msg_server收到消息后告诉客户端，你连file_server来传输文件吧，并把file_server的地址和端口号告诉客户端。客户端这个时候连接file_server进行文件传输。我们来具体看一看这个流程的细节信息：\n客户端发包给msg_server说要进行文件发送 然后选择一个文件：\npc客户端发送文件逻辑：\n//pc客户端代码(Modules工程SessionLayout.cpp) void SessionLayout::Notify(TNotifyUI\u0026amp; msg) { ... //省略无关代码 else if (msg.pSender == m_pBtnsendfile) //文件传输 { module::UserInfoEntity userInfo; if (!module::getUserListModule()-\u0026gt;getUserInfoBySId(m_sId, userInfo)) { LOG__(ERR, _T(\u0026#34;SendFile can\u0026#39;t find the sid\u0026#34;)); return; } CFileDialog\tfileDlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST , _T(\u0026#34;文件|*.",
  "keywords": [
    
  ],
  "articleBody": "08 服务器端file_server源码分析 这篇文章我们来介绍file_server服务的功能和源码实现。TeamTalk支持离线在线文件和离线文件两种传送文件的方式。单纯地研究file_server的程序结构没多大意义，因为其程序结构和其他几个服务结构基本上一模一样，前面几篇文章已经介绍过了。 我们研究teamtalk的file_server是为了学习和借鉴teamtalk的文件传输功能实现思路，以内化为自己的知识，并加以应用。\n所以这篇文章，我们将pc客户端的文件传输功能、msg_server转发消息、file_server处理文件数据三个方面结合起来一起介绍。\n下面开始啦。\n一、连接状况介绍\nfileserver开始并不是和客户端连接的，客户端是按需连接file_server的。但是file_server与msg_server却是长连接。先启动file_server，再启动msg_server。msg_server初始化的时候，会去尝试连接file_server的8601端口。连接成功以后，会给file_server发送一个发包询问file_server侦听客户端连接的ip和端口号信息：\nvoid CFileServConn::OnConfirm() { log(\"connect to file server success \"); m_bOpen = true; m_connect_time = get_tick_count(); g_file_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2; //连上file_server以后，给file_server发送获取ip地址的数据包 IM::Server::IMFileServerIPReq msg; CImPdu pdu; pdu.SetPBMsg(\u0026msg); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ); SendPdu(\u0026pdu); } file_server收到该数据包后，将自己的侦听客户端连接的ip地址和端口号发包告诉msg_server：\nvoid FileMsgServerConn::_HandleGetServerAddressReq(CImPdu* pPdu) { IM::Server::IMFileServerIPRsp msg; const std::list\u003cIM::BaseDefine::IpAddr\u003e\u0026 addrs = ConfigUtil::GetInstance()-\u003eGetAddressList(); for (std::list\u003cIM::BaseDefine::IpAddr\u003e::const_iterator it=addrs.begin(); it!=addrs.end(); ++it) { IM::BaseDefine::IpAddr* addr = msg.add_ip_addr_list(); *addr = *it; log(\"Upload file_client_conn addr info, ip=%s, port=%d\", addr-\u003eip().c_str(), addr-\u003eport()); } SendMessageLite(this, SID_OTHER, CID_OTHER_FILE_SERVER_IP_RSP, pPdu-\u003eGetSeqNum(), \u0026msg); } 得到的信息是file_server侦听的ip地址和端口号，默认配置的端口号是8600。也就是说file_server的8600用于客户端连接，8601端口用于msg_server连接。这样，客户端需要传输文件（注意：不是聊天图片，聊天图片使用另外一个服务msfs进行传输），会先告诉msg_server它需要进行文件传输，msg_server收到消息后告诉客户端，你连file_server来传输文件吧，并把file_server的地址和端口号告诉客户端。客户端这个时候连接file_server进行文件传输。我们来具体看一看这个流程的细节信息：\n客户端发包给msg_server说要进行文件发送 然后选择一个文件：\npc客户端发送文件逻辑：\n//pc客户端代码(Modules工程SessionLayout.cpp) void SessionLayout::Notify(TNotifyUI\u0026 msg) { ... //省略无关代码 else if (msg.pSender == m_pBtnsendfile) //文件传输 { module::UserInfoEntity userInfo; if (!module::getUserListModule()-\u003egetUserInfoBySId(m_sId, userInfo)) { LOG__(ERR, _T(\"SendFile can't find the sid\")); return; } CFileDialog\tfileDlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST , _T(\"文件|*.*||\"), AfxGetMainWnd()); fileDlg.m_ofn.Flags |= OFN_NOCHANGEDIR; fileDlg.DoModal(); CString sPathName; POSITION nPos = fileDlg.GetStartPosition(); if (nPos != NULL) { sPathName = fileDlg.GetNextPathName(nPos); } if (sPathName.IsEmpty()) return; module::getFileTransferModule()-\u003esendFile(sPathName, m_sId, userInfo.isOnlne()); } ... //省略无关代码 } sPathName是文件的全饰路径；m_sId是收取文件的用户id，userInfo.isOnlne()判断m_sId代表的用户是否在线，以此来决定这次文件传输是在线文件还是离线文件模式。\nBOOL FileTransferModule_Impl::sendFile(IN const CString\u0026 sFilePath, IN const std::string\u0026 sSendToSID,IN BOOL bOnlineMode) { if (TransferFileEntityManager::getInstance()-\u003echeckIfIsSending(sFilePath)) { return FALSE; } TransferFileEntity fileEntity; //获取文件大小 struct __stat64 buffer; _wstat64(sFilePath, \u0026buffer); fileEntity.nFileSize = (UInt32)buffer.st_size; if (0 != fileEntity.nFileSize) { CString strFileName = sFilePath; strFileName.Replace(_T(\"\\\\\"), _T(\"/\"));//mac上对于路径字符“\\”需要做特殊处理，windows上则可以识别 fileEntity.sFileName = util::cStringToString(strFileName); fileEntity.sFromID = module::getSysConfigModule()-\u003euserID(); fileEntity.sToID = sSendToSID; uint32_t transMode = 0; transMode = bOnlineMode ? IM::BaseDefine::TransferFileType::FILE_TYPE_ONLINE : IM::BaseDefine::TransferFileType::FILE_TYPE_OFFLINE; LOG__(DEBG,_T(\"FileTransferSevice_Impl::sendFile sTaskID = %s\"), util::stringToCString(fileEntity.sTaskID)); imcore::IMLibCoreStartOperationWithLambda( [=]() { IM::File::IMFileReq imFileReq; LOG__(APP, _T(\"imFileReq,name=%s,size=%d,toId=%s\"),util::stringToCString(fileEntity.sFileName) ,fileEntity.nFileSize,util::stringToCString(fileEntity.sToID)); imFileReq.set_from_user_id(util::stringToInt32(fileEntity.sFromID)); imFileReq.set_to_user_id(util::stringToInt32(fileEntity.sToID)); imFileReq.set_file_name(fileEntity.sFileName); imFileReq.set_file_size(fileEntity.nFileSize); imFileReq.set_trans_mode(static_cast\u003cIM::BaseDefine::TransferFileType\u003e(transMode)); module::getTcpClientModule()-\u003esendPacket(IM::BaseDefine::ServiceID::SID_FILE , IM::BaseDefine::FileCmdID::CID_FILE_REQUEST , \u0026imFileReq); }); return TRUE; } LOG__(ERR, _T(\"fileEntity FileSize error,size = %d\"), fileEntity.nFileSize); return FALSE; } 上面代码中组装的包信息中含有要传输的文件路径、文件大小、发送人id、接收方id、文件传输模式（在线还是离线），包的命令号是IM::BaseDefine::FileCmdID::CID_FILE_REQUEST。这个包发给msg_server以后，msg_server应答：\nvoid CMsgConn::HandlePdu(CImPdu* pPdu) { ... //省略无关代码 case CID_FILE_REQUEST: s_file_handler-\u003eHandleClientFileRequest(this, pPdu); break; ... //省略无关代码 } void CFileHandler::HandleClientFileRequest(CMsgConn* pMsgConn, CImPdu* pPdu) { IM::File::IMFileReq msg; CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength())); uint32_t from_id = pMsgConn-\u003eGetUserId(); uint32_t to_id = msg.to_user_id(); string file_name = msg.file_name(); uint32_t file_size = msg.file_size(); uint32_t trans_mode = msg.trans_mode(); log(\"HandleClientFileRequest, %u-\u003e%u, fileName: %s, trans_mode: %u.\", from_id, to_id, file_name.c_str(), trans_mode); CDbAttachData attach(ATTACH_TYPE_HANDLE, pMsgConn-\u003eGetHandle()); CFileServConn* pFileConn = get_random_file_serv_conn(); if (pFileConn) { IM::Server::IMFileTransferReq msg2; msg2.set_from_user_id(from_id); msg2.set_to_user_id(to_id); msg2.set_file_name(file_name); msg2.set_file_size(file_size); msg2.set_trans_mode((IM::BaseDefine::TransferFileType)trans_mode); msg2.set_attach_data(attach.GetBuffer(), attach.GetLength()); CImPdu pdu; pdu.SetPBMsg(\u0026msg2); pdu.SetServiceId(SID_OTHER); pdu.SetCommandId(CID_OTHER_FILE_TRANSFER_REQ); pdu.SetSeqNum(pPdu-\u003eGetSeqNum()); if (IM::BaseDefine::FILE_TYPE_OFFLINE == trans_mode) { pFileConn-\u003eSendPdu(\u0026pdu); } else //IM::BaseDefine::FILE_TYPE_ONLINE { CImUser* pUser = CImUserManager::GetInstance()-\u003eGetImUserById(to_id); if (pUser \u0026\u0026 pUser-\u003eGetPCLoginStatus())//已有对应的账号pc登录状态 { pFileConn-\u003eSendPdu(\u0026pdu); } else//无对应用户的pc登录状态,向route_server查询状态 { //no pc_client in this msg_server, check it from route_server CPduAttachData attach_data(ATTACH_TYPE_HANDLE_AND_PDU_FOR_FILE, pMsgConn-\u003eGetHandle(), pdu.GetBodyLength(), pdu.GetBodyData()); IM::Buddy::IMUsersStatReq msg3; msg3.set_user_id(from_id); msg3.add_user_id_list(to_id); msg3.set_attach_data(attach_data.GetBuffer(), attach_data.GetLength()); CImPdu pdu2; pdu2.SetPBMsg(\u0026msg3); pdu2.SetServiceId(SID_BUDDY_LIST); pdu2.SetCommandId(CID_BUDDY_LIST_USERS_STATUS_REQUEST); pdu2.SetSeqNum(pPdu-\u003eGetSeqNum()); CRouteServConn* route_conn = get_route_serv_conn(); if (route_conn) { route_conn-\u003eSendPdu(\u0026pdu2); } } } } else { log(\"HandleClientFileRequest, no file server. \"); IM::File::IMFileRsp msg2; msg2.set_result_code(1); msg2.set_from_user_id(from_id); msg2.set_to_user_id(to_id); msg2.set_file_name(file_name); msg2.set_task_id(\"\"); msg2.set_trans_mode((IM::BaseDefine::TransferFileType)trans_mode); CImPdu pdu; pdu.SetPBMsg(\u0026msg2); pdu.SetServiceId(SID_FILE); pdu.SetCommandId(CID_FILE_RESPONSE); pdu.SetSeqNum(pPdu-\u003eGetSeqNum()); pMsgConn-\u003eSendPdu(\u0026pdu); } } 这段代码，很有讲究，msg_server会检测file_server是否已经启动，如果没有启动，则直接发包告诉客户端，file_server不存在。另外，如果该文件传输模式是在线文件，会判断接收文件的用户是否和发送用户在同一台msg_server上。不在的话，则给route_server发送消息，查找该用户所在的msg_server（这个不具体介绍了，后面分析route_server会专门介绍的）。否则，会将文件发送请求转发给file_server，包的命令号是CID_OTHER_FILE_TRANSFER_REQ。file_server收到该请求后，处理如下：\nvoid FileMsgServerConn::HandlePdu(CImPdu* pdu) { ... //省略无关代码 case CID_OTHER_FILE_TRANSFER_REQ: _HandleMsgFileTransferReq(pdu); break ; ... //省略无关代码 } void FileMsgServerConn::_HandleMsgFileTransferReq(CImPdu* pdu) { IM::Server::IMFileTransferReq transfer_req; CHECK_PB_PARSE_MSG(transfer_req.ParseFromArray(pdu-\u003eGetBodyData(), pdu-\u003eGetBodyLength())); uint32_t from_id = transfer_req.from_user_id(); uint32_t to_id = transfer_req.to_user_id(); IM::Server::IMFileTransferRsp transfer_rsp; transfer_rsp.set_result_code(1); transfer_rsp.set_from_user_id(from_id); transfer_rsp.set_to_user_id(to_id); transfer_rsp.set_file_name(transfer_req.file_name()); transfer_rsp.set_file_size(transfer_req.file_size()); transfer_rsp.set_task_id(\"\"); transfer_rsp.set_trans_mode(transfer_req.trans_mode()); transfer_rsp.set_attach_data(transfer_req.attach_data()); bool rv = false; do { std::string task_id = GenerateUUID(); if (task_id.empty()) { log(\"Create task id failed\"); break; } log(\"trams_mode=%d, task_id=%s, from_id=%d, to_id=%d, file_name=%s, file_size=%d\", transfer_req.trans_mode(), task_id.c_str(), from_id, to_id, transfer_req.file_name().c_str(), transfer_req.file_size()); BaseTransferTask* transfer_task = TransferTaskManager::GetInstance()-\u003eNewTransferTask( transfer_req.trans_mode(), task_id, from_id, to_id, transfer_req.file_name(), transfer_req.file_size()); if (transfer_task == NULL) { // 创建未成功 // close connection with msg svr // need_close = true; log(\"Create task failed\"); break; } transfer_rsp.set_result_code(0); transfer_rsp.set_task_id(task_id); rv = true; // need_seq_no = false; log(\"Create task succeed, task id %s, task type %d, from user %d, to user %d\", task_id.c_str(), transfer_req.trans_mode(), from_id, to_id); } while (0); ::SendMessageLite(this, SID_OTHER, CID_OTHER_FILE_TRANSFER_RSP, pdu-\u003eGetSeqNum(), \u0026transfer_rsp); if (!rv) { // 未创建成功，关闭连接 Close(); } } 上述代码会为本次传输任务创建一个唯一的标识uuid作为taskid，然后根据离线文件还是在线文件创建离线文件传输任务OfflineTransferTask或者在线文件传输任务OnlineTransferTask，并加入一个一个成员变量transfer_tasks_中进行管理：\nBaseTransferTask* TransferTaskManager::NewTransferTask(uint32_t trans_mode, const std::string\u0026 task_id, uint32_t from_user_id, uint32_t to_user_id, const std::string\u0026 file_name, uint32_t file_size) { BaseTransferTask* transfer_task = NULL; TransferTaskMap::iterator it = transfer_tasks_.find(task_id); if (it==transfer_tasks_.end()) { if (trans_mode == IM::BaseDefine::FILE_TYPE_ONLINE) { transfer_task = new OnlineTransferTask(task_id, from_user_id, to_user_id, file_name, file_size); } else if (trans_mode == IM::BaseDefine::FILE_TYPE_OFFLINE) { transfer_task = new OfflineTransferTask(task_id, from_user_id, to_user_id, file_name, file_size); } else { log(\"Invalid trans_mode = %d\", trans_mode); } if (transfer_task) { transfer_tasks_.insert(std::make_pair(task_id, transfer_task)); } } else { log(\"Task existed by task_id=%s, why?????\", task_id.c_str()); } return transfer_task; } 这个map transfer_tasks_是在定时器里面进行定期处理的，处理的依据是当前任务的状态，比如已经完成的任务就可以从map中移除了：\nvoid TransferTaskManager::OnTimer(uint64_t tick) { for (TransferTaskMap::iterator it = transfer_tasks_.begin(); it != transfer_tasks_.end();) { BaseTransferTask* task = it-\u003esecond; if (task == NULL) { transfer_tasks_.erase(it++); continue; } if (task-\u003estate() != kTransferTaskStateWaitingUpload \u0026\u0026 task-\u003estate() == kTransferTaskStateTransferDone) { long esp = time(NULL) - task-\u003ecreate_time(); if (esp \u003e ConfigUtil::GetInstance()-\u003eGetTaskTimeout()) { if (task-\u003eGetFromConn()) { FileClientConn* conn = reinterpret_cast\u003cFileClientConn*\u003e(task-\u003eGetFromConn()); conn-\u003eClearTransferTask(); } if (task-\u003eGetToConn()) { FileClientConn* conn = reinterpret_cast\u003cFileClientConn*\u003e(task-\u003eGetToConn()); conn-\u003eClearTransferTask(); } delete task; transfer_tasks_.erase(it++); continue; } } ++it; } } 完成这些工作以后，组装的应答包命令号是CID_OTHER_FILE_TRANSFER_RSP，回复给msg_server。msg_server收到该应答包后处理：\nvoid CFileServConn::HandlePdu(CImPdu* pPdu) { switch (pPdu-\u003eGetCommandId()) { ... //省略无关代码 case CID_OTHER_FILE_TRANSFER_RSP: _HandleFileMsgTransRsp(pPdu); break; ... //省略无关代码 } } void CFileServConn::_HandleFileMsgTransRsp(CImPdu* pPdu) { IM::Server::IMFileTransferRsp msg; CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength())); uint32_t result = msg.result_code(); uint32_t from_id = msg.from_user_id(); uint32_t to_id = msg.to_user_id(); string file_name = msg.file_name(); uint32_t file_size = msg.file_size(); string task_id = msg.task_id(); uint32_t trans_mode = msg.trans_mode(); CDbAttachData attach((uchar_t*)msg.attach_data().c_str(), msg.attach_data().length()); log(\"HandleFileMsgTransRsp, result: %u, from_user_id: %u, to_user_id: %u, file_name: %s, \\ task_id: %s, trans_mode: %u. \", result, from_id, to_id, file_name.c_str(), task_id.c_str(), trans_mode); const list\u003cIM::BaseDefine::IpAddr\u003e* ip_addr_list = GetFileServerIPList(); IM::File::IMFileRsp msg2; msg2.set_result_code(result); msg2.set_from_user_id(from_id); msg2.set_to_user_id(to_id); msg2.set_file_name(file_name); msg2.set_task_id(task_id); msg2.set_trans_mode((IM::BaseDefine::TransferFileType)trans_mode); for (list\u003cIM::BaseDefine::IpAddr\u003e::const_iterator it = ip_addr_list-\u003ebegin(); it != ip_addr_list-\u003eend(); it++) { IM::BaseDefine::IpAddr ip_addr_tmp = *it; IM::BaseDefine::IpAddr* ip_addr = msg2.add_ip_addr_list(); ip_addr-\u003eset_ip(ip_addr_tmp.ip()); ip_addr-\u003eset_port(ip_addr_tmp.port()); } CImPdu pdu; pdu.SetPBMsg(\u0026msg2); pdu.SetServiceId(SID_FILE); pdu.SetCommandId(CID_FILE_RESPONSE); pdu.SetSeqNum(pPdu-\u003eGetSeqNum()); uint32_t handle = attach.GetHandle(); CMsgConn* pFromConn = CImUserManager::GetInstance()-\u003eGetMsgConnByHandle(from_id, handle); if (pFromConn) { pFromConn-\u003eSendPdu(\u0026pdu); } if (result == 0) { IM::File::IMFileNotify msg3; msg3.set_from_user_id(from_id); msg3.set_to_user_id(to_id); msg3.set_file_name(file_name); msg3.set_file_size(file_size); msg3.set_task_id(task_id); msg3.set_trans_mode((IM::BaseDefine::TransferFileType)trans_mode); msg3.set_offline_ready(0); for (list\u003cIM::BaseDefine::IpAddr\u003e::const_iterator it = ip_addr_list-\u003ebegin(); it != ip_addr_list-\u003eend(); it++) { IM::BaseDefine::IpAddr ip_addr_tmp = *it; IM::BaseDefine::IpAddr* ip_addr = msg3.add_ip_addr_list(); ip_addr-\u003eset_ip(ip_addr_tmp.ip()); ip_addr-\u003eset_port(ip_addr_tmp.port()); } CImPdu pdu2; pdu2.SetPBMsg(\u0026msg3); pdu2.SetServiceId(SID_FILE); pdu2.SetCommandId(CID_FILE_NOTIFY); //send notify to target user CImUser* pToUser = CImUserManager::GetInstance()-\u003eGetImUserById(to_id); if (pToUser) { pToUser-\u003eBroadcastPduWithOutMobile(\u0026pdu2); } //send to route server CRouteServConn* pRouteConn = get_route_serv_conn(); if (pRouteConn) { pRouteConn-\u003eSendPdu(\u0026pdu2); } } } msg_server收到包后，首先装包数据，并把file_server的ip地址和端口信息带上，发给请求发文件的客户端，命令号是CID_FILE_RESPONSE；接着查询通知接收方有人给其发文件（通知方式也是一样，如果接收方在该msg_server上，直接发给该用户；不在的话，发给路由服务route_server）。当然接收到文件发送的端只有pc端，移动端会被过滤掉的，也就是说移动端不会收到发送文件的请求。\n我们先看发送方pc客户端收到应答的逻辑（命令号是CID_FILE_RESPONSE）：\nvoid FileTransferModule_Impl::onPacket(imcore::TTPBHeader\u0026 header, std::string\u0026 pbBody) { switch (header.getCommandId()) { case IM::BaseDefine::FileCmdID::CID_FILE_RESPONSE://发送“文件请求/离线文件”-返回 _sendfileResponse(pbBody); break;\t} } void FileTransferModule_Impl::_sendfileResponse(IN std::string\u0026 body) { IM::File::IMFileRsp imFileRsp; if (!imFileRsp.ParseFromString(body)) { LOG__(ERR, _T(\"parse failed,body:%s\"), util::stringToCString(body)); return; } UInt32 nResult = imFileRsp.result_code(); if (nResult != 0) { LOG__(ERR, _T(\"_sendfileResponse result != 0\")); module::getFileTransferModule()-\u003easynNotifyObserver(module::KEY_FILESEVER_UPLOAD_FAILED); } TransferFileEntity fileEntity; fileEntity.sTaskID = imFileRsp.task_id(); assert(!fileEntity.sTaskID.empty()); fileEntity.sFromID = util::uint32ToString(imFileRsp.from_user_id()); fileEntity.sToID = util::uint32ToString(imFileRsp.to_user_id()); fileEntity.sFileName = imFileRsp.file_name(); fileEntity.setSaveFilePath(util::stringToCString(fileEntity.sFileName));//发送方文件地址，就是保存地址 fileEntity.time = static_cast\u003cUInt32\u003e(time(0)); uint32_t transMode = imFileRsp.trans_mode(); if (IM::BaseDefine::TransferFileType::FILE_TYPE_ONLINE == transMode) { fileEntity.nClientMode = IM::BaseDefine::ClientFileRole::CLIENT_REALTIME_SENDER; } else if (IM::BaseDefine::TransferFileType::FILE_TYPE_OFFLINE == transMode) { fileEntity.nClientMode = IM::BaseDefine::ClientFileRole::CLIENT_OFFLINE_UPLOAD; } fileEntity.pFileObject = new TransferFile(util::stringToCString(fileEntity.sFileName),FALSE); if (fileEntity.pFileObject) { fileEntity.nFileSize = fileEntity.pFileObject-\u003elength(); } UINT32 nIPCount = imFileRsp.ip_addr_list_size(); if (nIPCount \u003c= 0) { return; } const IM::BaseDefine::IpAddr\u0026 ipAdd = imFileRsp.ip_addr_list(0); fileEntity.sIP = ipAdd.ip(); fileEntity.nPort = ipAdd.port(); if (!TransferFileEntityManager::getInstance()-\u003epushTransferFileEntity(fileEntity)) TransferFileEntityManager::getInstance()-\u003eupdateFileInfoBysTaskID(fileEntity); LOG__(DEBG, _T(\"FileTransferSevice_Impl::准备连接文件服务器 sTaskId = %s\"), util::stringToCString(fileEntity.sTaskID)); TransferFileEntityManager::getInstance()-\u003eopenFileSocketByTaskId(fileEntity.sTaskID); } 客户端在TransferFileEntityManager::getInstance()-\u003eopenFileSocketByTaskId(fileEntity.sTaskID);里面实际去连接file_server并尝试发文件：\nvoid TransferFileEntityManager::openFileSocketByTaskId(std::string\u0026 taskId) { m_fileUIThread-\u003eopenFileSocketByTaskId(taskId); } void FileTransferUIThread::openFileSocketByTaskId(std::string\u0026 taskId) { FileTransferSocket* pFileSocket = _findFileSocketByTaskId(taskId); if (!pFileSocket) { pFileSocket = new FileTransferSocket(taskId); m_lstFileTransSockets.push_back(pFileSocket); assert(m_hWnd); ::PostMessage(m_hWnd, WM_FILE_TRANSFER, 0, (LPARAM)pFileSocket); } } LRESULT _stdcall FileTransferUIThread::_WndProc(HWND hWnd, UINT message, WPARAM wparam, LPARAM lparam) { if (WM_FILE_TRANSFER == message) { FileTransferSocket* pFileSocket = (FileTransferSocket*)lparam; pFileSocket-\u003estartFileTransLink(); } return ::DefWindowProc(hWnd, message, wparam, lparam); } BOOL FileTransferSocket::startFileTransLink() { TransferFileEntity FileInfo; if (TransferFileEntityManager::getInstance()-\u003egetFileInfoByTaskId(m_sTaskId, FileInfo)) { //大佛：使用msg server 传过来的IP和端口 LOG__(APP, _T(\"connect IP=%s,Port=%d\"), util::stringToCString(FileInfo.sIP), FileInfo.nPort); connect(util::stringToCString(FileInfo.sIP), FileInfo.nPort); //connect(util::stringToCString(module::FILETRANSFER_IP), module::FILETRANSFER_PORT); return TRUE; } LOG__(ERR, _T(\"can't find the TaskId\")); return FALSE; } 注意，这里只是去连接file_server服务器，连接成功的情况下，会尝试登录文件服务器，登录file_server的命令号是CID_FILE_LOGIN_REQ：\nvoid FileTransferSocket::onConnectDone() { LOG__(APP, _T(\"FileTransferSocket::onConnected()\")); startHeartbeat(); TransferFileEntity info; if (!TransferFileEntityManager::getInstance()-\u003egetFileInfoByTaskId(m_sTaskId, info)) { LOG__(APP, _T(\"Can't get the file info,task id:%s\"),util::stringToCString(m_sTaskId)); return; } //拉模式文件传输，传输taskid、token、client_mode IM::File::IMFileLoginReq imFileLoginReq; imFileLoginReq.set_user_id(module::getSysConfigModule()-\u003euserId()); imFileLoginReq.set_task_id(info.sTaskID); imFileLoginReq.set_file_role(static_cast\u003cIM::BaseDefine::ClientFileRole\u003e(info.nClientMode)); LOG__(APP, _T(\"IMFileLoginReq,sTaskID:%s,nClientMode:%d\"), util::stringToCString(info.sTaskID), info.nClientMode); //send packet LOG__(APP, _T(\"IMFileLoginReq,taskId:%s\"), util::stringToCString(info.sTaskID)); sendPacket(IM::BaseDefine::ServiceID::SID_FILE, IM::BaseDefine::FileCmdID::CID_FILE_LOGIN_REQ, \u0026imFileLoginReq); //CImPduClientFileLoginReq pduFileLoginReq(module::getSysConfigModule()-\u003euserID().c_str() //\t, \"\", info.sTaskID.c_str(), ); //sendPacket(\u0026pduFileLoginReq); } file_server收到该数据包处理如下：\nvoid FileClientConn::HandlePdu(CImPdu* pdu) { ... //省略无关代码 case CID_FILE_LOGIN_REQ: _HandleClientFileLoginReq(pdu); break; } void FileClientConn::_HandleClientFileLoginReq(CImPdu* pdu) { IM::File::IMFileLoginReq login_req; CHECK_PB_PARSE_MSG(login_req.ParseFromArray(pdu-\u003eGetBodyData(), pdu-\u003eGetBodyLength())); uint32_t user_id = login_req.user_id(); string task_id = login_req.task_id(); IM::BaseDefine::ClientFileRole mode = login_req.file_role(); log(\"Client login, user_id=%d, task_id=%s, file_role=%d\", user_id, task_id.c_str(), mode); BaseTransferTask* transfer_task = NULL; bool rv = false; do { // 查找任务是否存在 transfer_task = TransferTaskManager::GetInstance()-\u003eFindByTaskID(task_id); if (transfer_task == NULL) { if (mode == CLIENT_OFFLINE_DOWNLOAD) { // 文件不存在，检查是否是离线下载，有可能是文件服务器重启 // 尝试从磁盘加载 transfer_task = TransferTaskManager::GetInstance()-\u003eNewTransferTask(task_id, user_id); // 需要再次判断是否加载成功 if (transfer_task == NULL) { log(\"Find task id failed, user_id=%u, taks_id=%s, mode=%d\", user_id, task_id.c_str(), mode); break; } } else { log(\"Can't find task_id, user_id=%u, taks_id=%s, mode=%d\", user_id, task_id.c_str(), mode); break; } } // 状态转换 rv = transfer_task-\u003eChangePullState(user_id, mode); if (!rv) { // log(); break; // } // Ok auth_ = true; transfer_task_ = transfer_task; user_id_ = user_id; // 设置conn transfer_task-\u003eSetConnByUserID(user_id, this); rv = true; } while (0); IM::File::IMFileLoginRsp login_rsp; login_rsp.set_result_code(rv?0:1); login_rsp.set_task_id(task_id); ::SendMessageLite(this, SID_FILE, CID_FILE_LOGIN_RES, pdu-\u003eGetSeqNum(), \u0026login_rsp); if (rv) { if (transfer_task-\u003eGetTransMode() == FILE_TYPE_ONLINE) { if (transfer_task-\u003estate() == kTransferTaskStateWaitingTransfer) { CImConn* conn = transfer_task_-\u003eGetToConn(); if (conn) { _StatesNotify(CLIENT_FILE_PEER_READY, task_id, transfer_task_-\u003efrom_user_id(), conn); } else { log(\"to_conn is close, close me!!!\"); Close(); } // _StatesNotify(CLIENT_FILE_PEER_READY, task_id, user_id, this); // transfer_task-\u003eStatesNotify(CLIENT_FILE_PEER_READY, task_id, user_id_); } } else { if (transfer_task-\u003estate() == kTransferTaskStateWaitingUpload) { OfflineTransferTask* offline = reinterpret_cast\u003cOfflineTransferTask*\u003e(transfer_task); IM::File::IMFilePullDataReq pull_data_req; pull_data_req.set_task_id(task_id); pull_data_req.set_user_id(user_id); pull_data_req.set_trans_mode(FILE_TYPE_OFFLINE); pull_data_req.set_offset(0); pull_data_req.set_data_size(offline-\u003eGetNextSegmentBlockSize()); ::SendMessageLite(this, SID_FILE, CID_FILE_PULL_DATA_REQ, \u0026pull_data_req); log(\"Pull Data Req\"); } } } else { Close(); } } file_server应答客户端的命令号是CID_FILE_LOGIN_RES，客户端收到该包后处理如下：\nvoid FileTransferSocket::onReceiveData(const char* data, int32_t size) { std::string pbBody; imcore::TTPBHeader pbHeader; try { pbHeader.unSerialize((byte*)data, imcore::HEADER_LENGTH); pbBody.assign(data + imcore::HEADER_LENGTH, size - imcore::HEADER_LENGTH); if (IM::BaseDefine::OtherCmdID::CID_OTHER_HEARTBEAT == pbHeader.getCommandId() \u0026\u0026 IM::BaseDefine::ServiceID::SID_OTHER == pbHeader.getModuleId()) return; } catch (CPduException e) { LOG__(ERR, _T(\"onPacket CPduException serviceId:%d,commandId:%d,errCode:%d\") , e.GetModuleId(), e.GetCommandId(), e.GetErrorCode()); return; } catch (...) { LOG__(ERR, _T(\"FileTransferSocket onPacket unknown exception\")); return; } UInt16 ncmdid = pbHeader.getCommandId(); switch (ncmdid) {\tcase IM::BaseDefine::FileCmdID::CID_FILE_LOGIN_RES: _fileLoginResponse(pbBody); break; //无关代码省略 } } void FileTransferSocket::_fileLoginResponse(IN std::string\u0026 body) { IM::File::IMFileLoginRsp imFileLoginRsp; if (!imFileLoginRsp.ParseFromString(body)) { LOG__(ERR, _T(\"parse failed,body:%s\"), util::stringToCString(body)); return; } if (imFileLoginRsp.result_code() != 0) { LOG__(ERR, _T(\"file server login failed! \")); return; } //打开文件 std::string taskId = imFileLoginRsp.task_id(); TransferFileEntity fileEntity; if (!TransferFileEntityManager::getInstance()-\u003egetFileInfoByTaskId(taskId, fileEntity)) { LOG__(ERR, _T(\"file server login:can't find the fileInfo \")); return; } LOG__(APP, _T(\"IMFileLoginRsp, file server login succeed\")); //提示界面,界面上插入该项 if (IM::BaseDefine::ClientFileRole::CLIENT_REALTIME_SENDER == fileEntity.nClientMode || IM::BaseDefine::ClientFileRole::CLIENT_OFFLINE_UPLOAD == fileEntity.nClientMode) { module::getFileTransferModule()-\u003easynNotifyObserver(module::KEY_FILETRANSFER_SENDFILE, fileEntity.sTaskID); } else if (IM::BaseDefine::ClientFileRole::CLIENT_REALTIME_RECVER == fileEntity.nClientMode || IM::BaseDefine::ClientFileRole::CLIENT_OFFLINE_DOWNLOAD == fileEntity.nClientMode) { module::getFileTransferModule()-\u003easynNotifyObserver(module::KEY_FILETRANSFER_REQUEST, fileEntity.sTaskID); } } 至此，不管是离线文件还是在线文件发送，pc客户端会显示一个文件进度的对话框：\n对于在线文件，需要对端同意接收文件的传输，客户端才会读取文件，这个进度条才会发生变化。而对于离线文件，应该会立马读取文件上传文件数据到服务器。可是哪里会触发客户端读取文件并发送的逻辑呢？门道在于file_server在收到登录请求CID_FILE_LOGIN_REQ后，不仅会给客户端发送登录应答数据包CID_FILE_LOGIN_RES。还会根据文件的传输模式，如果是离线文件则会给客户端发送拉取文件的数据包CID_FILE_PULL_DATA_REQ，代码我们已经在上面的FileClientConn::_HandleClientFileLoginReq(CImPdu* pdu)中贴过了，我们再贴一次：\nvoid FileClientConn::_HandleClientFileLoginReq(CImPdu* pdu) { IM::File::IMFileLoginReq login_req; CHECK_PB_PARSE_MSG(login_req.ParseFromArray(pdu-\u003eGetBodyData(), pdu-\u003eGetBodyLength())); uint32_t user_id = login_req.user_id(); string task_id = login_req.task_id(); IM::BaseDefine::ClientFileRole mode = login_req.file_role(); log(\"Client login, user_id=%d, task_id=%s, file_role=%d\", user_id, task_id.c_str(), mode); BaseTransferTask* transfer_task = NULL; bool rv = false; do { // 查找任务是否存在 transfer_task = TransferTaskManager::GetInstance()-\u003eFindByTaskID(task_id); if (transfer_task == NULL) { if (mode == CLIENT_OFFLINE_DOWNLOAD) { // 文件不存在，检查是否是离线下载，有可能是文件服务器重启 // 尝试从磁盘加载 transfer_task = TransferTaskManager::GetInstance()-\u003eNewTransferTask(task_id, user_id); // 需要再次判断是否加载成功 if (transfer_task == NULL) { log(\"Find task id failed, user_id=%u, taks_id=%s, mode=%d\", user_id, task_id.c_str(), mode); break; } } else { log(\"Can't find task_id, user_id=%u, taks_id=%s, mode=%d\", user_id, task_id.c_str(), mode); break; } } // 状态转换 rv = transfer_task-\u003eChangePullState(user_id, mode); if (!rv) { // log(); break; // } // Ok auth_ = true; transfer_task_ = transfer_task; user_id_ = user_id; // 设置conn transfer_task-\u003eSetConnByUserID(user_id, this); rv = true; } while (0); IM::File::IMFileLoginRsp login_rsp; login_rsp.set_result_code(rv?0:1); login_rsp.set_task_id(task_id); ::SendMessageLite(this, SID_FILE, CID_FILE_LOGIN_RES, pdu-\u003eGetSeqNum(), \u0026login_rsp); if (rv) { if (transfer_task-\u003eGetTransMode() == FILE_TYPE_ONLINE) { if (transfer_task-\u003estate() == kTransferTaskStateWaitingTransfer) { CImConn* conn = transfer_task_-\u003eGetToConn(); if (conn) { _StatesNotify(CLIENT_FILE_PEER_READY, task_id, transfer_task_-\u003efrom_user_id(), conn); } else { log(\"to_conn is close, close me!!!\"); Close(); } // _StatesNotify(CLIENT_FILE_PEER_READY, task_id, user_id, this); // transfer_task-\u003eStatesNotify(CLIENT_FILE_PEER_READY, task_id, user_id_); } } else { if (transfer_task-\u003estate() == kTransferTaskStateWaitingUpload) { OfflineTransferTask* offline = reinterpret_cast\u003cOfflineTransferTask*\u003e(transfer_task); IM::File::IMFilePullDataReq pull_data_req; pull_data_req.set_task_id(task_id); pull_data_req.set_user_id(user_id); pull_data_req.set_trans_mode(FILE_TYPE_OFFLINE); pull_data_req.set_offset(0); pull_data_req.set_data_size(offline-\u003eGetNextSegmentBlockSize()); ::SendMessageLite(this, SID_FILE, CID_FILE_PULL_DATA_REQ, \u0026pull_data_req); log(\"Pull Data Req\"); } } } else { Close(); } } pc端收到CID_FILE_PULL_DATA_REQ后，表示这是一个离线文件，就可以直接上传文件数据了：\ncase IM::BaseDefine::FileCmdID::CID_FILE_PULL_DATA_REQ://发文件 _filePullDataReqResponse(pbBody); void FileTransferSocket::_filePullDataReqResponse(IN std::string\u0026 body)//发 { IM::File::IMFilePullDataReq imFilePullDataReq; if (!imFilePullDataReq.ParseFromString(body)) { LOG__(ERR, _T(\"parse failed,body:%s\"), util::stringToCString(body)); return; } UInt32 fileSize = imFilePullDataReq.data_size(); UInt32 fileOffset = imFilePullDataReq.offset(); std::string taskId = imFilePullDataReq.task_id(); TransferFileEntity fileEntity; if (!TransferFileEntityManager::getInstance()-\u003egetFileInfoByTaskId(taskId, fileEntity)) { LOG__(ERR, _T(\"PullDataReqResponse: can't find the fileInfo\")); return; } LOG__(DEBG, _T(\"send:taskId=%s,filesize=%d,name=%s,BolckSize=%d\") ,util::stringToCString(fileEntity.sTaskID) ,fileEntity.nFileSize ,fileEntity.getRealFileName() ,fileSize); std::string buff; if (nullptr == fileEntity.pFileObject) { LOG__(ERR, _T(\"PullDataReqResponse: file boject Destoryed!\")); return; } fileEntity.pFileObject-\u003ereadBlock(fileOffset, fileSize, buff);//读取本地文件的数据块 IM::File::IMFilePullDataRsp imFilePullDataRsp;//todo check imFilePullDataRsp.set_result_code(0); imFilePullDataRsp.set_task_id(taskId); imFilePullDataRsp.set_user_id(util::stringToInt32(fileEntity.sFromID)); imFilePullDataRsp.set_offset(fileOffset); imFilePullDataRsp.set_file_data((void*)buff.data(), fileSize); //send packet sendPacket(IM::BaseDefine::ServiceID::SID_FILE, IM::BaseDefine::FileCmdID::CID_FILE_PULL_DATA_RSP , \u0026imFilePullDataRsp); fileEntity.nProgress = fileOffset + fileSize; if (fileEntity.nProgress \u003c fileEntity.nFileSize) { //更新进度条 TransferFileEntityManager::getInstance()-\u003eupdateFileInfoBysTaskID(fileEntity);//保存当前进度 module::getFileTransferModule()-\u003easynNotifyObserver(module::KEY_FILESEVER_UPDATA_PROGRESSBAR , fileEntity.sTaskID); } else//传输完成 { if (fileEntity.pFileObject) { delete fileEntity.pFileObject; fileEntity.pFileObject = nullptr; } module::getFileTransferModule()-\u003easynNotifyObserver(module::KEY_FILESEVER_PROGRESSBAR_FINISHED , fileEntity.sTaskID); } TransferFileEntityManager::getInstance()-\u003eupdateFileInfoBysTaskID(fileEntity); } 当然，如果文件比较大，一次发不完也没关系，在CID_FILE_PULL_DATA_REQ中有当前文件的偏移量，客户端在读取文件和应答服务器时也带上这个偏移量fileOffset，应答给服务器的包是CID_FILE_PULL_DATA_RSP。file_server收到应答后处理：\nvoid FileClientConn::HandlePdu(CImPdu* pdu) { ... //省略无关代码 case CID_FILE_PULL_DATA_RSP: _HandleClientFilePullFileRsp( pdu); break ; ... //省略无关代码 } void FileClientConn::_HandleClientFilePullFileRsp(CImPdu *pdu) { if (!auth_ || !transfer_task_) { log(\"auth is false\"); return; } // 只有rsp IM::File::IMFilePullDataRsp pull_data_rsp; CHECK_PB_PARSE_MSG(pull_data_rsp.ParseFromArray(pdu-\u003eGetBodyData(), pdu-\u003eGetBodyLength())); uint32_t user_id = pull_data_rsp.user_id(); string task_id = pull_data_rsp.task_id(); uint32_t offset = pull_data_rsp.offset(); uint32_t data_size = static_cast\u003cuint32_t\u003e(pull_data_rsp.file_data().length()); const char* data = pull_data_rsp.file_data().data(); // log(\"Recv FilePullFileRsp, user_id=%d, task_id=%s, file_role=%d, offset=%d, datasize=%d\", user_id, task_id.c_str(), mode, offset, datasize); log(\"Recv FilePullFileRsp, task_id=%s, user_id=%u, offset=%u, data_size=%d\", task_id.c_str(), user_id, offset, data_size); int rv = -1; do { // // 检查user_id if (user_id != user_id_) { log(\"Received user_id valid, recv_user_id = %d, transfer_task.user_id = %d, user_id_ = %d\", user_id, transfer_task_-\u003efrom_user_id(), user_id_); break; } // 检查task_id if (transfer_task_-\u003etask_id() != task_id) { log(\"Received task_id valid, recv_task_id = %s, this_task_id = %s\", task_id.c_str(), transfer_task_-\u003etask_id().c_str()); // Close(); break; } rv = transfer_task_-\u003eDoRecvData(user_id, offset, data, data_size); if (rv == -1) { break; } if (transfer_task_-\u003eGetTransMode() == FILE_TYPE_ONLINE) { // 对于在线，直接转发 OnlineTransferTask* online = reinterpret_cast\u003cOnlineTransferTask*\u003e(transfer_task_); pdu-\u003eSetSeqNum(online-\u003eGetSeqNum()); // online-\u003eSetSeqNum(pdu-\u003eGetSeqNum()); CImConn* conn = transfer_task_-\u003eGetToConn(); if (conn) { conn-\u003eSendPdu(pdu); } } else { // 离线 // all packages recved if (rv == 1) { _StatesNotify(CLIENT_FILE_DONE, task_id, user_id, this); // Close(); } else { OfflineTransferTask* offline = reinterpret_cast\u003cOfflineTransferTask*\u003e(transfer_task_); IM::File::IMFilePullDataReq pull_data_req; pull_data_req.set_task_id(task_id); pull_data_req.set_user_id(user_id); pull_data_req.set_trans_mode(static_cast\u003cIM::BaseDefine::TransferFileType\u003e(offline-\u003eGetTransMode())); pull_data_req.set_offset(offline-\u003eGetNextOffset()); pull_data_req.set_data_size(offline-\u003eGetNextSegmentBlockSize()); ::SendMessageLite(this, SID_FILE, CID_FILE_PULL_DATA_REQ, \u0026pull_data_req); // log(\"size not match\"); } } } while (0); if (rv!=0) { // -1，出错关闭 // 1, 离线上传完成 Close(); } } 如果是在线文件，就直接转发含有文件数据的包；如果是离线文件，则存入文件服务上，即写入文件：\nint OfflineTransferTask::DoRecvData(uint32_t user_id, uint32_t offset, const char* data, uint32_t data_size) { // 离线文件上传 int rv = -1; do { // 检查是否发送者 if (!CheckFromUserID(user_id)) { log(\"rsp user_id=%d, but sender_id is %d\", user_id, from_user_id_); break; } // 检查状态 if (state_ != kTransferTaskStateWaitingUpload \u0026\u0026 state_ != kTransferTaskStateUploading) { log(\"state=%d error, need kTransferTaskStateWaitingUpload or kTransferTaskStateUploading\", state_); break; } // 检查offset是否有效 if (offset != transfered_idx_*SEGMENT_SIZE) { break; } //if (data_size != GetNextSegmentBlockSize()) { // break; //} // todo // 检查文件大小 data_size = GetNextSegmentBlockSize(); log(\"Ready recv data, offset=%d, data_size=%d, segment_size=%d\", offset, data_size, sengment_size_); if (state_ == kTransferTaskStateWaitingUpload) { if (fp_ == NULL) { fp_ = OpenByWrite(task_id_, to_user_id_); if (fp_ == NULL) { break; } } // 写文件头 OfflineFileHeader file_header; memset(\u0026file_header, 0, sizeof(file_header)); file_header.set_create_time(time(NULL)); file_header.set_task_id(task_id_); file_header.set_from_user_id(from_user_id_); file_header.set_to_user_id(to_user_id_); file_header.set_file_name(\"\"); file_header.set_file_size(file_size_); fwrite(\u0026file_header, 1, sizeof(file_header), fp_); fflush(fp_); state_ = kTransferTaskStateUploading; } // 存储 if (fp_ == NULL) { // break; } fwrite(data, 1, data_size, fp_); fflush(fp_); ++transfered_idx_; SetLastUpdateTime(); if (transfered_idx_ == sengment_size_) { state_ = kTransferTaskStateUploadEnd; fclose(fp_); fp_ = NULL; rv = 1; } else { rv = 0; } } while (0); return rv; } 如此循环，直至文件传输完成。当然文件上传完成后file_server也会断开与客户端的连接。\n到这里我们介绍了发送文件方的逻辑，下面我们看看接收方的逻辑，上文中介绍了接收方会收到接收文件的通知CID_FILE_NOTIFY，客户端处理这个命令号：\ncase IM::BaseDefine::FileCmdID::CID_FILE_NOTIFY://收到“发送文件请求” _fileNotify(pbBody);\t_fileNotify(pbBody); void FileTransferModule_Impl::_fileNotify(IN std::string\u0026 body) { IM::File::IMFileNotify imFileNotify; if (!imFileNotify.ParseFromString(body)) { LOG__(ERR, _T(\"parse failed,body:%s\"), util::stringToCString(body)); return; } TransferFileEntity file; file.sFileName = imFileNotify.file_name(); file.sFromID = util::uint32ToString(imFileNotify.from_user_id()); file.sToID = util::uint32ToString(imFileNotify.to_user_id()); file.sTaskID = imFileNotify.task_id(); file.nFileSize = imFileNotify.file_size(); UINT32 nIPCount = imFileNotify.ip_addr_list_size(); if (nIPCount \u003c= 0) { return; } const IM::BaseDefine::IpAddr\u0026 ipAdd = imFileNotify.ip_addr_list(0); file.sIP = ipAdd.ip(); file.nPort = ipAdd.port(); uint32_t transMode = imFileNotify.trans_mode(); if (IM::BaseDefine::TransferFileType::FILE_TYPE_ONLINE == transMode) { file.nClientMode = IM::BaseDefine::ClientFileRole::CLIENT_REALTIME_RECVER; } else if (IM::BaseDefine::TransferFileType::FILE_TYPE_OFFLINE == transMode) { file.nClientMode = IM::BaseDefine::ClientFileRole::CLIENT_OFFLINE_DOWNLOAD; } file.time = static_cast\u003cUInt32\u003e(time(0)); TransferFileEntityManager::getInstance()-\u003epushTransferFileEntity(file); LOG__(DEBG, _T(\"FileTransferSevice_Impl::给你发文件 sFileID = %s\"), util::stringToCString(file.sTaskID)); if (1 == imFileNotify.offline_ready()) { //TODO离线文件传输结束 } //连接服务器 TransferFileEntityManager::getInstance()-\u003eopenFileSocketByTaskId(file.sTaskID); } 其实也就是接收方会去连接文件服务器。连接成功以后，在对应的回调函数里面触发显示接收文件对话框。但是此时实际上还不能接收文件，因为发送方可能还没准备好。发送方要准备啥呢？前面我们已经介绍了，我们梳理一下上述流程：\n发送方先向msg_server请求发送文件，msg_server转发给file_server；\nfile_server应答msg_server并告诉msg_server自己的地址和端口号；\nmsg_server收到file_server的应答后，先回复发送方，再转发给接收方；\n发送方接着发送登录请求给file_server，file_server收到请求决定是否给发送方发送拉取文件的数据包。如果是离线文件，则会立刻给发送方发送拉取文件的数据包；如果是在线文件，则需要等待接收方同意接收。\n所以，必须过了步骤4，一直到file_server应答了发送方的登录文件服务器请求后，发送方才算准备好。此时，file_server知道发送方已经准备好了，给接收方发送数据包CID_FILE_STATE。接收方收到这个命令号后：\ncase IM::BaseDefine::FileCmdID::CID_FILE_STATE:// _fileState(pbBody); void FileTransferSocket::_fileState(IN std::string\u0026 body) { IM::File::IMFileState imFileState; if (!imFileState.ParseFromString(body)) { LOG__(ERR, _T(\"parse failed,body:%s\"), util::stringToCString(body)); return; } UINT32 nfileState = imFileState.state(); std::string taskId = imFileState.task_id(); TransferFileEntity fileEntity; if (!TransferFileEntityManager::getInstance()-\u003egetFileInfoByTaskId(taskId, fileEntity)) { LOG__(ERR, _T(\"fileState:can't find the fileInfo \")); return; } switch (nfileState) { case IM::BaseDefine::ClientFileState::CLIENT_FILE_PEER_READY: LOG__(APP, _T(\"fileState--CLIENT_FILE_PEER_READY \")); break; case IM::BaseDefine::ClientFileState::CLIENT_FILE_CANCEL ://取消的了文件传输 LOG__(APP, _T(\"fileState--CLIENT_FILE_CANCEL \")); { if (fileEntity.pFileObject) { delete fileEntity.pFileObject; fileEntity.pFileObject = nullptr; } TransferFileEntityManager::getInstance()-\u003eupdateFileInfoBysTaskID(fileEntity); module::getFileTransferModule()-\u003easynNotifyObserver(module::KEY_FILESEVER_UPLOAD_CANCEL, fileEntity.sTaskID); } break; case IM::BaseDefine::ClientFileState::CLIENT_FILE_REFUSE://拒绝了文件 LOG__(APP, _T(\"fileState--CLIENT_FILE_REFUSE \")); { if (fileEntity.pFileObject) { delete fileEntity.pFileObject; fileEntity.pFileObject = nullptr; } TransferFileEntityManager::getInstance()-\u003eupdateFileInfoBysTaskID(fileEntity); module::getFileTransferModule()-\u003easynNotifyObserver(module::KEY_FILESEVER_UPLOAD_REJECT, fileEntity.sTaskID); } break; case IM::BaseDefine::ClientFileState::CLIENT_FILE_DONE: LOG__(APP, _T(\"fileState--CLIENT_FILE_DONE \")); if (fileEntity.pFileObject) { delete fileEntity.pFileObject; fileEntity.pFileObject = nullptr; } TransferFileEntityManager::getInstance()-\u003eupdateFileInfoBysTaskID(fileEntity); module::getFileTransferModule()-\u003easynNotifyObserver(module::KEY_FILESEVER_PROGRESSBAR_FINISHED, fileEntity.sTaskID); break; default: break; } } 同理，对于接收方，选择接收还是拒绝文件的逻辑也是在这里一起处理的，与此类似，这里就不再重复叙述了。\n接收方下载文件的逻辑和发送方上传文件的逻辑类似。这里也不在描述了。\n最后说一点我的建议，teamtalk的file_server逻辑、以及与客户端还有msg_server的逻辑流程加上各种细节写的比较的细腻，代码实现上也比较好。强烈建议好好地阅读这部分的代码。毕竟很多人在自己实现一个文件服务器时，还是存在不少问题的。\n​\n",
  "wordCount" : "2543",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/c5f5c9828a6f472d9768cffc2f548784/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      08 服务器端file_server源码分析
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#08-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%affile_server%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" aria-label="08 服务器端file_server源码分析">08 服务器端file_server源码分析</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="08-服务器端file_server源码分析">08 服务器端file_server源码分析</h1>
<p>这篇文章我们来介绍file_server服务的功能和源码实现。TeamTalk支持离线在线文件和离线文件两种传送文件的方式。单纯地研究file_server的程序结构没多大意义，因为其程序结构和其他几个服务结构基本上一模一样，前面几篇文章已经介绍过了。 我们研究teamtalk的file_server是为了学习和借鉴teamtalk的文件传输功能实现思路，以内化为自己的知识，并加以应用。</p>
<p>所以这篇文章，我们将pc客户端的文件传输功能、msg_server转发消息、file_server处理文件数据三个方面结合起来一起介绍。</p>
<p>下面开始啦。</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/b5176e5e61fbb5a73c357b73fa8cdece.jpg" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>一、连接状况介绍</p>
<p>fileserver开始并不是和客户端连接的，客户端是按需连接file_server的。但是file_server与msg_server却是长连接。先启动file_server，再启动msg_server。msg_server初始化的时候，会去尝试连接file_server的8601端口。连接成功以后，会给file_server发送一个发包询问file_server侦听客户端连接的ip和端口号信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CFileServConn<span style="color:#f92672">::</span>OnConfirm()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	log(<span style="color:#e6db74">&#34;connect to file server success &#34;</span>);
</span></span><span style="display:flex;"><span>	m_bOpen <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	m_connect_time <span style="color:#f92672">=</span> get_tick_count();
</span></span><span style="display:flex;"><span>	g_file_server_list[m_serv_idx].reconnect_cnt <span style="color:#f92672">=</span> MIN_RECONNECT_CNT <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//连上file_server以后，给file_server发送获取ip地址的数据包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMFileServerIPReq msg;
</span></span><span style="display:flex;"><span>    CImPdu pdu;
</span></span><span style="display:flex;"><span>    pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>    pdu.SetServiceId(SID_OTHER);
</span></span><span style="display:flex;"><span>    pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ);
</span></span><span style="display:flex;"><span>    SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>file_server收到该数据包后，将自己的侦听客户端连接的ip地址和端口号发包告诉msg_server：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileMsgServerConn<span style="color:#f92672">::</span>_HandleGetServerAddressReq(CImPdu<span style="color:#f92672">*</span> pPdu) {
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMFileServerIPRsp msg;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">&gt;&amp;</span> addrs <span style="color:#f92672">=</span> ConfigUtil<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>GetAddressList();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">&gt;::</span>const_iterator it<span style="color:#f92672">=</span>addrs.begin(); it<span style="color:#f92672">!=</span>addrs.end(); <span style="color:#f92672">++</span>it) {
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">*</span> addr <span style="color:#f92672">=</span> msg.add_ip_addr_list();
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>addr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it;
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;Upload file_client_conn addr info, ip=%s, port=%d&#34;</span>, addr<span style="color:#f92672">-&gt;</span>ip().c_str(), addr<span style="color:#f92672">-&gt;</span>port());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SendMessageLite(<span style="color:#66d9ef">this</span>, SID_OTHER, CID_OTHER_FILE_SERVER_IP_RSP, pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum(), <span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>得到的信息是file_server侦听的ip地址和端口号，默认配置的端口号是8600。也就是说file_server的8600用于客户端连接，8601端口用于msg_server连接。这样，客户端需要传输文件（注意：不是聊天图片，聊天图片使用另外一个服务msfs进行传输），会先告诉msg_server它需要进行文件传输，msg_server收到消息后告诉客户端，你连file_server来传输文件吧，并把file_server的地址和端口号告诉客户端。客户端这个时候连接file_server进行文件传输。我们来具体看一看这个流程的细节信息：</p>
<ol>
<li>客户端发包给msg_server说要进行文件发送</li>
</ol>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/1ccd8f3ba87188bb6fcb2231d19d8cb4.jpg" alt=""  />
</p>
<p>然后选择一个文件：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/dc7ea845db9416def44fe505a622374e.jpg" alt=""  />
</p>
<p>pc客户端发送文件逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//pc客户端代码(Modules工程SessionLayout.cpp)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> SessionLayout<span style="color:#f92672">::</span>Notify(TNotifyUI<span style="color:#f92672">&amp;</span> msg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (msg.pSender <span style="color:#f92672">==</span> m_pBtnsendfile) <span style="color:#75715e">//文件传输
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	{
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>UserInfoEntity userInfo;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>module<span style="color:#f92672">::</span>getUserListModule()<span style="color:#f92672">-&gt;</span>getUserInfoBySId(m_sId, userInfo))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;SendFile can&#39;t find the sid&#34;</span>));
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		CFileDialog	<span style="color:#a6e22e">fileDlg</span>(TRUE, NULL, NULL, OFN_HIDEREADONLY <span style="color:#f92672">|</span> OFN_FILEMUSTEXIST
</span></span><span style="display:flex;"><span>			, _T(<span style="color:#e6db74">&#34;文件|*.*||&#34;</span>), AfxGetMainWnd());
</span></span><span style="display:flex;"><span>		fileDlg.m_ofn.Flags <span style="color:#f92672">|=</span> OFN_NOCHANGEDIR;
</span></span><span style="display:flex;"><span>		fileDlg.DoModal();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		CString sPathName;
</span></span><span style="display:flex;"><span>		POSITION nPos <span style="color:#f92672">=</span> fileDlg.GetStartPosition();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (nPos <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			sPathName <span style="color:#f92672">=</span> fileDlg.GetNextPathName(nPos);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (sPathName.IsEmpty())
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>sendFile(sPathName, m_sId, userInfo.isOnlne());
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>sPathName是文件的全饰路径；m_sId是收取文件的用户id，userInfo.isOnlne()判断m_sId代表的用户是否在线，以此来决定这次文件传输是在线文件还是离线文件模式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL FileTransferModule_Impl<span style="color:#f92672">::</span>sendFile(IN <span style="color:#66d9ef">const</span> CString<span style="color:#f92672">&amp;</span> sFilePath, IN <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> sSendToSID,IN BOOL bOnlineMode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>checkIfIsSending(sFilePath))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	TransferFileEntity fileEntity;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//获取文件大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__stat64</span> buffer;
</span></span><span style="display:flex;"><span>	_wstat64(sFilePath, <span style="color:#f92672">&amp;</span>buffer);
</span></span><span style="display:flex;"><span>	fileEntity.nFileSize <span style="color:#f92672">=</span> (UInt32)buffer.st_size;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">!=</span> fileEntity.nFileSize)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		CString strFileName <span style="color:#f92672">=</span> sFilePath;
</span></span><span style="display:flex;"><span>		strFileName.Replace(_T(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span>), _T(<span style="color:#e6db74">&#34;/&#34;</span>));<span style="color:#75715e">//mac上对于路径字符“\”需要做特殊处理，windows上则可以识别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		fileEntity.sFileName <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>cStringToString(strFileName);
</span></span><span style="display:flex;"><span>		fileEntity.sFromID <span style="color:#f92672">=</span> module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>userID();
</span></span><span style="display:flex;"><span>		fileEntity.sToID <span style="color:#f92672">=</span> sSendToSID;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint32_t</span> transMode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		transMode <span style="color:#f92672">=</span> bOnlineMode <span style="color:#f92672">?</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType<span style="color:#f92672">::</span>FILE_TYPE_ONLINE : IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType<span style="color:#f92672">::</span>FILE_TYPE_OFFLINE;
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		LOG__(DEBG,_T(<span style="color:#e6db74">&#34;FileTransferSevice_Impl::sendFile sTaskID = %s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(fileEntity.sTaskID));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		imcore<span style="color:#f92672">::</span>IMLibCoreStartOperationWithLambda(
</span></span><span style="display:flex;"><span>			[<span style="color:#f92672">=</span>]()
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileReq imFileReq;
</span></span><span style="display:flex;"><span>            LOG__(APP, _T(<span style="color:#e6db74">&#34;imFileReq,name=%s,size=%d,toId=%s&#34;</span>),util<span style="color:#f92672">::</span>stringToCString(fileEntity.sFileName)
</span></span><span style="display:flex;"><span>                ,fileEntity.nFileSize,util<span style="color:#f92672">::</span>stringToCString(fileEntity.sToID));
</span></span><span style="display:flex;"><span>			imFileReq.set_from_user_id(util<span style="color:#f92672">::</span>stringToInt32(fileEntity.sFromID));
</span></span><span style="display:flex;"><span>			imFileReq.set_to_user_id(util<span style="color:#f92672">::</span>stringToInt32(fileEntity.sToID));
</span></span><span style="display:flex;"><span>			imFileReq.set_file_name(fileEntity.sFileName);
</span></span><span style="display:flex;"><span>			imFileReq.set_file_size(fileEntity.nFileSize);
</span></span><span style="display:flex;"><span>			imFileReq.set_trans_mode(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType<span style="color:#f92672">&gt;</span>(transMode));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			module<span style="color:#f92672">::</span>getTcpClientModule()<span style="color:#f92672">-&gt;</span>sendPacket(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ServiceID<span style="color:#f92672">::</span>SID_FILE
</span></span><span style="display:flex;"><span>				, IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FileCmdID<span style="color:#f92672">::</span>CID_FILE_REQUEST
</span></span><span style="display:flex;"><span>				, <span style="color:#f92672">&amp;</span>imFileReq);
</span></span><span style="display:flex;"><span>		});
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    LOG__(ERR, _T(<span style="color:#e6db74">&#34;fileEntity FileSize error,size = %d&#34;</span>), fileEntity.nFileSize);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中组装的包信息中含有要传输的文件路径、文件大小、发送人id、接收方id、文件传输模式（在线还是离线），包的命令号是IM::BaseDefine::FileCmdID::CID_FILE_REQUEST。这个包发给msg_server以后，msg_server应答：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CMsgConn<span style="color:#f92672">::</span>HandlePdu(CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#75715e">//省略无关代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">case</span> CID_FILE_REQUEST:
</span></span><span style="display:flex;"><span>            s_file_handler<span style="color:#f92672">-&gt;</span>HandleClientFileRequest(<span style="color:#66d9ef">this</span>, pPdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#75715e">//省略无关代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CFileHandler<span style="color:#f92672">::</span>HandleClientFileRequest(CMsgConn<span style="color:#f92672">*</span> pMsgConn, CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileReq msg;
</span></span><span style="display:flex;"><span>    CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pPdu<span style="color:#f92672">-&gt;</span>GetBodyLength()));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> from_id <span style="color:#f92672">=</span> pMsgConn<span style="color:#f92672">-&gt;</span>GetUserId();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> to_id <span style="color:#f92672">=</span> msg.to_user_id();
</span></span><span style="display:flex;"><span>    string file_name <span style="color:#f92672">=</span> msg.file_name();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> file_size <span style="color:#f92672">=</span> msg.file_size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> trans_mode <span style="color:#f92672">=</span> msg.trans_mode();
</span></span><span style="display:flex;"><span>    log(<span style="color:#e6db74">&#34;HandleClientFileRequest, %u-&gt;%u, fileName: %s, trans_mode: %u.&#34;</span>, from_id, to_id, file_name.c_str(), trans_mode);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    CDbAttachData <span style="color:#a6e22e">attach</span>(ATTACH_TYPE_HANDLE, pMsgConn<span style="color:#f92672">-&gt;</span>GetHandle());
</span></span><span style="display:flex;"><span>    CFileServConn<span style="color:#f92672">*</span> pFileConn <span style="color:#f92672">=</span> get_random_file_serv_conn();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pFileConn)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMFileTransferReq msg2;
</span></span><span style="display:flex;"><span>        msg2.set_from_user_id(from_id);
</span></span><span style="display:flex;"><span>        msg2.set_to_user_id(to_id);
</span></span><span style="display:flex;"><span>        msg2.set_file_name(file_name);
</span></span><span style="display:flex;"><span>        msg2.set_file_size(file_size);
</span></span><span style="display:flex;"><span>        msg2.set_trans_mode((IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType)trans_mode);
</span></span><span style="display:flex;"><span>        msg2.set_attach_data(attach.GetBuffer(), attach.GetLength());
</span></span><span style="display:flex;"><span>        CImPdu pdu;
</span></span><span style="display:flex;"><span>        pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg2);
</span></span><span style="display:flex;"><span>        pdu.SetServiceId(SID_OTHER);
</span></span><span style="display:flex;"><span>        pdu.SetCommandId(CID_OTHER_FILE_TRANSFER_REQ);
</span></span><span style="display:flex;"><span>        pdu.SetSeqNum(pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FILE_TYPE_OFFLINE <span style="color:#f92672">==</span> trans_mode)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            pFileConn<span style="color:#f92672">-&gt;</span>SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">//IM::BaseDefine::FILE_TYPE_ONLINE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        {
</span></span><span style="display:flex;"><span>            CImUser<span style="color:#f92672">*</span> pUser <span style="color:#f92672">=</span> CImUserManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>GetImUserById(to_id);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pUser <span style="color:#f92672">&amp;&amp;</span> pUser<span style="color:#f92672">-&gt;</span>GetPCLoginStatus())<span style="color:#75715e">//已有对应的账号pc登录状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                pFileConn<span style="color:#f92672">-&gt;</span>SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span><span style="color:#75715e">//无对应用户的pc登录状态,向route_server查询状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//no pc_client in this msg_server, check it from route_server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                CPduAttachData <span style="color:#a6e22e">attach_data</span>(ATTACH_TYPE_HANDLE_AND_PDU_FOR_FILE, pMsgConn<span style="color:#f92672">-&gt;</span>GetHandle(), pdu.GetBodyLength(), pdu.GetBodyData());
</span></span><span style="display:flex;"><span>                IM<span style="color:#f92672">::</span>Buddy<span style="color:#f92672">::</span>IMUsersStatReq msg3;
</span></span><span style="display:flex;"><span>                msg3.set_user_id(from_id);
</span></span><span style="display:flex;"><span>                msg3.add_user_id_list(to_id);
</span></span><span style="display:flex;"><span>                msg3.set_attach_data(attach_data.GetBuffer(), attach_data.GetLength());
</span></span><span style="display:flex;"><span>                CImPdu pdu2;
</span></span><span style="display:flex;"><span>                pdu2.SetPBMsg(<span style="color:#f92672">&amp;</span>msg3);
</span></span><span style="display:flex;"><span>                pdu2.SetServiceId(SID_BUDDY_LIST);
</span></span><span style="display:flex;"><span>                pdu2.SetCommandId(CID_BUDDY_LIST_USERS_STATUS_REQUEST);
</span></span><span style="display:flex;"><span>                pdu2.SetSeqNum(pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>                CRouteServConn<span style="color:#f92672">*</span> route_conn <span style="color:#f92672">=</span> get_route_serv_conn();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (route_conn)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    route_conn<span style="color:#f92672">-&gt;</span>SendPdu(<span style="color:#f92672">&amp;</span>pdu2);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;HandleClientFileRequest, no file server.   &#34;</span>);
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileRsp msg2;
</span></span><span style="display:flex;"><span>        msg2.set_result_code(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        msg2.set_from_user_id(from_id);
</span></span><span style="display:flex;"><span>        msg2.set_to_user_id(to_id);
</span></span><span style="display:flex;"><span>        msg2.set_file_name(file_name);
</span></span><span style="display:flex;"><span>        msg2.set_task_id(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>        msg2.set_trans_mode((IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType)trans_mode);
</span></span><span style="display:flex;"><span>        CImPdu pdu;
</span></span><span style="display:flex;"><span>        pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg2);
</span></span><span style="display:flex;"><span>        pdu.SetServiceId(SID_FILE);
</span></span><span style="display:flex;"><span>        pdu.SetCommandId(CID_FILE_RESPONSE);
</span></span><span style="display:flex;"><span>        pdu.SetSeqNum(pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>        pMsgConn<span style="color:#f92672">-&gt;</span>SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段代码，很有讲究，msg_server会检测file_server是否已经启动，如果没有启动，则直接发包告诉客户端，file_server不存在。另外，如果该文件传输模式是在线文件，会判断接收文件的用户是否和发送用户在同一台msg_server上。不在的话，则给route_server发送消息，查找该用户所在的msg_server（这个不具体介绍了，后面分析route_server会专门介绍的）。否则，会将文件发送请求转发给file_server，包的命令号是CID_OTHER_FILE_TRANSFER_REQ。file_server收到该请求后，处理如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileMsgServerConn<span style="color:#f92672">::</span>HandlePdu(CImPdu<span style="color:#f92672">*</span> pdu) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>     ...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码      
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> CID_OTHER_FILE_TRANSFER_REQ:
</span></span><span style="display:flex;"><span>		_HandleMsgFileTransferReq(pdu);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span> ;
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码        
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileMsgServerConn<span style="color:#f92672">::</span>_HandleMsgFileTransferReq(CImPdu<span style="color:#f92672">*</span> pdu) {
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMFileTransferReq transfer_req;
</span></span><span style="display:flex;"><span>    CHECK_PB_PARSE_MSG(transfer_req.ParseFromArray(pdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pdu<span style="color:#f92672">-&gt;</span>GetBodyLength()));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> from_id <span style="color:#f92672">=</span> transfer_req.from_user_id();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> to_id <span style="color:#f92672">=</span> transfer_req.to_user_id();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMFileTransferRsp transfer_rsp;
</span></span><span style="display:flex;"><span>    transfer_rsp.set_result_code(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    transfer_rsp.set_from_user_id(from_id);
</span></span><span style="display:flex;"><span>    transfer_rsp.set_to_user_id(to_id);
</span></span><span style="display:flex;"><span>    transfer_rsp.set_file_name(transfer_req.file_name());
</span></span><span style="display:flex;"><span>    transfer_rsp.set_file_size(transfer_req.file_size());
</span></span><span style="display:flex;"><span>    transfer_rsp.set_task_id(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>    transfer_rsp.set_trans_mode(transfer_req.trans_mode());
</span></span><span style="display:flex;"><span>    transfer_rsp.set_attach_data(transfer_req.attach_data());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> rv <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>string task_id <span style="color:#f92672">=</span> GenerateUUID();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (task_id.empty()) {
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;Create task id failed&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;trams_mode=%d, task_id=%s, from_id=%d, to_id=%d, file_name=%s, file_size=%d&#34;</span>, transfer_req.trans_mode(), task_id.c_str(), from_id, to_id, transfer_req.file_name().c_str(), transfer_req.file_size());
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        BaseTransferTask<span style="color:#f92672">*</span> transfer_task <span style="color:#f92672">=</span> TransferTaskManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>NewTransferTask(
</span></span><span style="display:flex;"><span>                                                                                              transfer_req.trans_mode(),
</span></span><span style="display:flex;"><span>                                                                                              task_id,
</span></span><span style="display:flex;"><span>                                                                                              from_id,
</span></span><span style="display:flex;"><span>                                                                                              to_id,
</span></span><span style="display:flex;"><span>                                                                                              transfer_req.file_name(),
</span></span><span style="display:flex;"><span>                                                                                              transfer_req.file_size());
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (transfer_task <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 创建未成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// close connection with msg svr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// need_close = true;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            log(<span style="color:#e6db74">&#34;Create task failed&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        transfer_rsp.set_result_code(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        transfer_rsp.set_task_id(task_id);
</span></span><span style="display:flex;"><span>        rv <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// need_seq_no = false;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;Create task succeed, task id %s, task type %d, from user %d, to user %d&#34;</span>, task_id.c_str(), transfer_req.trans_mode(), from_id, to_id);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span>SendMessageLite(<span style="color:#66d9ef">this</span>, SID_OTHER, CID_OTHER_FILE_TRANSFER_RSP, pdu<span style="color:#f92672">-&gt;</span>GetSeqNum(), <span style="color:#f92672">&amp;</span>transfer_rsp);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>rv) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 未创建成功，关闭连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码会为本次传输任务创建一个唯一的标识uuid作为taskid，然后根据离线文件还是在线文件创建离线文件传输任务OfflineTransferTask或者在线文件传输任务OnlineTransferTask，并加入一个一个成员变量transfer_tasks_中进行管理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BaseTransferTask<span style="color:#f92672">*</span> TransferTaskManager<span style="color:#f92672">::</span>NewTransferTask(<span style="color:#66d9ef">uint32_t</span> trans_mode, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> task_id, <span style="color:#66d9ef">uint32_t</span> from_user_id, <span style="color:#66d9ef">uint32_t</span> to_user_id, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> file_name, <span style="color:#66d9ef">uint32_t</span> file_size) {
</span></span><span style="display:flex;"><span>    BaseTransferTask<span style="color:#f92672">*</span> transfer_task <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    TransferTaskMap<span style="color:#f92672">::</span>iterator it <span style="color:#f92672">=</span> transfer_tasks_.find(task_id);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (it<span style="color:#f92672">==</span>transfer_tasks_.end()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (trans_mode <span style="color:#f92672">==</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FILE_TYPE_ONLINE) {
</span></span><span style="display:flex;"><span>            transfer_task <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OnlineTransferTask(task_id, from_user_id, to_user_id, file_name, file_size);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (trans_mode <span style="color:#f92672">==</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FILE_TYPE_OFFLINE) {
</span></span><span style="display:flex;"><span>            transfer_task <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OfflineTransferTask(task_id, from_user_id, to_user_id, file_name, file_size);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;Invalid trans_mode = %d&#34;</span>, trans_mode);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (transfer_task) {
</span></span><span style="display:flex;"><span>            transfer_tasks_.insert(std<span style="color:#f92672">::</span>make_pair(task_id, transfer_task));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;Task existed by task_id=%s, why?????&#34;</span>, task_id.c_str());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> transfer_task;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个map transfer_tasks_是在定时器里面进行定期处理的，处理的依据是当前任务的状态，比如已经完成的任务就可以从map中移除了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TransferTaskManager<span style="color:#f92672">::</span>OnTimer(<span style="color:#66d9ef">uint64_t</span> tick) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (TransferTaskMap<span style="color:#f92672">::</span>iterator it <span style="color:#f92672">=</span> transfer_tasks_.begin(); it <span style="color:#f92672">!=</span> transfer_tasks_.end();) {
</span></span><span style="display:flex;"><span>        BaseTransferTask<span style="color:#f92672">*</span> task <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (task <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            transfer_tasks_.erase(it<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (task<span style="color:#f92672">-&gt;</span>state() <span style="color:#f92672">!=</span> kTransferTaskStateWaitingUpload <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            task<span style="color:#f92672">-&gt;</span>state() <span style="color:#f92672">==</span> kTransferTaskStateTransferDone) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> esp <span style="color:#f92672">=</span> time(NULL) <span style="color:#f92672">-</span> task<span style="color:#f92672">-&gt;</span>create_time();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (esp <span style="color:#f92672">&gt;</span> ConfigUtil<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>GetTaskTimeout()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (task<span style="color:#f92672">-&gt;</span>GetFromConn()) {
</span></span><span style="display:flex;"><span>                    FileClientConn<span style="color:#f92672">*</span> conn <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>FileClientConn<span style="color:#f92672">*&gt;</span>(task<span style="color:#f92672">-&gt;</span>GetFromConn());
</span></span><span style="display:flex;"><span>                    conn<span style="color:#f92672">-&gt;</span>ClearTransferTask();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (task<span style="color:#f92672">-&gt;</span>GetToConn()) {
</span></span><span style="display:flex;"><span>                    FileClientConn<span style="color:#f92672">*</span> conn <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>FileClientConn<span style="color:#f92672">*&gt;</span>(task<span style="color:#f92672">-&gt;</span>GetToConn());
</span></span><span style="display:flex;"><span>                    conn<span style="color:#f92672">-&gt;</span>ClearTransferTask();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">delete</span> task;
</span></span><span style="display:flex;"><span>                transfer_tasks_.erase(it<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>完成这些工作以后，组装的应答包命令号是CID_OTHER_FILE_TRANSFER_RSP，回复给msg_server。msg_server收到该应答包后处理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CFileServConn<span style="color:#f92672">::</span>HandlePdu(CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (pPdu<span style="color:#f92672">-&gt;</span>GetCommandId()) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> CID_OTHER_FILE_TRANSFER_RSP:
</span></span><span style="display:flex;"><span>            _HandleFileMsgTransRsp(pPdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CFileServConn<span style="color:#f92672">::</span>_HandleFileMsgTransRsp(CImPdu<span style="color:#f92672">*</span> pPdu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>Server<span style="color:#f92672">::</span>IMFileTransferRsp msg;
</span></span><span style="display:flex;"><span>    CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pPdu<span style="color:#f92672">-&gt;</span>GetBodyLength()));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> result <span style="color:#f92672">=</span> msg.result_code();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> from_id <span style="color:#f92672">=</span> msg.from_user_id();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> to_id <span style="color:#f92672">=</span> msg.to_user_id();
</span></span><span style="display:flex;"><span>    string file_name <span style="color:#f92672">=</span> msg.file_name();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> file_size <span style="color:#f92672">=</span> msg.file_size();
</span></span><span style="display:flex;"><span>    string task_id <span style="color:#f92672">=</span> msg.task_id();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> trans_mode <span style="color:#f92672">=</span> msg.trans_mode();
</span></span><span style="display:flex;"><span>    CDbAttachData <span style="color:#a6e22e">attach</span>((uchar_t<span style="color:#f92672">*</span>)msg.attach_data().c_str(), msg.attach_data().length());
</span></span><span style="display:flex;"><span>    log(<span style="color:#e6db74">&#34;HandleFileMsgTransRsp, result: %u, from_user_id: %u, to_user_id: %u, file_name: %s, \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        task_id: %s, trans_mode: %u. &#34;</span>, result, from_id, to_id,
</span></span><span style="display:flex;"><span>        file_name.c_str(), task_id.c_str(), trans_mode);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> list<span style="color:#f92672">&lt;</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">&gt;*</span> ip_addr_list <span style="color:#f92672">=</span> GetFileServerIPList();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileRsp msg2;
</span></span><span style="display:flex;"><span>    msg2.set_result_code(result);
</span></span><span style="display:flex;"><span>    msg2.set_from_user_id(from_id);
</span></span><span style="display:flex;"><span>    msg2.set_to_user_id(to_id);
</span></span><span style="display:flex;"><span>    msg2.set_file_name(file_name);
</span></span><span style="display:flex;"><span>    msg2.set_task_id(task_id);
</span></span><span style="display:flex;"><span>    msg2.set_trans_mode((IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType)trans_mode);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">&gt;::</span>const_iterator it <span style="color:#f92672">=</span> ip_addr_list<span style="color:#f92672">-&gt;</span>begin(); it <span style="color:#f92672">!=</span> ip_addr_list<span style="color:#f92672">-&gt;</span>end(); it<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr ip_addr_tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it;
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">*</span> ip_addr <span style="color:#f92672">=</span> msg2.add_ip_addr_list();
</span></span><span style="display:flex;"><span>        ip_addr<span style="color:#f92672">-&gt;</span>set_ip(ip_addr_tmp.ip());
</span></span><span style="display:flex;"><span>        ip_addr<span style="color:#f92672">-&gt;</span>set_port(ip_addr_tmp.port());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    CImPdu pdu;
</span></span><span style="display:flex;"><span>    pdu.SetPBMsg(<span style="color:#f92672">&amp;</span>msg2);
</span></span><span style="display:flex;"><span>    pdu.SetServiceId(SID_FILE);
</span></span><span style="display:flex;"><span>    pdu.SetCommandId(CID_FILE_RESPONSE);
</span></span><span style="display:flex;"><span>    pdu.SetSeqNum(pPdu<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> handle <span style="color:#f92672">=</span> attach.GetHandle();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    CMsgConn<span style="color:#f92672">*</span> pFromConn <span style="color:#f92672">=</span> CImUserManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>GetMsgConnByHandle(from_id, handle);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pFromConn)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        pFromConn<span style="color:#f92672">-&gt;</span>SendPdu(<span style="color:#f92672">&amp;</span>pdu);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileNotify msg3;
</span></span><span style="display:flex;"><span>        msg3.set_from_user_id(from_id);
</span></span><span style="display:flex;"><span>        msg3.set_to_user_id(to_id);
</span></span><span style="display:flex;"><span>        msg3.set_file_name(file_name);
</span></span><span style="display:flex;"><span>        msg3.set_file_size(file_size);
</span></span><span style="display:flex;"><span>        msg3.set_task_id(task_id);
</span></span><span style="display:flex;"><span>        msg3.set_trans_mode((IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType)trans_mode);
</span></span><span style="display:flex;"><span>        msg3.set_offline_ready(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">&gt;::</span>const_iterator it <span style="color:#f92672">=</span> ip_addr_list<span style="color:#f92672">-&gt;</span>begin(); it <span style="color:#f92672">!=</span> ip_addr_list<span style="color:#f92672">-&gt;</span>end(); it<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr ip_addr_tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it;
</span></span><span style="display:flex;"><span>            IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">*</span> ip_addr <span style="color:#f92672">=</span> msg3.add_ip_addr_list();
</span></span><span style="display:flex;"><span>            ip_addr<span style="color:#f92672">-&gt;</span>set_ip(ip_addr_tmp.ip());
</span></span><span style="display:flex;"><span>            ip_addr<span style="color:#f92672">-&gt;</span>set_port(ip_addr_tmp.port());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        CImPdu pdu2;
</span></span><span style="display:flex;"><span>        pdu2.SetPBMsg(<span style="color:#f92672">&amp;</span>msg3);
</span></span><span style="display:flex;"><span>        pdu2.SetServiceId(SID_FILE);
</span></span><span style="display:flex;"><span>        pdu2.SetCommandId(CID_FILE_NOTIFY);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//send notify to target user
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        CImUser<span style="color:#f92672">*</span> pToUser <span style="color:#f92672">=</span> CImUserManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>GetImUserById(to_id);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pToUser)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            pToUser<span style="color:#f92672">-&gt;</span>BroadcastPduWithOutMobile(<span style="color:#f92672">&amp;</span>pdu2);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//send to route server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        CRouteServConn<span style="color:#f92672">*</span> pRouteConn <span style="color:#f92672">=</span> get_route_serv_conn();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pRouteConn) {
</span></span><span style="display:flex;"><span>            pRouteConn<span style="color:#f92672">-&gt;</span>SendPdu(<span style="color:#f92672">&amp;</span>pdu2);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>msg_server收到包后，首先装包数据，并把file_server的ip地址和端口信息带上，发给请求发文件的客户端，命令号是CID_FILE_RESPONSE；接着查询通知接收方有人给其发文件（通知方式也是一样，如果接收方在该msg_server上，直接发给该用户；不在的话，发给路由服务route_server）。当然接收到文件发送的端只有pc端，移动端会被过滤掉的，也就是说移动端不会收到发送文件的请求。</p>
<p>我们先看发送方pc客户端收到应答的逻辑（命令号是CID_FILE_RESPONSE）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferModule_Impl<span style="color:#f92672">::</span>onPacket(imcore<span style="color:#f92672">::</span>TTPBHeader<span style="color:#f92672">&amp;</span> header, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> pbBody)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (header.getCommandId())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FileCmdID<span style="color:#f92672">::</span>CID_FILE_RESPONSE:<span style="color:#75715e">//发送“文件请求/离线文件”-返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		_sendfileResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;	
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferModule_Impl<span style="color:#f92672">::</span>_sendfileResponse(IN std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> body)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileRsp imFileRsp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>imFileRsp.ParseFromString(body))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;parse failed,body:%s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(body));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	UInt32 nResult <span style="color:#f92672">=</span> imFileRsp.result_code();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nResult <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;_sendfileResponse result != 0&#34;</span>));
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>asynNotifyObserver(module<span style="color:#f92672">::</span>KEY_FILESEVER_UPLOAD_FAILED);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	TransferFileEntity fileEntity;
</span></span><span style="display:flex;"><span>	fileEntity.sTaskID <span style="color:#f92672">=</span> imFileRsp.task_id();
</span></span><span style="display:flex;"><span>    assert(<span style="color:#f92672">!</span>fileEntity.sTaskID.empty());
</span></span><span style="display:flex;"><span>	fileEntity.sFromID <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>uint32ToString(imFileRsp.from_user_id());
</span></span><span style="display:flex;"><span>	fileEntity.sToID <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>uint32ToString(imFileRsp.to_user_id());
</span></span><span style="display:flex;"><span>	fileEntity.sFileName <span style="color:#f92672">=</span> imFileRsp.file_name();
</span></span><span style="display:flex;"><span>	fileEntity.setSaveFilePath(util<span style="color:#f92672">::</span>stringToCString(fileEntity.sFileName));<span style="color:#75715e">//发送方文件地址，就是保存地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	fileEntity.time <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>UInt32<span style="color:#f92672">&gt;</span>(time(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> transMode <span style="color:#f92672">=</span> imFileRsp.trans_mode();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType<span style="color:#f92672">::</span>FILE_TYPE_ONLINE <span style="color:#f92672">==</span> transMode)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		fileEntity.nClientMode <span style="color:#f92672">=</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">::</span>CLIENT_REALTIME_SENDER;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType<span style="color:#f92672">::</span>FILE_TYPE_OFFLINE <span style="color:#f92672">==</span> transMode)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		fileEntity.nClientMode <span style="color:#f92672">=</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">::</span>CLIENT_OFFLINE_UPLOAD;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	fileEntity.pFileObject <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TransferFile(util<span style="color:#f92672">::</span>stringToCString(fileEntity.sFileName),FALSE);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (fileEntity.pFileObject)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		fileEntity.nFileSize <span style="color:#f92672">=</span> fileEntity.pFileObject<span style="color:#f92672">-&gt;</span>length();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	UINT32 nIPCount <span style="color:#f92672">=</span> imFileRsp.ip_addr_list_size();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nIPCount <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">&amp;</span> ipAdd <span style="color:#f92672">=</span> imFileRsp.ip_addr_list(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	fileEntity.sIP <span style="color:#f92672">=</span> ipAdd.ip();
</span></span><span style="display:flex;"><span>	fileEntity.nPort <span style="color:#f92672">=</span> ipAdd.port();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>pushTransferFileEntity(fileEntity))
</span></span><span style="display:flex;"><span>		TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>updateFileInfoBysTaskID(fileEntity);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LOG__(DEBG, _T(<span style="color:#e6db74">&#34;FileTransferSevice_Impl::准备连接文件服务器 sTaskId = %s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(fileEntity.sTaskID));
</span></span><span style="display:flex;"><span>	TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>openFileSocketByTaskId(fileEntity.sTaskID);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>客户端在TransferFileEntityManager::getInstance()-&gt;openFileSocketByTaskId(fileEntity.sTaskID);里面实际去连接file_server并尝试发文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TransferFileEntityManager<span style="color:#f92672">::</span>openFileSocketByTaskId(std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> taskId)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_fileUIThread<span style="color:#f92672">-&gt;</span>openFileSocketByTaskId(taskId);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferUIThread<span style="color:#f92672">::</span>openFileSocketByTaskId(std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> taskId)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	FileTransferSocket<span style="color:#f92672">*</span> pFileSocket <span style="color:#f92672">=</span> _findFileSocketByTaskId(taskId);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pFileSocket)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		pFileSocket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileTransferSocket(taskId);
</span></span><span style="display:flex;"><span>		m_lstFileTransSockets.push_back(pFileSocket);
</span></span><span style="display:flex;"><span>        assert(m_hWnd);
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">::</span>PostMessage(m_hWnd, WM_FILE_TRANSFER, <span style="color:#ae81ff">0</span>, (LPARAM)pFileSocket);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LRESULT _stdcall FileTransferUIThread<span style="color:#f92672">::</span>_WndProc(HWND hWnd, UINT message, WPARAM wparam, LPARAM lparam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (WM_FILE_TRANSFER <span style="color:#f92672">==</span> message)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		FileTransferSocket<span style="color:#f92672">*</span> pFileSocket <span style="color:#f92672">=</span> (FileTransferSocket<span style="color:#f92672">*</span>)lparam;
</span></span><span style="display:flex;"><span>		pFileSocket<span style="color:#f92672">-&gt;</span>startFileTransLink();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span>DefWindowProc(hWnd, message, wparam, lparam);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL FileTransferSocket<span style="color:#f92672">::</span>startFileTransLink()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	TransferFileEntity FileInfo;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>getFileInfoByTaskId(m_sTaskId, FileInfo))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//大佛：使用msg server 传过来的IP和端口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		LOG__(APP, _T(<span style="color:#e6db74">&#34;connect IP=%s,Port=%d&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(FileInfo.sIP), FileInfo.nPort);
</span></span><span style="display:flex;"><span>		connect(util<span style="color:#f92672">::</span>stringToCString(FileInfo.sIP), FileInfo.nPort);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//connect(util::stringToCString(module::FILETRANSFER_IP), module::FILETRANSFER_PORT);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	LOG__(ERR, _T(<span style="color:#e6db74">&#34;can&#39;t find the TaskId&#34;</span>));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意，这里只是去连接file_server服务器，连接成功的情况下，会尝试登录文件服务器，登录file_server的命令号是CID_FILE_LOGIN_REQ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferSocket<span style="color:#f92672">::</span>onConnectDone()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;FileTransferSocket::onConnected()&#34;</span>));
</span></span><span style="display:flex;"><span>	startHeartbeat();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	TransferFileEntity info;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>getFileInfoByTaskId(m_sTaskId, info))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        LOG__(APP, _T(<span style="color:#e6db74">&#34;Can&#39;t get the file info,task id:%s&#34;</span>),util<span style="color:#f92672">::</span>stringToCString(m_sTaskId));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//拉模式文件传输，传输taskid、token、client_mode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileLoginReq imFileLoginReq;
</span></span><span style="display:flex;"><span>	imFileLoginReq.set_user_id(module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>userId());
</span></span><span style="display:flex;"><span>	imFileLoginReq.set_task_id(info.sTaskID);
</span></span><span style="display:flex;"><span>	imFileLoginReq.set_file_role(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">&gt;</span>(info.nClientMode));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LOG__(APP, _T(<span style="color:#e6db74">&#34;IMFileLoginReq,sTaskID:%s,nClientMode:%d&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(info.sTaskID), info.nClientMode);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//send packet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LOG__(APP, _T(<span style="color:#e6db74">&#34;IMFileLoginReq,taskId:%s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(info.sTaskID));
</span></span><span style="display:flex;"><span>    sendPacket(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ServiceID<span style="color:#f92672">::</span>SID_FILE, IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FileCmdID<span style="color:#f92672">::</span>CID_FILE_LOGIN_REQ, <span style="color:#f92672">&amp;</span>imFileLoginReq);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//CImPduClientFileLoginReq pduFileLoginReq(module::getSysConfigModule()-&gt;userID().c_str()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	, &#34;&#34;, info.sTaskID.c_str(), );
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//sendPacket(&amp;pduFileLoginReq);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>file_server收到该数据包处理如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileClientConn<span style="color:#f92672">::</span>HandlePdu(CImPdu<span style="color:#f92672">*</span> pdu) {
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> CID_FILE_LOGIN_REQ:
</span></span><span style="display:flex;"><span>            _HandleClientFileLoginReq(pdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileClientConn<span style="color:#f92672">::</span>_HandleClientFileLoginReq(CImPdu<span style="color:#f92672">*</span> pdu) {
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileLoginReq login_req;
</span></span><span style="display:flex;"><span>    CHECK_PB_PARSE_MSG(login_req.ParseFromArray(pdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pdu<span style="color:#f92672">-&gt;</span>GetBodyLength()));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> user_id <span style="color:#f92672">=</span> login_req.user_id();
</span></span><span style="display:flex;"><span>    string task_id <span style="color:#f92672">=</span> login_req.task_id();
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole mode <span style="color:#f92672">=</span> login_req.file_role();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    log(<span style="color:#e6db74">&#34;Client login, user_id=%d, task_id=%s, file_role=%d&#34;</span>, user_id, task_id.c_str(), mode);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    BaseTransferTask<span style="color:#f92672">*</span> transfer_task <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> rv <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 查找任务是否存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        transfer_task <span style="color:#f92672">=</span> TransferTaskManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>FindByTaskID(task_id);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (transfer_task <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (mode <span style="color:#f92672">==</span> CLIENT_OFFLINE_DOWNLOAD) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 文件不存在，检查是否是离线下载，有可能是文件服务器重启
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 尝试从磁盘加载
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                transfer_task <span style="color:#f92672">=</span> TransferTaskManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>NewTransferTask(task_id, user_id);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 需要再次判断是否加载成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (transfer_task <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                    log(<span style="color:#e6db74">&#34;Find task id failed, user_id=%u, taks_id=%s, mode=%d&#34;</span>, user_id, task_id.c_str(), mode);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                log(<span style="color:#e6db74">&#34;Can&#39;t find task_id, user_id=%u, taks_id=%s, mode=%d&#34;</span>, user_id, task_id.c_str(), mode);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 状态转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        rv <span style="color:#f92672">=</span> transfer_task<span style="color:#f92672">-&gt;</span>ChangePullState(user_id, mode);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>rv) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// log();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        auth_ <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        transfer_task_ <span style="color:#f92672">=</span> transfer_task;
</span></span><span style="display:flex;"><span>        user_id_ <span style="color:#f92672">=</span> user_id;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 设置conn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        transfer_task<span style="color:#f92672">-&gt;</span>SetConnByUserID(user_id, <span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        rv <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileLoginRsp login_rsp;
</span></span><span style="display:flex;"><span>    login_rsp.set_result_code(rv<span style="color:#f92672">?</span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    login_rsp.set_task_id(task_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span>SendMessageLite(<span style="color:#66d9ef">this</span>, SID_FILE, CID_FILE_LOGIN_RES, pdu<span style="color:#f92672">-&gt;</span>GetSeqNum(), <span style="color:#f92672">&amp;</span>login_rsp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (rv) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (transfer_task<span style="color:#f92672">-&gt;</span>GetTransMode() <span style="color:#f92672">==</span> FILE_TYPE_ONLINE) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (transfer_task<span style="color:#f92672">-&gt;</span>state() <span style="color:#f92672">==</span> kTransferTaskStateWaitingTransfer) {
</span></span><span style="display:flex;"><span>                CImConn<span style="color:#f92672">*</span> conn <span style="color:#f92672">=</span> transfer_task_<span style="color:#f92672">-&gt;</span>GetToConn();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (conn) {
</span></span><span style="display:flex;"><span>                    _StatesNotify(CLIENT_FILE_PEER_READY, task_id, transfer_task_<span style="color:#f92672">-&gt;</span>from_user_id(), conn);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    log(<span style="color:#e6db74">&#34;to_conn is close, close me!!!&#34;</span>);
</span></span><span style="display:flex;"><span>                    Close();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// _StatesNotify(CLIENT_FILE_PEER_READY, task_id, user_id, this);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// transfer_task-&gt;StatesNotify(CLIENT_FILE_PEER_READY, task_id, user_id_);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (transfer_task<span style="color:#f92672">-&gt;</span>state() <span style="color:#f92672">==</span> kTransferTaskStateWaitingUpload) {
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                OfflineTransferTask<span style="color:#f92672">*</span> offline <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>OfflineTransferTask<span style="color:#f92672">*&gt;</span>(transfer_task);
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFilePullDataReq pull_data_req;
</span></span><span style="display:flex;"><span>                pull_data_req.set_task_id(task_id);
</span></span><span style="display:flex;"><span>                pull_data_req.set_user_id(user_id);
</span></span><span style="display:flex;"><span>                pull_data_req.set_trans_mode(FILE_TYPE_OFFLINE);
</span></span><span style="display:flex;"><span>                pull_data_req.set_offset(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                pull_data_req.set_data_size(offline<span style="color:#f92672">-&gt;</span>GetNextSegmentBlockSize());
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">::</span>SendMessageLite(<span style="color:#66d9ef">this</span>, SID_FILE, CID_FILE_PULL_DATA_REQ, <span style="color:#f92672">&amp;</span>pull_data_req);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                log(<span style="color:#e6db74">&#34;Pull Data Req&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>file_server应答客户端的命令号是CID_FILE_LOGIN_RES，客户端收到该包后处理如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferSocket<span style="color:#f92672">::</span>onReceiveData(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> data, <span style="color:#66d9ef">int32_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string pbBody;
</span></span><span style="display:flex;"><span>    imcore<span style="color:#f92672">::</span>TTPBHeader pbHeader; 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>        pbHeader.unSerialize((byte<span style="color:#f92672">*</span>)data, imcore<span style="color:#f92672">::</span>HEADER_LENGTH);
</span></span><span style="display:flex;"><span>        pbBody.assign(data <span style="color:#f92672">+</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH, size <span style="color:#f92672">-</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>OtherCmdID<span style="color:#f92672">::</span>CID_OTHER_HEARTBEAT <span style="color:#f92672">==</span> pbHeader.getCommandId()
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ServiceID<span style="color:#f92672">::</span>SID_OTHER <span style="color:#f92672">==</span> pbHeader.getModuleId())
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">catch</span> (CPduException e)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;onPacket CPduException serviceId:%d,commandId:%d,errCode:%d&#34;</span>)
</span></span><span style="display:flex;"><span>			, e.GetModuleId(), e.GetCommandId(), e.GetErrorCode());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">catch</span> (...)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;FileTransferSocket onPacket unknown exception&#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    UInt16 ncmdid <span style="color:#f92672">=</span> pbHeader.getCommandId();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (ncmdid)
</span></span><span style="display:flex;"><span>	{	 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FileCmdID<span style="color:#f92672">::</span>CID_FILE_LOGIN_RES:
</span></span><span style="display:flex;"><span>        _fileLoginResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//无关代码省略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferSocket<span style="color:#f92672">::</span>_fileLoginResponse(IN std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> body)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileLoginRsp imFileLoginRsp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>imFileLoginRsp.ParseFromString(body))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        LOG__(ERR, _T(<span style="color:#e6db74">&#34;parse failed,body:%s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(body));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (imFileLoginRsp.result_code() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;file server login failed! &#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//打开文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>string taskId <span style="color:#f92672">=</span> imFileLoginRsp.task_id();
</span></span><span style="display:flex;"><span>	TransferFileEntity fileEntity;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>getFileInfoByTaskId(taskId, fileEntity))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;file server login:can&#39;t find the fileInfo &#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;IMFileLoginRsp, file server login succeed&#34;</span>));
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//提示界面,界面上插入该项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">::</span>CLIENT_REALTIME_SENDER <span style="color:#f92672">==</span> fileEntity.nClientMode
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">||</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">::</span>CLIENT_OFFLINE_UPLOAD <span style="color:#f92672">==</span> fileEntity.nClientMode)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>asynNotifyObserver(module<span style="color:#f92672">::</span>KEY_FILETRANSFER_SENDFILE, fileEntity.sTaskID);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">::</span>CLIENT_REALTIME_RECVER <span style="color:#f92672">==</span> fileEntity.nClientMode
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">||</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">::</span>CLIENT_OFFLINE_DOWNLOAD <span style="color:#f92672">==</span> fileEntity.nClientMode)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>asynNotifyObserver(module<span style="color:#f92672">::</span>KEY_FILETRANSFER_REQUEST, fileEntity.sTaskID);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>至此，不管是离线文件还是在线文件发送，pc客户端会显示一个文件进度的对话框：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/15a704d9d8cdc2d43eba136257a92f90.jpg" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>对于在线文件，需要对端同意接收文件的传输，客户端才会读取文件，这个进度条才会发生变化。而对于离线文件，应该会立马读取文件上传文件数据到服务器。可是哪里会触发客户端读取文件并发送的逻辑呢？门道在于file_server在收到登录请求CID_FILE_LOGIN_REQ后，不仅会给客户端发送登录应答数据包CID_FILE_LOGIN_RES。还会根据文件的传输模式，如果是离线文件则会给客户端发送拉取文件的数据包CID_FILE_PULL_DATA_REQ，代码我们已经在上面的FileClientConn::_HandleClientFileLoginReq(CImPdu* pdu)中贴过了，我们再贴一次：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileClientConn<span style="color:#f92672">::</span>_HandleClientFileLoginReq(CImPdu<span style="color:#f92672">*</span> pdu) {
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileLoginReq login_req;
</span></span><span style="display:flex;"><span>    CHECK_PB_PARSE_MSG(login_req.ParseFromArray(pdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pdu<span style="color:#f92672">-&gt;</span>GetBodyLength()));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> user_id <span style="color:#f92672">=</span> login_req.user_id();
</span></span><span style="display:flex;"><span>    string task_id <span style="color:#f92672">=</span> login_req.task_id();
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole mode <span style="color:#f92672">=</span> login_req.file_role();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    log(<span style="color:#e6db74">&#34;Client login, user_id=%d, task_id=%s, file_role=%d&#34;</span>, user_id, task_id.c_str(), mode);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    BaseTransferTask<span style="color:#f92672">*</span> transfer_task <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> rv <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 查找任务是否存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        transfer_task <span style="color:#f92672">=</span> TransferTaskManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>FindByTaskID(task_id);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (transfer_task <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (mode <span style="color:#f92672">==</span> CLIENT_OFFLINE_DOWNLOAD) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 文件不存在，检查是否是离线下载，有可能是文件服务器重启
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 尝试从磁盘加载
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                transfer_task <span style="color:#f92672">=</span> TransferTaskManager<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>NewTransferTask(task_id, user_id);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 需要再次判断是否加载成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (transfer_task <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                    log(<span style="color:#e6db74">&#34;Find task id failed, user_id=%u, taks_id=%s, mode=%d&#34;</span>, user_id, task_id.c_str(), mode);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                log(<span style="color:#e6db74">&#34;Can&#39;t find task_id, user_id=%u, taks_id=%s, mode=%d&#34;</span>, user_id, task_id.c_str(), mode);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 状态转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        rv <span style="color:#f92672">=</span> transfer_task<span style="color:#f92672">-&gt;</span>ChangePullState(user_id, mode);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>rv) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// log();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        auth_ <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        transfer_task_ <span style="color:#f92672">=</span> transfer_task;
</span></span><span style="display:flex;"><span>        user_id_ <span style="color:#f92672">=</span> user_id;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 设置conn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        transfer_task<span style="color:#f92672">-&gt;</span>SetConnByUserID(user_id, <span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        rv <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileLoginRsp login_rsp;
</span></span><span style="display:flex;"><span>    login_rsp.set_result_code(rv<span style="color:#f92672">?</span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    login_rsp.set_task_id(task_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span>SendMessageLite(<span style="color:#66d9ef">this</span>, SID_FILE, CID_FILE_LOGIN_RES, pdu<span style="color:#f92672">-&gt;</span>GetSeqNum(), <span style="color:#f92672">&amp;</span>login_rsp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (rv) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (transfer_task<span style="color:#f92672">-&gt;</span>GetTransMode() <span style="color:#f92672">==</span> FILE_TYPE_ONLINE) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (transfer_task<span style="color:#f92672">-&gt;</span>state() <span style="color:#f92672">==</span> kTransferTaskStateWaitingTransfer) {
</span></span><span style="display:flex;"><span>                CImConn<span style="color:#f92672">*</span> conn <span style="color:#f92672">=</span> transfer_task_<span style="color:#f92672">-&gt;</span>GetToConn();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (conn) {
</span></span><span style="display:flex;"><span>                    _StatesNotify(CLIENT_FILE_PEER_READY, task_id, transfer_task_<span style="color:#f92672">-&gt;</span>from_user_id(), conn);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    log(<span style="color:#e6db74">&#34;to_conn is close, close me!!!&#34;</span>);
</span></span><span style="display:flex;"><span>                    Close();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// _StatesNotify(CLIENT_FILE_PEER_READY, task_id, user_id, this);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// transfer_task-&gt;StatesNotify(CLIENT_FILE_PEER_READY, task_id, user_id_);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (transfer_task<span style="color:#f92672">-&gt;</span>state() <span style="color:#f92672">==</span> kTransferTaskStateWaitingUpload) {
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                OfflineTransferTask<span style="color:#f92672">*</span> offline <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>OfflineTransferTask<span style="color:#f92672">*&gt;</span>(transfer_task);
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFilePullDataReq pull_data_req;
</span></span><span style="display:flex;"><span>                pull_data_req.set_task_id(task_id);
</span></span><span style="display:flex;"><span>                pull_data_req.set_user_id(user_id);
</span></span><span style="display:flex;"><span>                pull_data_req.set_trans_mode(FILE_TYPE_OFFLINE);
</span></span><span style="display:flex;"><span>                pull_data_req.set_offset(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                pull_data_req.set_data_size(offline<span style="color:#f92672">-&gt;</span>GetNextSegmentBlockSize());
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">::</span>SendMessageLite(<span style="color:#66d9ef">this</span>, SID_FILE, CID_FILE_PULL_DATA_REQ, <span style="color:#f92672">&amp;</span>pull_data_req);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                log(<span style="color:#e6db74">&#34;Pull Data Req&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>pc端收到CID_FILE_PULL_DATA_REQ后，表示这是一个离线文件，就可以直接上传文件数据了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FileCmdID<span style="color:#f92672">::</span>CID_FILE_PULL_DATA_REQ:<span style="color:#75715e">//发文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        _filePullDataReqResponse(pbBody);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferSocket<span style="color:#f92672">::</span>_filePullDataReqResponse(IN std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> body)<span style="color:#75715e">//发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>	IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFilePullDataReq imFilePullDataReq;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>imFilePullDataReq.ParseFromString(body))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        LOG__(ERR, _T(<span style="color:#e6db74">&#34;parse failed,body:%s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(body));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	UInt32 fileSize <span style="color:#f92672">=</span> imFilePullDataReq.data_size();
</span></span><span style="display:flex;"><span>	UInt32 fileOffset <span style="color:#f92672">=</span> imFilePullDataReq.offset();
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string taskId <span style="color:#f92672">=</span> imFilePullDataReq.task_id();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	TransferFileEntity fileEntity;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>getFileInfoByTaskId(taskId, fileEntity))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;PullDataReqResponse: can&#39;t find the fileInfo&#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	LOG__(DEBG, _T(<span style="color:#e6db74">&#34;send:taskId=%s,filesize=%d,name=%s,BolckSize=%d&#34;</span>)
</span></span><span style="display:flex;"><span>		,util<span style="color:#f92672">::</span>stringToCString(fileEntity.sTaskID)
</span></span><span style="display:flex;"><span>		,fileEntity.nFileSize
</span></span><span style="display:flex;"><span>		,fileEntity.getRealFileName()
</span></span><span style="display:flex;"><span>        ,fileSize);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string buff;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> fileEntity.pFileObject)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;PullDataReqResponse: file boject Destoryed!&#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	fileEntity.pFileObject<span style="color:#f92672">-&gt;</span>readBlock(fileOffset, fileSize, buff);<span style="color:#75715e">//读取本地文件的数据块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFilePullDataRsp imFilePullDataRsp;<span style="color:#75715e">//todo check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    imFilePullDataRsp.set_result_code(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	imFilePullDataRsp.set_task_id(taskId);
</span></span><span style="display:flex;"><span>	imFilePullDataRsp.set_user_id(util<span style="color:#f92672">::</span>stringToInt32(fileEntity.sFromID));
</span></span><span style="display:flex;"><span>	imFilePullDataRsp.set_offset(fileOffset);
</span></span><span style="display:flex;"><span>    imFilePullDataRsp.set_file_data((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)buff.data(), fileSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//send packet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sendPacket(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ServiceID<span style="color:#f92672">::</span>SID_FILE, IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FileCmdID<span style="color:#f92672">::</span>CID_FILE_PULL_DATA_RSP
</span></span><span style="display:flex;"><span>        , <span style="color:#f92672">&amp;</span>imFilePullDataRsp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fileEntity.nProgress <span style="color:#f92672">=</span> fileOffset <span style="color:#f92672">+</span> fileSize;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (fileEntity.nProgress <span style="color:#f92672">&lt;</span> fileEntity.nFileSize)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//更新进度条
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>updateFileInfoBysTaskID(fileEntity);<span style="color:#75715e">//保存当前进度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>asynNotifyObserver(module<span style="color:#f92672">::</span>KEY_FILESEVER_UPDATA_PROGRESSBAR
</span></span><span style="display:flex;"><span>            , fileEntity.sTaskID);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span><span style="color:#75715e">//传输完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fileEntity.pFileObject)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">delete</span> fileEntity.pFileObject;
</span></span><span style="display:flex;"><span>			fileEntity.pFileObject <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>asynNotifyObserver(module<span style="color:#f92672">::</span>KEY_FILESEVER_PROGRESSBAR_FINISHED
</span></span><span style="display:flex;"><span>            , fileEntity.sTaskID);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>updateFileInfoBysTaskID(fileEntity);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当然，如果文件比较大，一次发不完也没关系，在CID_FILE_PULL_DATA_REQ中有当前文件的偏移量，客户端在读取文件和应答服务器时也带上这个偏移量fileOffset，应答给服务器的包是CID_FILE_PULL_DATA_RSP。file_server收到应答后处理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileClientConn<span style="color:#f92672">::</span>HandlePdu(CImPdu<span style="color:#f92672">*</span> pdu) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> CID_FILE_PULL_DATA_RSP:
</span></span><span style="display:flex;"><span>            _HandleClientFilePullFileRsp( pdu);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span> ;
</span></span><span style="display:flex;"><span>			    ...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//省略无关代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileClientConn<span style="color:#f92672">::</span>_HandleClientFilePullFileRsp(CImPdu <span style="color:#f92672">*</span>pdu) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>auth_ <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>transfer_task_) {
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;auth is false&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只有rsp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFilePullDataRsp pull_data_rsp;
</span></span><span style="display:flex;"><span>    CHECK_PB_PARSE_MSG(pull_data_rsp.ParseFromArray(pdu<span style="color:#f92672">-&gt;</span>GetBodyData(), pdu<span style="color:#f92672">-&gt;</span>GetBodyLength()));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> user_id <span style="color:#f92672">=</span> pull_data_rsp.user_id();
</span></span><span style="display:flex;"><span>    string task_id <span style="color:#f92672">=</span> pull_data_rsp.task_id();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> offset <span style="color:#f92672">=</span> pull_data_rsp.offset();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> data_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;</span>(pull_data_rsp.file_data().length());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> data <span style="color:#f92672">=</span> pull_data_rsp.file_data().data();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// log(&#34;Recv FilePullFileRsp, user_id=%d, task_id=%s, file_role=%d, offset=%d, datasize=%d&#34;, user_id, task_id.c_str(), mode, offset, datasize);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    log(<span style="color:#e6db74">&#34;Recv FilePullFileRsp, task_id=%s, user_id=%u, offset=%u, data_size=%d&#34;</span>, task_id.c_str(), user_id, offset, data_size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rv <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 检查user_id
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (user_id <span style="color:#f92672">!=</span> user_id_) {
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;Received user_id valid, recv_user_id = %d, transfer_task.user_id = %d, user_id_ = %d&#34;</span>, user_id, transfer_task_<span style="color:#f92672">-&gt;</span>from_user_id(), user_id_);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查task_id
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (transfer_task_<span style="color:#f92672">-&gt;</span>task_id() <span style="color:#f92672">!=</span> task_id) {
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;Received task_id valid, recv_task_id = %s, this_task_id = %s&#34;</span>, task_id.c_str(), transfer_task_<span style="color:#f92672">-&gt;</span>task_id().c_str());
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Close();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        rv <span style="color:#f92672">=</span> transfer_task_<span style="color:#f92672">-&gt;</span>DoRecvData(user_id, offset, data, data_size);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (rv <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (transfer_task_<span style="color:#f92672">-&gt;</span>GetTransMode() <span style="color:#f92672">==</span> FILE_TYPE_ONLINE) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 对于在线，直接转发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            OnlineTransferTask<span style="color:#f92672">*</span> online <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>OnlineTransferTask<span style="color:#f92672">*&gt;</span>(transfer_task_);
</span></span><span style="display:flex;"><span>            pdu<span style="color:#f92672">-&gt;</span>SetSeqNum(online<span style="color:#f92672">-&gt;</span>GetSeqNum());
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// online-&gt;SetSeqNum(pdu-&gt;GetSeqNum());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            CImConn<span style="color:#f92672">*</span> conn <span style="color:#f92672">=</span> transfer_task_<span style="color:#f92672">-&gt;</span>GetToConn();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (conn) {
</span></span><span style="display:flex;"><span>                conn<span style="color:#f92672">-&gt;</span>SendPdu(pdu);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 离线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// all packages recved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (rv <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                _StatesNotify(CLIENT_FILE_DONE, task_id, user_id, <span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Close();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                OfflineTransferTask<span style="color:#f92672">*</span> offline <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>OfflineTransferTask<span style="color:#f92672">*&gt;</span>(transfer_task_);
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFilePullDataReq pull_data_req;
</span></span><span style="display:flex;"><span>                pull_data_req.set_task_id(task_id);
</span></span><span style="display:flex;"><span>                pull_data_req.set_user_id(user_id);
</span></span><span style="display:flex;"><span>                pull_data_req.set_trans_mode(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType<span style="color:#f92672">&gt;</span>(offline<span style="color:#f92672">-&gt;</span>GetTransMode()));
</span></span><span style="display:flex;"><span>                pull_data_req.set_offset(offline<span style="color:#f92672">-&gt;</span>GetNextOffset());
</span></span><span style="display:flex;"><span>                pull_data_req.set_data_size(offline<span style="color:#f92672">-&gt;</span>GetNextSegmentBlockSize());
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">::</span>SendMessageLite(<span style="color:#66d9ef">this</span>, SID_FILE, CID_FILE_PULL_DATA_REQ, <span style="color:#f92672">&amp;</span>pull_data_req);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// log(&#34;size not match&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (rv<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// -1，出错关闭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//  1, 离线上传完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果是在线文件，就直接转发含有文件数据的包；如果是离线文件，则存入文件服务上，即写入文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> OfflineTransferTask<span style="color:#f92672">::</span>DoRecvData(<span style="color:#66d9ef">uint32_t</span> user_id, <span style="color:#66d9ef">uint32_t</span> offset, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> data, <span style="color:#66d9ef">uint32_t</span> data_size) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 离线文件上传
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rv <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查是否发送者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CheckFromUserID(user_id)) {
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;rsp user_id=%d, but sender_id is %d&#34;</span>, user_id, from_user_id_);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (state_ <span style="color:#f92672">!=</span> kTransferTaskStateWaitingUpload <span style="color:#f92672">&amp;&amp;</span> state_ <span style="color:#f92672">!=</span> kTransferTaskStateUploading) {
</span></span><span style="display:flex;"><span>            log(<span style="color:#e6db74">&#34;state=%d error, need kTransferTaskStateWaitingUpload or kTransferTaskStateUploading&#34;</span>, state_);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查offset是否有效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (offset <span style="color:#f92672">!=</span> transfered_idx_<span style="color:#f92672">*</span>SEGMENT_SIZE) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//if (data_size != GetNextSegmentBlockSize()) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//    break;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// todo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 检查文件大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        data_size <span style="color:#f92672">=</span> GetNextSegmentBlockSize();
</span></span><span style="display:flex;"><span>        log(<span style="color:#e6db74">&#34;Ready recv data, offset=%d, data_size=%d, segment_size=%d&#34;</span>, offset, data_size, sengment_size_);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (state_ <span style="color:#f92672">==</span> kTransferTaskStateWaitingUpload) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (fp_ <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                fp_ <span style="color:#f92672">=</span> OpenByWrite(task_id_, to_user_id_);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (fp_ <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 写文件头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            OfflineFileHeader file_header;
</span></span><span style="display:flex;"><span>            memset(<span style="color:#f92672">&amp;</span>file_header, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(file_header));
</span></span><span style="display:flex;"><span>            file_header.set_create_time(time(NULL));
</span></span><span style="display:flex;"><span>            file_header.set_task_id(task_id_);
</span></span><span style="display:flex;"><span>            file_header.set_from_user_id(from_user_id_);
</span></span><span style="display:flex;"><span>            file_header.set_to_user_id(to_user_id_);
</span></span><span style="display:flex;"><span>            file_header.set_file_name(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>            file_header.set_file_size(file_size_);
</span></span><span style="display:flex;"><span>            fwrite(<span style="color:#f92672">&amp;</span>file_header, <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span>(file_header), fp_);
</span></span><span style="display:flex;"><span>            fflush(fp_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            state_ <span style="color:#f92672">=</span> kTransferTaskStateUploading;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 存储
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (fp_ <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        fwrite(data, <span style="color:#ae81ff">1</span>, data_size, fp_);
</span></span><span style="display:flex;"><span>        fflush(fp_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>transfered_idx_;
</span></span><span style="display:flex;"><span>        SetLastUpdateTime();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (transfered_idx_ <span style="color:#f92672">==</span> sengment_size_) {
</span></span><span style="display:flex;"><span>            state_ <span style="color:#f92672">=</span> kTransferTaskStateUploadEnd;
</span></span><span style="display:flex;"><span>            fclose(fp_);
</span></span><span style="display:flex;"><span>            fp_ <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>            rv <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            rv <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> rv;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如此循环，直至文件传输完成。当然文件上传完成后file_server也会断开与客户端的连接。</p>
<p>到这里我们介绍了发送文件方的逻辑，下面我们看看接收方的逻辑，上文中介绍了接收方会收到接收文件的通知CID_FILE_NOTIFY，客户端处理这个命令号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FileCmdID<span style="color:#f92672">::</span>CID_FILE_NOTIFY:<span style="color:#75715e">//收到“发送文件请求”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	_fileNotify(pbBody);	_fileNotify(pbBody);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferModule_Impl<span style="color:#f92672">::</span>_fileNotify(IN std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> body)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileNotify imFileNotify;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>imFileNotify.ParseFromString(body))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;parse failed,body:%s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(body));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	TransferFileEntity file;
</span></span><span style="display:flex;"><span>	file.sFileName <span style="color:#f92672">=</span> imFileNotify.file_name();
</span></span><span style="display:flex;"><span>	file.sFromID <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>uint32ToString(imFileNotify.from_user_id());
</span></span><span style="display:flex;"><span>	file.sToID <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>uint32ToString(imFileNotify.to_user_id());
</span></span><span style="display:flex;"><span>	file.sTaskID <span style="color:#f92672">=</span> imFileNotify.task_id();
</span></span><span style="display:flex;"><span>	file.nFileSize <span style="color:#f92672">=</span> imFileNotify.file_size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	UINT32 nIPCount <span style="color:#f92672">=</span> imFileNotify.ip_addr_list_size();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nIPCount <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>IpAddr<span style="color:#f92672">&amp;</span> ipAdd <span style="color:#f92672">=</span> imFileNotify.ip_addr_list(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	file.sIP <span style="color:#f92672">=</span> ipAdd.ip();
</span></span><span style="display:flex;"><span>	file.nPort <span style="color:#f92672">=</span> ipAdd.port();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> transMode <span style="color:#f92672">=</span> imFileNotify.trans_mode();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType<span style="color:#f92672">::</span>FILE_TYPE_ONLINE <span style="color:#f92672">==</span> transMode)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		file.nClientMode <span style="color:#f92672">=</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">::</span>CLIENT_REALTIME_RECVER;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>TransferFileType<span style="color:#f92672">::</span>FILE_TYPE_OFFLINE <span style="color:#f92672">==</span> transMode)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		file.nClientMode <span style="color:#f92672">=</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileRole<span style="color:#f92672">::</span>CLIENT_OFFLINE_DOWNLOAD;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	file.time <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>UInt32<span style="color:#f92672">&gt;</span>(time(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>	TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>pushTransferFileEntity(file);
</span></span><span style="display:flex;"><span>	LOG__(DEBG, _T(<span style="color:#e6db74">&#34;FileTransferSevice_Impl::给你发文件 sFileID = %s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(file.sTaskID));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> imFileNotify.offline_ready())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//TODO离线文件传输结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//连接服务器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>openFileSocketByTaskId(file.sTaskID);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其实也就是接收方会去连接文件服务器。连接成功以后，在对应的回调函数里面触发显示接收文件对话框。但是此时实际上还不能接收文件，因为发送方可能还没准备好。发送方要准备啥呢？前面我们已经介绍了，我们梳理一下上述流程：</p>
<ol>
<li>
<p>发送方先向msg_server请求发送文件，msg_server转发给file_server；</p>
</li>
<li>
<p>file_server应答msg_server并告诉msg_server自己的地址和端口号；</p>
</li>
<li>
<p>msg_server收到file_server的应答后，先回复发送方，再转发给接收方；</p>
</li>
<li>
<p>发送方接着发送登录请求给file_server，file_server收到请求决定是否给发送方发送拉取文件的数据包。如果是离线文件，则会立刻给发送方发送拉取文件的数据包；如果是在线文件，则需要等待接收方同意接收。</p>
</li>
</ol>
<p>所以，必须过了步骤4，一直到file_server应答了发送方的登录文件服务器请求后，发送方才算准备好。此时，file_server知道发送方已经准备好了，给接收方发送数据包CID_FILE_STATE。接收方收到这个命令号后：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>FileCmdID<span style="color:#f92672">::</span>CID_FILE_STATE:<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        _fileState(pbBody);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> FileTransferSocket<span style="color:#f92672">::</span>_fileState(IN std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> body)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	IM<span style="color:#f92672">::</span>File<span style="color:#f92672">::</span>IMFileState imFileState;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>imFileState.ParseFromString(body))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        LOG__(ERR, _T(<span style="color:#e6db74">&#34;parse failed,body:%s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(body));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	UINT32 nfileState <span style="color:#f92672">=</span> imFileState.state();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string taskId <span style="color:#f92672">=</span> imFileState.task_id();
</span></span><span style="display:flex;"><span>	TransferFileEntity fileEntity;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>getFileInfoByTaskId(taskId, fileEntity))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;fileState:can&#39;t find the fileInfo &#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (nfileState)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileState<span style="color:#f92672">::</span>CLIENT_FILE_PEER_READY:
</span></span><span style="display:flex;"><span>		LOG__(APP, _T(<span style="color:#e6db74">&#34;fileState--CLIENT_FILE_PEER_READY &#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileState<span style="color:#f92672">::</span>CLIENT_FILE_CANCEL :<span style="color:#75715e">//取消的了文件传输
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		LOG__(APP, _T(<span style="color:#e6db74">&#34;fileState--CLIENT_FILE_CANCEL &#34;</span>));
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (fileEntity.pFileObject)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">delete</span> fileEntity.pFileObject;
</span></span><span style="display:flex;"><span>                fileEntity.pFileObject <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>			TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>updateFileInfoBysTaskID(fileEntity);
</span></span><span style="display:flex;"><span>			module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>asynNotifyObserver(module<span style="color:#f92672">::</span>KEY_FILESEVER_UPLOAD_CANCEL, fileEntity.sTaskID);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileState<span style="color:#f92672">::</span>CLIENT_FILE_REFUSE:<span style="color:#75715e">//拒绝了文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		LOG__(APP, _T(<span style="color:#e6db74">&#34;fileState--CLIENT_FILE_REFUSE &#34;</span>));
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (fileEntity.pFileObject)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">delete</span> fileEntity.pFileObject;
</span></span><span style="display:flex;"><span>                fileEntity.pFileObject <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>			TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>updateFileInfoBysTaskID(fileEntity);
</span></span><span style="display:flex;"><span>			module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>asynNotifyObserver(module<span style="color:#f92672">::</span>KEY_FILESEVER_UPLOAD_REJECT, fileEntity.sTaskID);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>ClientFileState<span style="color:#f92672">::</span>CLIENT_FILE_DONE:
</span></span><span style="display:flex;"><span>		LOG__(APP, _T(<span style="color:#e6db74">&#34;fileState--CLIENT_FILE_DONE &#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fileEntity.pFileObject)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">delete</span> fileEntity.pFileObject;
</span></span><span style="display:flex;"><span>			fileEntity.pFileObject <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		TransferFileEntityManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>updateFileInfoBysTaskID(fileEntity);
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>getFileTransferModule()<span style="color:#f92672">-&gt;</span>asynNotifyObserver(module<span style="color:#f92672">::</span>KEY_FILESEVER_PROGRESSBAR_FINISHED, fileEntity.sTaskID);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同理，对于接收方，选择接收还是拒绝文件的逻辑也是在这里一起处理的，与此类似，这里就不再重复叙述了。</p>
<p>接收方下载文件的逻辑和发送方上传文件的逻辑类似。这里也不在描述了。</p>
<p>最后说一点我的建议，teamtalk的file_server逻辑、以及与客户端还有msg_server的逻辑流程加上各种细节写的比较的细腻，代码实现上也比较好。强烈建议好好地阅读这部分的代码。毕竟很多人在自己实现一个文件服务器时，还是存在不少问题的。</p>
<p>​</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/0055f7fa607b4b2180cd0eb3924eff5c/">
    <span class="title">« Prev</span>
    <br>
    <span>07 服务器端msfs源码分析</span>
  </a>
  <a class="next" href="https://haokiu.com/d337b00514f346dcb055e1a411da83d8/">
    <span class="title">Next »</span>
    <br>
    <span>09 服务器端route_server源码分析</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
