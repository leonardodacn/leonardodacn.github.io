<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>4 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/categories/4/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://haokiu.com/categories/4/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="4" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://haokiu.com/categories/4/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="4"/>
<meta name="twitter:description" content=""/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/categories/">Categories</a></div>
  <h1>
    4
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX ODPSReader
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX ODPSReader 1 快速介绍 ODPSReader 实现了从 ODPS读取数据的功能，有关ODPS请参看(https://help.aliyun.com/document_detail/27800.html?spm=5176.doc27803.6.101.NxCIgY)。 在底层实现上，ODPSReader 根据你配置的 源头项目 / 表 / 分区 / 表字段 等信息，通过 Tunnel 从 ODPS 系统中读取数据。
注意 1、如果你需要使用ODPSReader/Writer插件，由于 AccessId/AccessKey 解密的需要，请务必使用 JDK 1.6.32 及以上版本。JDK 安装事项，请联系 PE 处理 2、ODPSReader 不是通过 ODPS SQL （select ... from ... where ... ）来抽取数据的 3、注意区分你要读取的表是线上环境还是线下环境 4、目前 DataX3 依赖的 SDK 版本是： &lt;dependency&gt; &lt;groupId&gt;com.aliyun.odps&lt;/groupId&gt; &lt;artifactId&gt;odps-sdk-core-internal&lt;/artifactId&gt; &lt;version&gt;0.13.2&lt;/version&gt; &lt;/dependency&gt; 2 实现原理 ODPSReader 支持读取分区表、非分区表，不支持读取虚拟视图。当要读取分区表时，需要指定出具体的分区配置，比如读取 t0 表，其分区为 pt=1,ds=hangzhou 那么你需要在配置中配置该值。当要读取非分区表时，你不能提供分区配置。表字段可以依序指定全部列，也可以指定部分列，或者调整列顺序，或者指定常量字段，但是表字段中不能指定分区列（分区列不是表字段）。
注意：要特别注意 odpsServer、project、table、accessId、accessKey 的配置，因为直接影响到是否能够加载到你需要读取数据的表。很多权限问题都出现在这里。 3 功能说明 3.1 配置样例 这里使用一份读出 ODPS 数据然后打印到屏幕的配置样板。 { &#34;job&#34;: { &#34;setting&#34;: { &#34;speed&#34;: { &#34;channel&#34;: 1 } }, &#34;content&#34;: [ { &#34;reader&#34;: { &#34;name&#34;: &#34;odpsreader&#34;, &#34;parameter&#34;: { &#34;accessId&#34;: &#34;accessId&#34;, &#34;accessKey&#34;: &#34;accessKey&#34;, &#34;project&#34;: &#34;targetProjectName&#34;, &#34;table&#34;: &#34;tableName&#34;, &#34;partition&#34;: [ &#34;pt=1,ds=hangzhou&#34; ], &#34;column&#34;: [ &#34;customer_id&#34;, &#34;nickname&#34; ], &#34;packageAuthorizedProject&#34;: &#34;yourCurrentProjectName&#34;, &#34;splitMode&#34;: &#34;record&#34;, &#34;odpsServer&#34;: &#34;http://xxx/api&#34;, &#34;tunnelServer&#34;: &#34;http://dt....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX ODPSReader" href="https://haokiu.com/blog/5b1b6009df684895ab2ef943e412ee8a/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX ODPS写入
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX ODPS写入 1 快速介绍 ODPSWriter插件用于实现往ODPS插入或者更新数据，主要提供给etl开发同学将业务数据导入odps，适合于TB,GB数量级的数据传输，如果需要传输PB量级的数据，请选择dt task工具 ;
2 实现原理 在底层实现上，ODPSWriter是通过DT Tunnel写入ODPS系统的，有关ODPS的更多技术细节请参看 ODPS主站 https://data.aliyun.com/product/odps 和ODPS产品文档 https://help.aliyun.com/product/27797.html
目前 DataX3 依赖的 SDK 版本是：
&lt;dependency&gt; &lt;groupId&gt;com.aliyun.odps&lt;/groupId&gt; &lt;artifactId&gt;odps-sdk-core-internal&lt;/artifactId&gt; &lt;version&gt;0.13.2&lt;/version&gt; &lt;/dependency&gt; 注意: 如果你需要使用ODPSReader/Writer插件，请务必使用JDK 1.6-32及以上版本 使用java -version查看Java版本号
3 功能说明 3.1 配置样例 这里使用一份从内存产生到ODPS导入的数据。 { &#34;job&#34;: { &#34;setting&#34;: { &#34;speed&#34;: { &#34;byte&#34;: 1048576 } }, &#34;content&#34;: [ { &#34;reader&#34;: { &#34;name&#34;: &#34;streamreader&#34;, &#34;parameter&#34;: { &#34;column&#34;: [ { &#34;value&#34;: &#34;DataX&#34;, &#34;type&#34;: &#34;string&#34; }, { &#34;value&#34;: &#34;test&#34;, &#34;type&#34;: &#34;bytes&#34; } ], &#34;sliceRecordCount&#34;: 100000 } }, &#34;writer&#34;: { &#34;name&#34;: &#34;odpswriter&#34;, &#34;parameter&#34;: { &#34;project&#34;: &#34;chinan_test&#34;, &#34;table&#34;: &#34;odps_write_test00_partitioned&#34;, &#34;partition&#34;: &#34;school=SiChuan-School,class=1&#34;, &#34;column&#34;: [ &#34;id&#34;, &#34;name&#34; ], &#34;accessId&#34;: &#34;xxx&#34;, &#34;accessKey&#34;: &#34;xxxx&#34;, &#34;truncate&#34;: true, &#34;odpsServer&#34;: &#34;http://sxxx/api&#34;, &#34;tunnelServer&#34;: &#34;http://xxx&#34;, &#34;accountType&#34;: &#34;aliyun&#34; } } } ] } } 3....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX ODPS写入" href="https://haokiu.com/blog/ab33f89c494e47eaae02f9c21465b322/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX OracleWriter
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX OracleWriter 1 快速介绍 OracleWriter 插件实现了写入数据到 Oracle 主库的目的表的功能。在底层实现上， OracleWriter 通过 JDBC 连接远程 Oracle 数据库，并执行相应的 insert into … sql 语句将数据写入 Oracle，内部会分批次提交入库。
OracleWriter 面向ETL开发工程师，他们使用 OracleWriter 从数仓导入数据到 Oracle。同时 OracleWriter 亦可以作为数据迁移工具为DBA等用户提供服务。
2 实现原理 OracleWriter 通过 DataX 框架获取 Reader 生成的协议数据，根据你配置生成相应的SQL语句
insert into...(当主键/唯一性索引冲突时会写不进去冲突的行) 注意： 1. 目的表所在数据库必须是主库才能写入数据；整个任务至少需具备 insert into...的权限，是否需要其他权限，取决于你任务配置中在 preSql 和 postSql 中指定的语句。 2.OracleWriter和MysqlWriter不同，不支持配置writeMode参数。 3 功能说明 3.1 配置样例 这里使用一份从内存产生到 Oracle 导入的数据。 { &#34;job&#34;: { &#34;setting&#34;: { &#34;speed&#34;: { &#34;channel&#34;: 1 } }, &#34;content&#34;: [ { &#34;reader&#34;: { &#34;name&#34;: &#34;streamreader&#34;, &#34;parameter&#34;: { &#34;column&#34; : [ { &#34;value&#34;: &#34;DataX&#34;, &#34;type&#34;: &#34;string&#34; }, { &#34;value&#34;: 19880808, &#34;type&#34;: &#34;long&#34; }, { &#34;value&#34;: &#34;1988-08-08 08:08:08&#34;, &#34;type&#34;: &#34;date&#34; }, { &#34;value&#34;: true, &#34;type&#34;: &#34;bool&#34; }, { &#34;value&#34;: &#34;test&#34;, &#34;type&#34;: &#34;bytes&#34; } ], &#34;sliceRecordCount&#34;: 1000 } }, &#34;writer&#34;: { &#34;name&#34;: &#34;oraclewriter&#34;, &#34;parameter&#34;: { &#34;username&#34;: &#34;root&#34;, &#34;password&#34;: &#34;root&#34;, &#34;column&#34;: [ &#34;id&#34;, &#34;name&#34; ], &#34;preSql&#34;: [ &#34;delete from test&#34; ], &#34;connection&#34;: [ { &#34;jdbcUrl&#34;: &#34;jdbc:oracle:thin:@[HOST_NAME]:PORT:[DATABASE_NAME]&#34;, &#34;table&#34;: [ &#34;test&#34; ] } ] } } } ] } } 3....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX OracleWriter" href="https://haokiu.com/blog/1eb2fdd8968d4f6e8bbc0312c6647246/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX OSSReader 说明
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX OSSReader 说明 1 快速介绍 OSSReader提供了读取OSS数据存储的能力。在底层实现上，OSSReader使用OSS官方Java SDK获取OSS数据，并转换为DataX传输协议传递给Writer。
OSS 产品介绍, 参看[阿里云OSS Portal] OSS Java SDK, 参看[阿里云OSS Java SDK] 2 功能与限制 OSSReader实现了从OSS读取数据并转为DataX协议的功能，OSS本身是无结构化数据存储，对于DataX而言，OSSReader实现上类比TxtFileReader，有诸多相似之处。目前OSSReader支持功能如下：
支持且仅支持读取TXT的文件，且要求TXT中shema为一张二维表。
支持类CSV格式文件，自定义分隔符。
支持多种类型数据读取(使用String表示)，支持列裁剪，支持列常量
支持递归读取、支持文件名过滤。
支持文本压缩，现有压缩格式为zip、gzip、bzip2。注意，一个压缩包不允许多文件打包压缩。
多个object可以支持并发读取。
我们暂时不能做到：
单个Object(File)支持多线程并发读取，这里涉及到单个Object内部切分算法。二期考虑支持。
单个Object在压缩情况下，从技术上无法支持多线程并发读取。
3 功能说明 3.1 配置样例 { &#34;job&#34;: { &#34;setting&#34;: {}, &#34;content&#34;: [ { &#34;reader&#34;: { &#34;name&#34;: &#34;ossreader&#34;, &#34;parameter&#34;: { &#34;endpoint&#34;: &#34;http://oss.aliyuncs.com&#34;, &#34;accessId&#34;: &#34;&#34;, &#34;accessKey&#34;: &#34;&#34;, &#34;bucket&#34;: &#34;myBucket&#34;, &#34;object&#34;: [ &#34;bazhen/*&#34; ], &#34;column&#34;: [ { &#34;type&#34;: &#34;long&#34;, &#34;index&#34;: 0 }, { &#34;type&#34;: &#34;string&#34;, &#34;value&#34;: &#34;alibaba&#34; }, { &#34;type&#34;: &#34;date&#34;, &#34;index&#34;: 1, &#34;format&#34;: &#34;yyyy-MM-dd&#34; } ], &#34;encoding&#34;: &#34;UTF-8&#34;, &#34;fieldDelimiter&#34;: &#34;\t&#34;, &#34;compress&#34;: &#34;gzip&#34; } }, &#34;writer&#34;: {} } ] } } 3.2 参数说明 endpoint
描述：OSS Server的EndPoint地址，例如http://oss....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX OSSReader 说明" href="https://haokiu.com/blog/bf15e9112ab546c9a6d8baab000d9601/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX OSSWriter 说明
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX OSSWriter 说明 1 快速介绍 OSSWriter提供了向OSS写入类CSV格式的一个或者多个表文件。
写入OSS内容存放的是一张逻辑意义上的二维表，例如CSV格式的文本信息。
OSS 产品介绍, 参看[阿里云OSS Portal] OSS Java SDK, 参看[阿里云OSS Java SDK] 2 功能与限制 OSSWriter实现了从DataX协议转为OSS中的TXT文件功能，OSS本身是无结构化数据存储，OSSWriter需要在如下几个方面增加:
支持且仅支持写入 TXT的文件，且要求TXT中shema为一张二维表。
支持类CSV格式文件，自定义分隔符。
暂时不支持文本压缩。
支持多线程写入，每个线程写入不同子文件。
文件支持滚动，当文件大于某个size值或者行数值，文件需要切换。 [暂不支持]
我们不能做到：
单个文件不能支持并发写入。 3 功能说明 3.1 配置样例 { &#34;job&#34;: { &#34;setting&#34;: {}, &#34;content&#34;: [ { &#34;reader&#34;: { }, &#34;writer&#34;: { &#34;name&#34;: &#34;osswriter&#34;, &#34;parameter&#34;: { &#34;endpoint&#34;: &#34;http://oss.aliyuncs.com&#34;, &#34;accessId&#34;: &#34;&#34;, &#34;accessKey&#34;: &#34;&#34;, &#34;bucket&#34;: &#34;myBucket&#34;, &#34;object&#34;: &#34;cdo/datax&#34;, &#34;encoding&#34;: &#34;UTF-8&#34;, &#34;fieldDelimiter&#34;: &#34;,&#34;, &#34;writeMode&#34;: &#34;truncate|append|nonConflict&#34; } } } ] } } 3.2 参数说明 endpoint
描述：OSS Server的EndPoint地址，例如http://oss.aliyuncs.com。
必选：是 默认值：无 accessId
描述：OSS的accessId 必选：是 默认值：无 accessKey
描述：OSS的accessKey 必选：是 默认值：无 bucket
描述：OSS的bucket 必选：是 默认值：无 object
描述：OSSWriter写入的文件名，OSS使用文件名模拟目录的实现。 使用&#34;object&#34;: “datax”，写入object以datax开头，后缀添加随机字符串。 使用&#34;object&#34;: “cdo/datax”，写入的object以cdo/datax开头，后缀随机添加字符串，/作为OSS模拟目录的分隔符。
必选：是 默认值：无 writeMode...</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX OSSWriter 说明" href="https://haokiu.com/blog/516202a7c10f4658ad32aa517c141a05/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX PostgresqlWriter
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX PostgresqlWriter 1 快速介绍 PostgresqlWriter插件实现了写入数据到 PostgreSQL主库目的表的功能。在底层实现上，PostgresqlWriter通过JDBC连接远程 PostgreSQL 数据库，并执行相应的 insert into … sql 语句将数据写入 PostgreSQL，内部会分批次提交入库。
PostgresqlWriter面向ETL开发工程师，他们使用PostgresqlWriter从数仓导入数据到PostgreSQL。同时 PostgresqlWriter亦可以作为数据迁移工具为DBA等用户提供服务。
2 实现原理 PostgresqlWriter通过 DataX 框架获取 Reader 生成的协议数据，根据你配置生成相应的SQL插入语句
insert into...(当主键/唯一性索引冲突时会写不进去冲突的行) 注意： 1. 目的表所在数据库必须是主库才能写入数据；整个任务至少需具备 insert into...的权限，是否需要其他权限，取决于你任务配置中在 preSql 和 postSql 中指定的语句。 2. PostgresqlWriter和MysqlWriter不同，不支持配置writeMode参数。 3 功能说明 3.1 配置样例 这里使用一份从内存产生到 PostgresqlWriter导入的数据。 { &#34;job&#34;: { &#34;setting&#34;: { &#34;speed&#34;: { &#34;channel&#34;: 1 } }, &#34;content&#34;: [ { &#34;reader&#34;: { &#34;name&#34;: &#34;streamreader&#34;, &#34;parameter&#34;: { &#34;column&#34; : [ { &#34;value&#34;: &#34;DataX&#34;, &#34;type&#34;: &#34;string&#34; }, { &#34;value&#34;: 19880808, &#34;type&#34;: &#34;long&#34; }, { &#34;value&#34;: &#34;1988-08-08 08:08:08&#34;, &#34;type&#34;: &#34;date&#34; }, { &#34;value&#34;: true, &#34;type&#34;: &#34;bool&#34; }, { &#34;value&#34;: &#34;test&#34;, &#34;type&#34;: &#34;bytes&#34; } ], &#34;sliceRecordCount&#34;: 1000 } }, &#34;writer&#34;: { &#34;name&#34;: &#34;postgresqlwriter&#34;, &#34;parameter&#34;: { &#34;username&#34;: &#34;xx&#34;, &#34;password&#34;: &#34;xx&#34;, &#34;column&#34;: [ &#34;id&#34;, &#34;name&#34; ], &#34;preSql&#34;: [ &#34;delete from test&#34; ], &#34;connection&#34;: [ { &#34;jdbcUrl&#34;: &#34;jdbc:postgresql://127....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX PostgresqlWriter" href="https://haokiu.com/blog/1c01500e456b4ef6b6c14eb5a072696e/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX SqlServerWriter
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX SqlServerWriter 1 快速介绍 SqlServerWriter 插件实现了写入数据到 SqlServer 库的目的表的功能。在底层实现上， SqlServerWriter 通过 JDBC 连接远程 SqlServer 数据库，并执行相应的 insert into … sql 语句将数据写入 SqlServer，内部会分批次提交入库。
SqlServerWriter 面向ETL开发工程师，他们使用 SqlServerWriter 从数仓导入数据到 SqlServer。同时 SqlServerWriter 亦可以作为数据迁移工具为DBA等用户提供服务。
2 实现原理 SqlServerWriter 通过 DataX 框架获取 Reader 生成的协议数据，根据你配置生成相应的SQL语句
insert into...(当主键/唯一性索引冲突时会写不进去冲突的行) 注意： 1. 目的表所在数据库必须是主库才能写入数据；整个任务至少需具备 insert into...的权限，是否需要其他权限，取决于你任务配置中在 preSql 和 postSql 中指定的语句。 2.SqlServerWriter和MysqlWriter不同，不支持配置writeMode参数。 3 功能说明 3.1 配置样例 这里使用一份从内存产生到 SqlServer 导入的数据。 { &#34;job&#34;: { &#34;setting&#34;: { &#34;speed&#34;: { &#34;channel&#34;: 5 } }, &#34;content&#34;: [ { &#34;reader&#34;: {}, &#34;writer&#34;: { &#34;name&#34;: &#34;sqlserverwriter&#34;, &#34;parameter&#34;: { &#34;username&#34;: &#34;root&#34;, &#34;password&#34;: &#34;root&#34;, &#34;column&#34;: [ &#34;db_id&#34;, &#34;db_type&#34;, &#34;db_ip&#34;, &#34;db_port&#34;, &#34;db_role&#34;, &#34;db_name&#34;, &#34;db_username&#34;, &#34;db_password&#34;, &#34;db_modify_time&#34;, &#34;db_modify_user&#34;, &#34;db_description&#34;, &#34;db_tddl_info&#34; ], &#34;connection&#34;: [ { &#34;table&#34;: [ &#34;db_info_for_writer&#34; ], &#34;jdbcUrl&#34;: &#34;jdbc:sqlserver://[HOST_NAME]:PORT;DatabaseName=[DATABASE_NAME]&#34; } ], &#34;preSql&#34;: [ &#34;delete from @table where db_id = -1;&#34; ], &#34;postSql&#34;: [ &#34;update @table set db_modify_time = now() where db_id = 1;&#34; ] } } } ] } } 3....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX SqlServerWriter" href="https://haokiu.com/blog/f23fb4346cfa45459b6eaa8537ff5d17/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX Transformer
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX Transformer Transformer定义 在数据同步、传输过程中，存在用户对于数据传输进行特殊定制化的需求场景，包括裁剪列、转换列等工作，可以借助ETL的T过程实现(Transformer)。DataX包含了完整的E(Extract)、T(Transformer)、L(Load)支持。
运行模型 UDF手册 dx_substr 参数：3个 第一个参数：字段编号，对应record中第几个字段。 第二个参数：字段值的开始位置。 第三个参数：目标字段长度。 返回： 从字符串的指定位置（包含）截取指定长度的字符串。如果开始位置非法抛出异常。如果字段为空值，直接返回（即不参与本transformer） 举例： dx_substr(1,&#34;2&#34;,&#34;5&#34;) column 1的value为“dataxTest”=&gt;&#34;taxTe&#34; dx_substr(1,&#34;5&#34;,&#34;10&#34;) column 1的value为“dataxTest”=&gt;&#34;Test&#34; dx_pad 参数：4个 第一个参数：字段编号，对应record中第几个字段。 第二个参数：“l”,“r”, 指示是在头进行pad，还是尾进行pad。 第三个参数：目标字段长度。 第四个参数：需要pad的字符。 返回： 如果源字符串长度小于目标字段长度，按照位置添加pad字符后返回。如果长于，直接截断（都截右边）。如果字段为空值，转换为空字符串进行pad，即最后的字符串全是需要pad的字符 举例： dx_pad(1,&#34;l&#34;,&#34;4&#34;,&#34;A&#34;), 如果column 1 的值为 xyz=&gt; Axyz， 值为 xyzzzzz =&gt; xyzz dx_pad(1,&#34;r&#34;,&#34;4&#34;,&#34;A&#34;), 如果column 1 的值为 xyz=&gt; xyzA， 值为 xyzzzzz =&gt; xyzz dx_replace 参数：4个 第一个参数：字段编号，对应record中第几个字段。 第二个参数：字段值的开始位置。 第三个参数：需要替换的字段长度。 第四个参数：需要替换的字符串。 返回： 从字符串的指定位置（包含）替换指定长度的字符串。如果开始位置非法抛出异常。如果字段为空值，直接返回（即不参与本transformer） 举例： dx_replace(1,&#34;2&#34;,&#34;4&#34;,&#34;****&#34;) column 1的value为“dataxTest”=&gt;&#34;da****est&#34; dx_replace(1,&#34;5&#34;,&#34;10&#34;,&#34;****&#34;) column 1的value为“dataxTest”=&gt;&#34;data****&#34; dx_filter （关联filter暂不支持，即多个字段的联合判断，函参太过复杂，用户难以使用。） 参数： 第一个参数：字段编号，对应record中第几个字段。 第二个参数：运算符，支持一下运算符：like, not like, &gt;, =, &lt;, &gt;=, !=, &lt;= 第三个参数：正则表达式（java正则表达式）、值。 返回： 如果匹配正则表达式，返回Null，表示过滤该行。不匹配表达式时，表示保留该行。（注意是该行）。对于&gt;=&lt;都是对字段直接compare的结果. like ， not like是将字段转换成String，然后和目标正则表达式进行全匹配。 , =, &lt;, &gt;=, !=, &lt;= 对于DoubleColumn比较double值，对于LongColumn和DateColumn比较long值，其他StringColumn，BooleanColumn以及ByteColumn均比较的是StringColumn值。
如果目标colunn为空（null），对于 = null的过滤条件，将满足条件，被过滤。！=null的过滤条件，null不满足过滤条件，不被过滤。 like，字段为null不满足条件，不被过滤，和not like，字段为null满足条件，被过滤。 举例： dx_filter(1,&#34;like&#34;,&#34;dataTest&#34;) dx_filter(1,&#34;&gt;=&#34;,&#34;10&#34;) dx_groovy 参数。 第一个参数： groovy code 第二个参数（列表或者为空）：extraPackage 备注： dx_groovy只能调用一次。不能多次调用。 groovy code中支持java....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX Transformer" href="https://haokiu.com/blog/760d0498cfcd435bafba3fe96793cd01/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX TxtFileReader 说明
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX TxtFileReader 说明 1 快速介绍 TxtFileReader提供了读取本地文件系统数据存储的能力。在底层实现上，TxtFileReader获取本地文件数据，并转换为DataX传输协议传递给Writer。
本地文件内容存放的是一张逻辑意义上的二维表，例如CSV格式的文本信息。
2 功能与限制 TxtFileReader实现了从本地文件读取数据并转为DataX协议的功能，本地文件本身是无结构化数据存储，对于DataX而言，TxtFileReader实现上类比OSSReader，有诸多相似之处。目前TxtFileReader支持功能如下：
支持且仅支持读取TXT的文件，且要求TXT中shema为一张二维表。
支持类CSV格式文件，自定义分隔符。
支持多种类型数据读取(使用String表示)，支持列裁剪，支持列常量
支持递归读取、支持文件名过滤。
支持文本压缩，现有压缩格式为zip、gzip、bzip2。
多个File可以支持并发读取。
我们暂时不能做到：
单个File支持多线程并发读取，这里涉及到单个File内部切分算法。二期考虑支持。
单个File在压缩情况下，从技术上无法支持多线程并发读取。
3 功能说明 3.1 配置样例 { &#34;setting&#34;: {}, &#34;job&#34;: { &#34;setting&#34;: { &#34;speed&#34;: { &#34;channel&#34;: 2 } }, &#34;content&#34;: [ { &#34;reader&#34;: { &#34;name&#34;: &#34;txtfilereader&#34;, &#34;parameter&#34;: { &#34;path&#34;: [&#34;/home/haiwei.luo/case00/data&#34;], &#34;encoding&#34;: &#34;UTF-8&#34;, &#34;column&#34;: [ { &#34;index&#34;: 0, &#34;type&#34;: &#34;long&#34; }, { &#34;index&#34;: 1, &#34;type&#34;: &#34;boolean&#34; }, { &#34;index&#34;: 2, &#34;type&#34;: &#34;double&#34; }, { &#34;index&#34;: 3, &#34;type&#34;: &#34;string&#34; }, { &#34;index&#34;: 4, &#34;type&#34;: &#34;date&#34;, &#34;format&#34;: &#34;yyyy.MM.dd&#34; } ], &#34;fieldDelimiter&#34;: &#34;,&#34; } }, &#34;writer&#34;: { &#34;name&#34;: &#34;txtfilewriter&#34;, &#34;parameter&#34;: { &#34;path&#34;: &#34;/home/haiwei.luo/case00/result&#34;, &#34;fileName&#34;: &#34;luohw&#34;, &#34;writeMode&#34;: &#34;truncate&#34;, &#34;format&#34;: &#34;yyyy-MM-dd&#34; } } } ] } } 3....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX TxtFileReader 说明" href="https://haokiu.com/blog/cbeab748638041dfa63c78ebe4fa91db/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>DataX TxtFileWriter 说明
    </h2>
  </header>
  <div class="entry-content">
    <p>DataX TxtFileWriter 说明 1 快速介绍 TxtFileWriter提供了向本地文件写入类CSV格式的一个或者多个表文件。TxtFileWriter服务的用户主要在于DataX开发、测试同学。
写入本地文件内容存放的是一张逻辑意义上的二维表，例如CSV格式的文本信息。
2 功能与限制 TxtFileWriter实现了从DataX协议转为本地TXT文件功能，本地文件本身是无结构化数据存储，TxtFileWriter如下几个方面约定:
支持且仅支持写入 TXT的文件，且要求TXT中shema为一张二维表。
支持类CSV格式文件，自定义分隔符。
支持文本压缩，现有压缩格式为gzip、bzip2。
支持多线程写入，每个线程写入不同子文件。
文件支持滚动，当文件大于某个size值或者行数值，文件需要切换。 [暂不支持]
我们不能做到：
单个文件不能支持并发写入。 3 功能说明 3.1 配置样例 { &#34;setting&#34;: {}, &#34;job&#34;: { &#34;setting&#34;: { &#34;speed&#34;: { &#34;channel&#34;: 2 } }, &#34;content&#34;: [ { &#34;reader&#34;: { &#34;name&#34;: &#34;txtfilereader&#34;, &#34;parameter&#34;: { &#34;path&#34;: [&#34;/home/haiwei.luo/case00/data&#34;], &#34;encoding&#34;: &#34;UTF-8&#34;, &#34;column&#34;: [ { &#34;index&#34;: 0, &#34;type&#34;: &#34;long&#34; }, { &#34;index&#34;: 1, &#34;type&#34;: &#34;boolean&#34; }, { &#34;index&#34;: 2, &#34;type&#34;: &#34;double&#34; }, { &#34;index&#34;: 3, &#34;type&#34;: &#34;string&#34; }, { &#34;index&#34;: 4, &#34;type&#34;: &#34;date&#34;, &#34;format&#34;: &#34;yyyy.MM.dd&#34; } ], &#34;fieldDelimiter&#34;: &#34;,&#34; } }, &#34;writer&#34;: { &#34;name&#34;: &#34;txtfilewriter&#34;, &#34;parameter&#34;: { &#34;path&#34;: &#34;/home/haiwei.luo/case00/result&#34;, &#34;fileName&#34;: &#34;luohw&#34;, &#34;writeMode&#34;: &#34;truncate&#34;, &#34;dateFormat&#34;: &#34;yyyy-MM-dd&#34; } } } ] } } 3....</p>
  </div>
  <footer class="entry-footer"><span title='2021-02-02 17:45:01 +0000 UTC'>February 2, 2021</span></footer>
  <a class="entry-link" aria-label="post link to DataX TxtFileWriter 说明" href="https://haokiu.com/blog/599f9ae387e54760ab26e177bd423e82/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://haokiu.com/categories/4/index/2/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://haokiu.com/categories/4/index/4/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
