<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>11 pc客户端源码分析 | haokiu</title>
<meta name="keywords" content="">
<meta name="description" content="11 pc客户端源码分析 ——写在前面的话
在要不要写这篇文章的纠结中挣扎了好久，就我个人而已，我接触windows编程，已经六七个年头了，尤其是在我读研的三年内，基本心思都是花在学习和研究windows程序上了。我很庆幸我当初学习windows程序走了一条正确的路线：先是学习常用的windows程序原理和基本API，再学习的mfc、wtl等一些常用的框架和类库，同时看了大量windows项目的源码，如金山卫士的开源代码、filezilla、电驴源码等等。个人觉得，基础真的很重要，拿windows开发来说，当你掌握了windows的程序的基本原理，我列一下大致范围：
windows消息机制（消息如何产生、如何发送、如何处理，常见的消息有哪些、消息的优先级、如何自定义消息、窗体消息、常用控件消息）
gdi原理（要熟悉gdi的各种对象，如画笔、画刷、字体、区域、裁剪、位图等，熟悉它们的API，熟悉各种gdi绘图API、当然最好也要熟悉一整套的gdi&#43;的类，gdi与gdi&#43;的区别）
windows进程与线程的概念（进程的概念、如何创建、如何结束、跨进程如何通信；线程的创建与销毁、线程间的同步与资源保护，熟悉windows常用的线程同步对象：临界区、事件、互斥体、信号量等）
windows内存管理（清晰地掌握一个进程地址空间的内存分布、windows堆的创建与管理等）
dll技术（dll的生成、变量的导出、函数的导出、类的导出、如何查看dll导出哪些函数、隐式dll的加载、显示dll的加载、远程dll注入技术等）
PE文件（一个PE文件的结构、有哪些节、如何修改、分别映射到进程地址空间的什么位置等）
windows SEH（结构化异常处理）
windows socket编程
windows读写文件技术（像CreateFile、WriteFile、GetFileSize等这些API应该熟练掌握、内存映射技术）
当然很多必备的技术也不好归类到windows技术下面，比如socket编程，这涉及到很多网络的知识，比如tcp的三次握手，数据的收发等，还有就是各种字符编码的知识、以及之间的相互转换，又比如一系列的CRT函数及其对应的宽字符版本。当然如果你搞windows开发，一定要熟悉开发工具Visual Studio，熟悉其工程项目的大多数属性配置，而且要做到知其然也知其所以然。如果不是不能跨平台，我敢说VS是史上最好最强大的开发工具，没有之一！我已经有好几年年不做windows开发了，目前主要从事linux开发，但windows的很多设计思想真的很好，非常值得借鉴，而且从编码风格来说，虽然看起来有点怪异，但是非常规范和易懂。
有了基础知识，你可以轻松地对工作中的一些问题给出解决方案，也能轻松阅读和使用市面上的那些库，比如，如果你深刻理解windows GDI，你不会在一个群里大喊，duilib某个属性为什么不起作用，你可以直接去阅读它的画法代码，如果是bug你可以改bug，如果只是你使用错误，你可以了解到正确的使用方法。所以基础这个东西，在短时间内，可能让你看不出与其他人的差别，但是从长远来看，它决定着你在技术上走的高度与深度。套用侯捷先生的一句话：勿在浮沙筑高台。
—— 正题
上面简单地介绍了下，我个人学习windows程序设计的一些心得吧。扯的有点远了，让我们回到正题上来，来分析TeamTalk的源码吧。当然这篇文章与前面介绍的不一样，我们不仅介绍程序的正题设计思路，还会介绍一些有意义的细节，比如一些windows开发中常用的一些细节。
一、程序功能 我们来先看下TeamTalk pc客户端包括哪些功能：TeamTalk因为开发的初衷是用于企业内部的即时通讯软件，所以，不提供对外注册的功能，一个员工的加入一般是人事部门在后台管理系统来新增该员工信息。其功能包括登录、聊天、群聊和建讨论组，当然聊天过程中可以发文字、表情、图片和文件，还包括查看聊天记录和简单地查看某个员工的个人信息，业务功能其实不多的。下面是一些功能截图：
二、编译方法与项目工程文件介绍 TeamTalk的pc客户端的下载地址是：https://github.com/baloonwj/TeamTalk 代码包括服务器端代码、pc端、mac端、安卓和IOS端，还有web端所有代码。
pc客户端代码的编译方法很简单：用VS2013打开win-client\solution目录下的teamtalk.sln，编译即可。你的VS版本至少要是VS2013，因为代码中大量使用了C&#43;&#43;11的东西，VS2013以下版本是不支持C&#43;&#43;11的语法的。当然，如果你是VS2015的话，可以参考这篇文章来进行修改和编译：http://www.07net01.com/linux/2017/01/1795569.html
打开teamtalk.sln之后，总共有10个解决方法，如下图所示：
其中teamtalk是主工程，你应该将它设置成启动工程，编译完成之后就可以调试了。你可以自己配置服务器来连接进行调试，我也可以连接我的测试服务器，具体参见《TeamTalk源码分析（十） —— 开放一个TeamTalk测试服务器地址和几个测试账号》。下面先大致介绍一个各个工程的作用：
Duilib是teamtalk使用的一款开源界面库，该界面库模仿web开发中的布局技术，使用xml文件来布局windows界面，并且在主窗口上绘制所有子控件，也就是所谓的directUI技术；
GifSmiley是程序中用来解析和显示gif格式的图片的库，以支持gif图片的动画效果；
httpclient功能是程序中使用的http请求库，登录前程序会先连接服务器的login_server以获得后续需要登录的msg_server的ip地址和端口号 等信息，这里就是使用的http协议，同时聊天过程中收发的聊天图片与图片服务器msfs也使用http协议来收发这些图片；
libogg是一个语音库，用来解析声音文件的，因为pc客户端可能会收到移动端的语音聊天，相比较传统的*.wav、.mp3、.wma，*.ogg格式的不仅音质高，而且音频文件的体积小，腾讯的QQ游戏英雄杀中的语音也是使用这个格式的。
libspeex是一个音频压缩库；
Modules就是TeamTalk中使用的各种库了，展开来看下你就明白了：
network是teamtalk使用的网络通信的代码，其实teamtalk pc端和服务器端使用的是同一套网络通信库，只不过如果服务器运行在linux下，其核心的IO复用模型是epoll，而pc客户端使用的IO复用模型是select；
speexdec 也是和ogg格式相关的编码和解码器；
teamtalk是主程序入口工程；
utility包含了teamtalk中用到的一些工具类工程，比如sqlite的包装接口、md5工具类等。
除了上面介绍的一些库以外，程序还使用了sqlite库、谷歌protobuf库、日志库yaolog等。关于yaolog可参见http://blog.csdn.net/gemo/article/details/8499692，这个日志库比较有意思的地方是可以单独打印出网络通信中的字节流的二进制形式，推荐一下，效果如下图所示（位于win-client\bin\teamtalk\Debug\log\socket.log文件中）：
三、程序总体框架介绍 整个程序使用了mfc框架来做一个架子，而所有的窗口和对话框都使用的是duilib，关于duilib网上有很多资料，这里不介绍duilib细节的东西了。一个mfc程序框架，使用起来也很简单，就是定义一个类集成mfc的CWinApp类，并改写其InitInstance()方法，mfc内部会替我们做好消息循环的步骤。TeamTalk相关的代码如下：
//位于teamtalk.h中 class CteamtalkApp : public CWinApp { public: CteamtalkApp(); public: virtual BOOL InitInstance(); virtual BOOL ExitInstance(); private: /** * 创建用户目录 * * @return BOOL * @exception there is no any exception to throw. */	BOOL _CreateUsersFolder(); /** * 创建主窗口 * * @return BOOL * @exception there is no any exception to throw.">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/ee4c77c4daf64f5f821d76808ec0b8b3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="11 pc客户端源码分析" />
<meta property="og:description" content="11 pc客户端源码分析 ——写在前面的话
在要不要写这篇文章的纠结中挣扎了好久，就我个人而已，我接触windows编程，已经六七个年头了，尤其是在我读研的三年内，基本心思都是花在学习和研究windows程序上了。我很庆幸我当初学习windows程序走了一条正确的路线：先是学习常用的windows程序原理和基本API，再学习的mfc、wtl等一些常用的框架和类库，同时看了大量windows项目的源码，如金山卫士的开源代码、filezilla、电驴源码等等。个人觉得，基础真的很重要，拿windows开发来说，当你掌握了windows的程序的基本原理，我列一下大致范围：
windows消息机制（消息如何产生、如何发送、如何处理，常见的消息有哪些、消息的优先级、如何自定义消息、窗体消息、常用控件消息）
gdi原理（要熟悉gdi的各种对象，如画笔、画刷、字体、区域、裁剪、位图等，熟悉它们的API，熟悉各种gdi绘图API、当然最好也要熟悉一整套的gdi&#43;的类，gdi与gdi&#43;的区别）
windows进程与线程的概念（进程的概念、如何创建、如何结束、跨进程如何通信；线程的创建与销毁、线程间的同步与资源保护，熟悉windows常用的线程同步对象：临界区、事件、互斥体、信号量等）
windows内存管理（清晰地掌握一个进程地址空间的内存分布、windows堆的创建与管理等）
dll技术（dll的生成、变量的导出、函数的导出、类的导出、如何查看dll导出哪些函数、隐式dll的加载、显示dll的加载、远程dll注入技术等）
PE文件（一个PE文件的结构、有哪些节、如何修改、分别映射到进程地址空间的什么位置等）
windows SEH（结构化异常处理）
windows socket编程
windows读写文件技术（像CreateFile、WriteFile、GetFileSize等这些API应该熟练掌握、内存映射技术）
当然很多必备的技术也不好归类到windows技术下面，比如socket编程，这涉及到很多网络的知识，比如tcp的三次握手，数据的收发等，还有就是各种字符编码的知识、以及之间的相互转换，又比如一系列的CRT函数及其对应的宽字符版本。当然如果你搞windows开发，一定要熟悉开发工具Visual Studio，熟悉其工程项目的大多数属性配置，而且要做到知其然也知其所以然。如果不是不能跨平台，我敢说VS是史上最好最强大的开发工具，没有之一！我已经有好几年年不做windows开发了，目前主要从事linux开发，但windows的很多设计思想真的很好，非常值得借鉴，而且从编码风格来说，虽然看起来有点怪异，但是非常规范和易懂。
有了基础知识，你可以轻松地对工作中的一些问题给出解决方案，也能轻松阅读和使用市面上的那些库，比如，如果你深刻理解windows GDI，你不会在一个群里大喊，duilib某个属性为什么不起作用，你可以直接去阅读它的画法代码，如果是bug你可以改bug，如果只是你使用错误，你可以了解到正确的使用方法。所以基础这个东西，在短时间内，可能让你看不出与其他人的差别，但是从长远来看，它决定着你在技术上走的高度与深度。套用侯捷先生的一句话：勿在浮沙筑高台。
—— 正题
上面简单地介绍了下，我个人学习windows程序设计的一些心得吧。扯的有点远了，让我们回到正题上来，来分析TeamTalk的源码吧。当然这篇文章与前面介绍的不一样，我们不仅介绍程序的正题设计思路，还会介绍一些有意义的细节，比如一些windows开发中常用的一些细节。
一、程序功能 我们来先看下TeamTalk pc客户端包括哪些功能：TeamTalk因为开发的初衷是用于企业内部的即时通讯软件，所以，不提供对外注册的功能，一个员工的加入一般是人事部门在后台管理系统来新增该员工信息。其功能包括登录、聊天、群聊和建讨论组，当然聊天过程中可以发文字、表情、图片和文件，还包括查看聊天记录和简单地查看某个员工的个人信息，业务功能其实不多的。下面是一些功能截图：
二、编译方法与项目工程文件介绍 TeamTalk的pc客户端的下载地址是：https://github.com/baloonwj/TeamTalk 代码包括服务器端代码、pc端、mac端、安卓和IOS端，还有web端所有代码。
pc客户端代码的编译方法很简单：用VS2013打开win-client\solution目录下的teamtalk.sln，编译即可。你的VS版本至少要是VS2013，因为代码中大量使用了C&#43;&#43;11的东西，VS2013以下版本是不支持C&#43;&#43;11的语法的。当然，如果你是VS2015的话，可以参考这篇文章来进行修改和编译：http://www.07net01.com/linux/2017/01/1795569.html
打开teamtalk.sln之后，总共有10个解决方法，如下图所示：
其中teamtalk是主工程，你应该将它设置成启动工程，编译完成之后就可以调试了。你可以自己配置服务器来连接进行调试，我也可以连接我的测试服务器，具体参见《TeamTalk源码分析（十） —— 开放一个TeamTalk测试服务器地址和几个测试账号》。下面先大致介绍一个各个工程的作用：
Duilib是teamtalk使用的一款开源界面库，该界面库模仿web开发中的布局技术，使用xml文件来布局windows界面，并且在主窗口上绘制所有子控件，也就是所谓的directUI技术；
GifSmiley是程序中用来解析和显示gif格式的图片的库，以支持gif图片的动画效果；
httpclient功能是程序中使用的http请求库，登录前程序会先连接服务器的login_server以获得后续需要登录的msg_server的ip地址和端口号 等信息，这里就是使用的http协议，同时聊天过程中收发的聊天图片与图片服务器msfs也使用http协议来收发这些图片；
libogg是一个语音库，用来解析声音文件的，因为pc客户端可能会收到移动端的语音聊天，相比较传统的*.wav、.mp3、.wma，*.ogg格式的不仅音质高，而且音频文件的体积小，腾讯的QQ游戏英雄杀中的语音也是使用这个格式的。
libspeex是一个音频压缩库；
Modules就是TeamTalk中使用的各种库了，展开来看下你就明白了：
network是teamtalk使用的网络通信的代码，其实teamtalk pc端和服务器端使用的是同一套网络通信库，只不过如果服务器运行在linux下，其核心的IO复用模型是epoll，而pc客户端使用的IO复用模型是select；
speexdec 也是和ogg格式相关的编码和解码器；
teamtalk是主程序入口工程；
utility包含了teamtalk中用到的一些工具类工程，比如sqlite的包装接口、md5工具类等。
除了上面介绍的一些库以外，程序还使用了sqlite库、谷歌protobuf库、日志库yaolog等。关于yaolog可参见http://blog.csdn.net/gemo/article/details/8499692，这个日志库比较有意思的地方是可以单独打印出网络通信中的字节流的二进制形式，推荐一下，效果如下图所示（位于win-client\bin\teamtalk\Debug\log\socket.log文件中）：
三、程序总体框架介绍 整个程序使用了mfc框架来做一个架子，而所有的窗口和对话框都使用的是duilib，关于duilib网上有很多资料，这里不介绍duilib细节的东西了。一个mfc程序框架，使用起来也很简单，就是定义一个类集成mfc的CWinApp类，并改写其InitInstance()方法，mfc内部会替我们做好消息循环的步骤。TeamTalk相关的代码如下：
//位于teamtalk.h中 class CteamtalkApp : public CWinApp { public: CteamtalkApp(); public: virtual BOOL InitInstance(); virtual BOOL ExitInstance(); private: /** * 创建用户目录 * * @return BOOL * @exception there is no any exception to throw. */	BOOL _CreateUsersFolder(); /** * 创建主窗口 * * @return BOOL * @exception there is no any exception to throw." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://haokiu.com/ee4c77c4daf64f5f821d76808ec0b8b3/" /><meta property="article:section" content="1" />
<meta property="article:published_time" content="2021-01-11T09:20:42+00:00" />
<meta property="article:modified_time" content="2021-01-11T09:20:42+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="11 pc客户端源码分析"/>
<meta name="twitter:description" content="11 pc客户端源码分析 ——写在前面的话
在要不要写这篇文章的纠结中挣扎了好久，就我个人而已，我接触windows编程，已经六七个年头了，尤其是在我读研的三年内，基本心思都是花在学习和研究windows程序上了。我很庆幸我当初学习windows程序走了一条正确的路线：先是学习常用的windows程序原理和基本API，再学习的mfc、wtl等一些常用的框架和类库，同时看了大量windows项目的源码，如金山卫士的开源代码、filezilla、电驴源码等等。个人觉得，基础真的很重要，拿windows开发来说，当你掌握了windows的程序的基本原理，我列一下大致范围：
windows消息机制（消息如何产生、如何发送、如何处理，常见的消息有哪些、消息的优先级、如何自定义消息、窗体消息、常用控件消息）
gdi原理（要熟悉gdi的各种对象，如画笔、画刷、字体、区域、裁剪、位图等，熟悉它们的API，熟悉各种gdi绘图API、当然最好也要熟悉一整套的gdi&#43;的类，gdi与gdi&#43;的区别）
windows进程与线程的概念（进程的概念、如何创建、如何结束、跨进程如何通信；线程的创建与销毁、线程间的同步与资源保护，熟悉windows常用的线程同步对象：临界区、事件、互斥体、信号量等）
windows内存管理（清晰地掌握一个进程地址空间的内存分布、windows堆的创建与管理等）
dll技术（dll的生成、变量的导出、函数的导出、类的导出、如何查看dll导出哪些函数、隐式dll的加载、显示dll的加载、远程dll注入技术等）
PE文件（一个PE文件的结构、有哪些节、如何修改、分别映射到进程地址空间的什么位置等）
windows SEH（结构化异常处理）
windows socket编程
windows读写文件技术（像CreateFile、WriteFile、GetFileSize等这些API应该熟练掌握、内存映射技术）
当然很多必备的技术也不好归类到windows技术下面，比如socket编程，这涉及到很多网络的知识，比如tcp的三次握手，数据的收发等，还有就是各种字符编码的知识、以及之间的相互转换，又比如一系列的CRT函数及其对应的宽字符版本。当然如果你搞windows开发，一定要熟悉开发工具Visual Studio，熟悉其工程项目的大多数属性配置，而且要做到知其然也知其所以然。如果不是不能跨平台，我敢说VS是史上最好最强大的开发工具，没有之一！我已经有好几年年不做windows开发了，目前主要从事linux开发，但windows的很多设计思想真的很好，非常值得借鉴，而且从编码风格来说，虽然看起来有点怪异，但是非常规范和易懂。
有了基础知识，你可以轻松地对工作中的一些问题给出解决方案，也能轻松阅读和使用市面上的那些库，比如，如果你深刻理解windows GDI，你不会在一个群里大喊，duilib某个属性为什么不起作用，你可以直接去阅读它的画法代码，如果是bug你可以改bug，如果只是你使用错误，你可以了解到正确的使用方法。所以基础这个东西，在短时间内，可能让你看不出与其他人的差别，但是从长远来看，它决定着你在技术上走的高度与深度。套用侯捷先生的一句话：勿在浮沙筑高台。
—— 正题
上面简单地介绍了下，我个人学习windows程序设计的一些心得吧。扯的有点远了，让我们回到正题上来，来分析TeamTalk的源码吧。当然这篇文章与前面介绍的不一样，我们不仅介绍程序的正题设计思路，还会介绍一些有意义的细节，比如一些windows开发中常用的一些细节。
一、程序功能 我们来先看下TeamTalk pc客户端包括哪些功能：TeamTalk因为开发的初衷是用于企业内部的即时通讯软件，所以，不提供对外注册的功能，一个员工的加入一般是人事部门在后台管理系统来新增该员工信息。其功能包括登录、聊天、群聊和建讨论组，当然聊天过程中可以发文字、表情、图片和文件，还包括查看聊天记录和简单地查看某个员工的个人信息，业务功能其实不多的。下面是一些功能截图：
二、编译方法与项目工程文件介绍 TeamTalk的pc客户端的下载地址是：https://github.com/baloonwj/TeamTalk 代码包括服务器端代码、pc端、mac端、安卓和IOS端，还有web端所有代码。
pc客户端代码的编译方法很简单：用VS2013打开win-client\solution目录下的teamtalk.sln，编译即可。你的VS版本至少要是VS2013，因为代码中大量使用了C&#43;&#43;11的东西，VS2013以下版本是不支持C&#43;&#43;11的语法的。当然，如果你是VS2015的话，可以参考这篇文章来进行修改和编译：http://www.07net01.com/linux/2017/01/1795569.html
打开teamtalk.sln之后，总共有10个解决方法，如下图所示：
其中teamtalk是主工程，你应该将它设置成启动工程，编译完成之后就可以调试了。你可以自己配置服务器来连接进行调试，我也可以连接我的测试服务器，具体参见《TeamTalk源码分析（十） —— 开放一个TeamTalk测试服务器地址和几个测试账号》。下面先大致介绍一个各个工程的作用：
Duilib是teamtalk使用的一款开源界面库，该界面库模仿web开发中的布局技术，使用xml文件来布局windows界面，并且在主窗口上绘制所有子控件，也就是所谓的directUI技术；
GifSmiley是程序中用来解析和显示gif格式的图片的库，以支持gif图片的动画效果；
httpclient功能是程序中使用的http请求库，登录前程序会先连接服务器的login_server以获得后续需要登录的msg_server的ip地址和端口号 等信息，这里就是使用的http协议，同时聊天过程中收发的聊天图片与图片服务器msfs也使用http协议来收发这些图片；
libogg是一个语音库，用来解析声音文件的，因为pc客户端可能会收到移动端的语音聊天，相比较传统的*.wav、.mp3、.wma，*.ogg格式的不仅音质高，而且音频文件的体积小，腾讯的QQ游戏英雄杀中的语音也是使用这个格式的。
libspeex是一个音频压缩库；
Modules就是TeamTalk中使用的各种库了，展开来看下你就明白了：
network是teamtalk使用的网络通信的代码，其实teamtalk pc端和服务器端使用的是同一套网络通信库，只不过如果服务器运行在linux下，其核心的IO复用模型是epoll，而pc客户端使用的IO复用模型是select；
speexdec 也是和ogg格式相关的编码和解码器；
teamtalk是主程序入口工程；
utility包含了teamtalk中用到的一些工具类工程，比如sqlite的包装接口、md5工具类等。
除了上面介绍的一些库以外，程序还使用了sqlite库、谷歌protobuf库、日志库yaolog等。关于yaolog可参见http://blog.csdn.net/gemo/article/details/8499692，这个日志库比较有意思的地方是可以单独打印出网络通信中的字节流的二进制形式，推荐一下，效果如下图所示（位于win-client\bin\teamtalk\Debug\log\socket.log文件中）：
三、程序总体框架介绍 整个程序使用了mfc框架来做一个架子，而所有的窗口和对话框都使用的是duilib，关于duilib网上有很多资料，这里不介绍duilib细节的东西了。一个mfc程序框架，使用起来也很简单，就是定义一个类集成mfc的CWinApp类，并改写其InitInstance()方法，mfc内部会替我们做好消息循环的步骤。TeamTalk相关的代码如下：
//位于teamtalk.h中 class CteamtalkApp : public CWinApp { public: CteamtalkApp(); public: virtual BOOL InitInstance(); virtual BOOL ExitInstance(); private: /** * 创建用户目录 * * @return BOOL * @exception there is no any exception to throw. */	BOOL _CreateUsersFolder(); /** * 创建主窗口 * * @return BOOL * @exception there is no any exception to throw."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "1s",
      "item": "https://haokiu.com/1/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "11 pc客户端源码分析",
      "item": "https://haokiu.com/ee4c77c4daf64f5f821d76808ec0b8b3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "11 pc客户端源码分析",
  "name": "11 pc客户端源码分析",
  "description": "11 pc客户端源码分析 ——写在前面的话\n在要不要写这篇文章的纠结中挣扎了好久，就我个人而已，我接触windows编程，已经六七个年头了，尤其是在我读研的三年内，基本心思都是花在学习和研究windows程序上了。我很庆幸我当初学习windows程序走了一条正确的路线：先是学习常用的windows程序原理和基本API，再学习的mfc、wtl等一些常用的框架和类库，同时看了大量windows项目的源码，如金山卫士的开源代码、filezilla、电驴源码等等。个人觉得，基础真的很重要，拿windows开发来说，当你掌握了windows的程序的基本原理，我列一下大致范围：\nwindows消息机制（消息如何产生、如何发送、如何处理，常见的消息有哪些、消息的优先级、如何自定义消息、窗体消息、常用控件消息）\ngdi原理（要熟悉gdi的各种对象，如画笔、画刷、字体、区域、裁剪、位图等，熟悉它们的API，熟悉各种gdi绘图API、当然最好也要熟悉一整套的gdi+的类，gdi与gdi+的区别）\nwindows进程与线程的概念（进程的概念、如何创建、如何结束、跨进程如何通信；线程的创建与销毁、线程间的同步与资源保护，熟悉windows常用的线程同步对象：临界区、事件、互斥体、信号量等）\nwindows内存管理（清晰地掌握一个进程地址空间的内存分布、windows堆的创建与管理等）\ndll技术（dll的生成、变量的导出、函数的导出、类的导出、如何查看dll导出哪些函数、隐式dll的加载、显示dll的加载、远程dll注入技术等）\nPE文件（一个PE文件的结构、有哪些节、如何修改、分别映射到进程地址空间的什么位置等）\nwindows SEH（结构化异常处理）\nwindows socket编程\nwindows读写文件技术（像CreateFile、WriteFile、GetFileSize等这些API应该熟练掌握、内存映射技术）\n当然很多必备的技术也不好归类到windows技术下面，比如socket编程，这涉及到很多网络的知识，比如tcp的三次握手，数据的收发等，还有就是各种字符编码的知识、以及之间的相互转换，又比如一系列的CRT函数及其对应的宽字符版本。当然如果你搞windows开发，一定要熟悉开发工具Visual Studio，熟悉其工程项目的大多数属性配置，而且要做到知其然也知其所以然。如果不是不能跨平台，我敢说VS是史上最好最强大的开发工具，没有之一！我已经有好几年年不做windows开发了，目前主要从事linux开发，但windows的很多设计思想真的很好，非常值得借鉴，而且从编码风格来说，虽然看起来有点怪异，但是非常规范和易懂。\n有了基础知识，你可以轻松地对工作中的一些问题给出解决方案，也能轻松阅读和使用市面上的那些库，比如，如果你深刻理解windows GDI，你不会在一个群里大喊，duilib某个属性为什么不起作用，你可以直接去阅读它的画法代码，如果是bug你可以改bug，如果只是你使用错误，你可以了解到正确的使用方法。所以基础这个东西，在短时间内，可能让你看不出与其他人的差别，但是从长远来看，它决定着你在技术上走的高度与深度。套用侯捷先生的一句话：勿在浮沙筑高台。\n—— 正题\n上面简单地介绍了下，我个人学习windows程序设计的一些心得吧。扯的有点远了，让我们回到正题上来，来分析TeamTalk的源码吧。当然这篇文章与前面介绍的不一样，我们不仅介绍程序的正题设计思路，还会介绍一些有意义的细节，比如一些windows开发中常用的一些细节。\n一、程序功能 我们来先看下TeamTalk pc客户端包括哪些功能：TeamTalk因为开发的初衷是用于企业内部的即时通讯软件，所以，不提供对外注册的功能，一个员工的加入一般是人事部门在后台管理系统来新增该员工信息。其功能包括登录、聊天、群聊和建讨论组，当然聊天过程中可以发文字、表情、图片和文件，还包括查看聊天记录和简单地查看某个员工的个人信息，业务功能其实不多的。下面是一些功能截图：\n二、编译方法与项目工程文件介绍 TeamTalk的pc客户端的下载地址是：https://github.com/baloonwj/TeamTalk 代码包括服务器端代码、pc端、mac端、安卓和IOS端，还有web端所有代码。\npc客户端代码的编译方法很简单：用VS2013打开win-client\\solution目录下的teamtalk.sln，编译即可。你的VS版本至少要是VS2013，因为代码中大量使用了C++11的东西，VS2013以下版本是不支持C++11的语法的。当然，如果你是VS2015的话，可以参考这篇文章来进行修改和编译：http://www.07net01.com/linux/2017/01/1795569.html\n打开teamtalk.sln之后，总共有10个解决方法，如下图所示：\n其中teamtalk是主工程，你应该将它设置成启动工程，编译完成之后就可以调试了。你可以自己配置服务器来连接进行调试，我也可以连接我的测试服务器，具体参见《TeamTalk源码分析（十） —— 开放一个TeamTalk测试服务器地址和几个测试账号》。下面先大致介绍一个各个工程的作用：\nDuilib是teamtalk使用的一款开源界面库，该界面库模仿web开发中的布局技术，使用xml文件来布局windows界面，并且在主窗口上绘制所有子控件，也就是所谓的directUI技术；\nGifSmiley是程序中用来解析和显示gif格式的图片的库，以支持gif图片的动画效果；\nhttpclient功能是程序中使用的http请求库，登录前程序会先连接服务器的login_server以获得后续需要登录的msg_server的ip地址和端口号 等信息，这里就是使用的http协议，同时聊天过程中收发的聊天图片与图片服务器msfs也使用http协议来收发这些图片；\nlibogg是一个语音库，用来解析声音文件的，因为pc客户端可能会收到移动端的语音聊天，相比较传统的*.wav、.mp3、.wma，*.ogg格式的不仅音质高，而且音频文件的体积小，腾讯的QQ游戏英雄杀中的语音也是使用这个格式的。\nlibspeex是一个音频压缩库；\nModules就是TeamTalk中使用的各种库了，展开来看下你就明白了：\nnetwork是teamtalk使用的网络通信的代码，其实teamtalk pc端和服务器端使用的是同一套网络通信库，只不过如果服务器运行在linux下，其核心的IO复用模型是epoll，而pc客户端使用的IO复用模型是select；\nspeexdec 也是和ogg格式相关的编码和解码器；\nteamtalk是主程序入口工程；\nutility包含了teamtalk中用到的一些工具类工程，比如sqlite的包装接口、md5工具类等。\n除了上面介绍的一些库以外，程序还使用了sqlite库、谷歌protobuf库、日志库yaolog等。关于yaolog可参见http://blog.csdn.net/gemo/article/details/8499692，这个日志库比较有意思的地方是可以单独打印出网络通信中的字节流的二进制形式，推荐一下，效果如下图所示（位于win-client\\bin\\teamtalk\\Debug\\log\\socket.log文件中）：\n三、程序总体框架介绍 整个程序使用了mfc框架来做一个架子，而所有的窗口和对话框都使用的是duilib，关于duilib网上有很多资料，这里不介绍duilib细节的东西了。一个mfc程序框架，使用起来也很简单，就是定义一个类集成mfc的CWinApp类，并改写其InitInstance()方法，mfc内部会替我们做好消息循环的步骤。TeamTalk相关的代码如下：\n//位于teamtalk.h中 class CteamtalkApp : public CWinApp { public: CteamtalkApp(); public: virtual BOOL InitInstance(); virtual BOOL ExitInstance(); private: /** * 创建用户目录 * * @return BOOL * @exception there is no any exception to throw. */\tBOOL _CreateUsersFolder(); /** * 创建主窗口 * * @return BOOL * @exception there is no any exception to throw.",
  "keywords": [
    
  ],
  "articleBody": "11 pc客户端源码分析 ——写在前面的话\n在要不要写这篇文章的纠结中挣扎了好久，就我个人而已，我接触windows编程，已经六七个年头了，尤其是在我读研的三年内，基本心思都是花在学习和研究windows程序上了。我很庆幸我当初学习windows程序走了一条正确的路线：先是学习常用的windows程序原理和基本API，再学习的mfc、wtl等一些常用的框架和类库，同时看了大量windows项目的源码，如金山卫士的开源代码、filezilla、电驴源码等等。个人觉得，基础真的很重要，拿windows开发来说，当你掌握了windows的程序的基本原理，我列一下大致范围：\nwindows消息机制（消息如何产生、如何发送、如何处理，常见的消息有哪些、消息的优先级、如何自定义消息、窗体消息、常用控件消息）\ngdi原理（要熟悉gdi的各种对象，如画笔、画刷、字体、区域、裁剪、位图等，熟悉它们的API，熟悉各种gdi绘图API、当然最好也要熟悉一整套的gdi+的类，gdi与gdi+的区别）\nwindows进程与线程的概念（进程的概念、如何创建、如何结束、跨进程如何通信；线程的创建与销毁、线程间的同步与资源保护，熟悉windows常用的线程同步对象：临界区、事件、互斥体、信号量等）\nwindows内存管理（清晰地掌握一个进程地址空间的内存分布、windows堆的创建与管理等）\ndll技术（dll的生成、变量的导出、函数的导出、类的导出、如何查看dll导出哪些函数、隐式dll的加载、显示dll的加载、远程dll注入技术等）\nPE文件（一个PE文件的结构、有哪些节、如何修改、分别映射到进程地址空间的什么位置等）\nwindows SEH（结构化异常处理）\nwindows socket编程\nwindows读写文件技术（像CreateFile、WriteFile、GetFileSize等这些API应该熟练掌握、内存映射技术）\n当然很多必备的技术也不好归类到windows技术下面，比如socket编程，这涉及到很多网络的知识，比如tcp的三次握手，数据的收发等，还有就是各种字符编码的知识、以及之间的相互转换，又比如一系列的CRT函数及其对应的宽字符版本。当然如果你搞windows开发，一定要熟悉开发工具Visual Studio，熟悉其工程项目的大多数属性配置，而且要做到知其然也知其所以然。如果不是不能跨平台，我敢说VS是史上最好最强大的开发工具，没有之一！我已经有好几年年不做windows开发了，目前主要从事linux开发，但windows的很多设计思想真的很好，非常值得借鉴，而且从编码风格来说，虽然看起来有点怪异，但是非常规范和易懂。\n有了基础知识，你可以轻松地对工作中的一些问题给出解决方案，也能轻松阅读和使用市面上的那些库，比如，如果你深刻理解windows GDI，你不会在一个群里大喊，duilib某个属性为什么不起作用，你可以直接去阅读它的画法代码，如果是bug你可以改bug，如果只是你使用错误，你可以了解到正确的使用方法。所以基础这个东西，在短时间内，可能让你看不出与其他人的差别，但是从长远来看，它决定着你在技术上走的高度与深度。套用侯捷先生的一句话：勿在浮沙筑高台。\n—— 正题\n上面简单地介绍了下，我个人学习windows程序设计的一些心得吧。扯的有点远了，让我们回到正题上来，来分析TeamTalk的源码吧。当然这篇文章与前面介绍的不一样，我们不仅介绍程序的正题设计思路，还会介绍一些有意义的细节，比如一些windows开发中常用的一些细节。\n一、程序功能 我们来先看下TeamTalk pc客户端包括哪些功能：TeamTalk因为开发的初衷是用于企业内部的即时通讯软件，所以，不提供对外注册的功能，一个员工的加入一般是人事部门在后台管理系统来新增该员工信息。其功能包括登录、聊天、群聊和建讨论组，当然聊天过程中可以发文字、表情、图片和文件，还包括查看聊天记录和简单地查看某个员工的个人信息，业务功能其实不多的。下面是一些功能截图：\n二、编译方法与项目工程文件介绍 TeamTalk的pc客户端的下载地址是：https://github.com/baloonwj/TeamTalk 代码包括服务器端代码、pc端、mac端、安卓和IOS端，还有web端所有代码。\npc客户端代码的编译方法很简单：用VS2013打开win-client\\solution目录下的teamtalk.sln，编译即可。你的VS版本至少要是VS2013，因为代码中大量使用了C++11的东西，VS2013以下版本是不支持C++11的语法的。当然，如果你是VS2015的话，可以参考这篇文章来进行修改和编译：http://www.07net01.com/linux/2017/01/1795569.html\n打开teamtalk.sln之后，总共有10个解决方法，如下图所示：\n其中teamtalk是主工程，你应该将它设置成启动工程，编译完成之后就可以调试了。你可以自己配置服务器来连接进行调试，我也可以连接我的测试服务器，具体参见《TeamTalk源码分析（十） —— 开放一个TeamTalk测试服务器地址和几个测试账号》。下面先大致介绍一个各个工程的作用：\nDuilib是teamtalk使用的一款开源界面库，该界面库模仿web开发中的布局技术，使用xml文件来布局windows界面，并且在主窗口上绘制所有子控件，也就是所谓的directUI技术；\nGifSmiley是程序中用来解析和显示gif格式的图片的库，以支持gif图片的动画效果；\nhttpclient功能是程序中使用的http请求库，登录前程序会先连接服务器的login_server以获得后续需要登录的msg_server的ip地址和端口号 等信息，这里就是使用的http协议，同时聊天过程中收发的聊天图片与图片服务器msfs也使用http协议来收发这些图片；\nlibogg是一个语音库，用来解析声音文件的，因为pc客户端可能会收到移动端的语音聊天，相比较传统的*.wav、.mp3、.wma，*.ogg格式的不仅音质高，而且音频文件的体积小，腾讯的QQ游戏英雄杀中的语音也是使用这个格式的。\nlibspeex是一个音频压缩库；\nModules就是TeamTalk中使用的各种库了，展开来看下你就明白了：\nnetwork是teamtalk使用的网络通信的代码，其实teamtalk pc端和服务器端使用的是同一套网络通信库，只不过如果服务器运行在linux下，其核心的IO复用模型是epoll，而pc客户端使用的IO复用模型是select；\nspeexdec 也是和ogg格式相关的编码和解码器；\nteamtalk是主程序入口工程；\nutility包含了teamtalk中用到的一些工具类工程，比如sqlite的包装接口、md5工具类等。\n除了上面介绍的一些库以外，程序还使用了sqlite库、谷歌protobuf库、日志库yaolog等。关于yaolog可参见http://blog.csdn.net/gemo/article/details/8499692，这个日志库比较有意思的地方是可以单独打印出网络通信中的字节流的二进制形式，推荐一下，效果如下图所示（位于win-client\\bin\\teamtalk\\Debug\\log\\socket.log文件中）：\n三、程序总体框架介绍 整个程序使用了mfc框架来做一个架子，而所有的窗口和对话框都使用的是duilib，关于duilib网上有很多资料，这里不介绍duilib细节的东西了。一个mfc程序框架，使用起来也很简单，就是定义一个类集成mfc的CWinApp类，并改写其InitInstance()方法，mfc内部会替我们做好消息循环的步骤。TeamTalk相关的代码如下：\n//位于teamtalk.h中 class CteamtalkApp : public CWinApp { public: CteamtalkApp(); public: virtual BOOL InitInstance(); virtual BOOL ExitInstance(); private: /** * 创建用户目录 * * @return BOOL * @exception there is no any exception to throw. */\tBOOL _CreateUsersFolder(); /** * 创建主窗口 * * @return BOOL * @exception there is no any exception to throw. */\tBOOL _CreateMainDialog(); /** * 销毁主窗口 * * @return BOOL * @exception there is no any exception to throw. */ BOOL _DestroyMainDialog(); /** * 判断是否是单实例 * * @return BOOL * @exception there is no any exception to throw. */ BOOL _IsHaveInstance(); void _InitLog(); private: MainDialog*\tm_pMainDialog; }; 在teamtalk.cpp中定义了唯一的全局对象CteamtalkApp对象：\n接着，所有的初始化工作就是写在CteamtalkApp::InitInstance()方法中了：\nBOOL CteamtalkApp::InitInstance() { INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026InitCtrls); //log init _InitLog(); // Verify that the version of the library that we linked against is // compatible with the version of the headers we compiled against. GOOGLE_PROTOBUF_VERIFY_VERSION; LOG__(APP, _T(\"===================================VersionNO:%d======BulidTime：%s--%s==========================\") , TEAMTALK_VERSION, util::utf8ToCString(__DATE__), util::utf8ToCString(__TIME__)); if (!__super::InitInstance()) { LOG__(ERR, _T(\"__super::InitInstance failed.\")); return FALSE; } AfxEnableControlContainer(); //为了调试方便，暂且注释掉 //if (_IsHaveInstance()) //{ //\tLOG__(ERR, _T(\"Had one instance,this will exit\")); //\tHWND hwndMain = FindWindow(_T(\"TeamTalkMainDialog\"), NULL); //\tif (hwndMain) //\t{ //\t::SendMessage(hwndMain, WM_START_MOGUTALKINSTANCE, NULL, NULL); //\t} //\treturn FALSE; //} //start imcore lib //在这里启动任务队列和网络IO线程 if (!imcore::IMLibCoreRunEvent()) { LOG__(ERR, _T(\"start imcore lib failed!\")); } LOG__(APP, _T(\"start imcore lib done\")); //start ui event //在这里创建代理窗口并启动定时器定时处理任务 if (module::getEventManager()-\u003estartup() != imcore::IMCORE_OK) { LOG__(ERR, _T(\"start ui event failed\")); } LOG__(APP, _T(\"start ui event done\")); //create user folders _CreateUsersFolder(); //duilib初始化 CPaintManagerUI::SetInstance(AfxGetInstanceHandle()); CPaintManagerUI::SetResourcePath(CPaintManagerUI::GetInstancePath() + _T(\"..\\\\gui\\\\\"));//track这个设置了路径，会导致base里设置的无效。 ::CoInitialize(NULL); ::OleInitialize(NULL); //无需配置server module::TTConfig* pCfg = module::getSysConfigModule()-\u003egetSystemConfig(); if (pCfg \u0026\u0026 pCfg-\u003eloginServIP.IsEmpty()) { if (!module::getSysConfigModule()-\u003eshowServerConfigDialog(NULL)) { LOG__(APP, _T(\"server config canceled\")); return FALSE; } } if (!module::getLoginModule()-\u003eshowLoginDialog()) { LOG__(ERR, _T(\"login canceled\")); return FALSE; } LOG__(APP,_T(\"login success\")); //创建主窗口 if (!_CreateMainDialog()) { LOG__(ERR, _T(\"Create MianDialog failed\")); return FALSE; } LOG__(APP, _T(\"Create MianDialog done\")); CPaintManagerUI::MessageLoop(); CPaintManagerUI::Term(); return TRUE; } 上述代码大致做了以下工作：\n// 1. 初始化yaolog日志库 // 2. google protobuf的版本号检测 // 3. 启动网络通信线程检测网络数据读写，再启动一个线程创建一个队列，如果队列中有任务，则取出该任务执行 // 4. 创建支线程与UI线程的桥梁——代理窗口 // 5. 创建用户文件夹 // 6. 配置duilib的资源文件路径、初始化com库、初始化ole库 // 7. 如果没有配置登录服务器的地址，则显示配置对话框 // 8. 显示登录对话框 // 9. 登录成功后，登录对话框销毁，显示主对话框 // 10. 启动duilib的消息循环（也就是说不使用mfc的消息循环） 其它的没什么好介绍的，我们来重点介绍下第3点和第4点。先说第3点，在第3点中又会牵扯出第4点，网络通信线程的启动：\n//start imcore lib //在这里启动任务队列和网络IO线程 if (!imcore::IMLibCoreRunEvent()) { LOG__(ERR, _T(\"start imcore lib failed!\")); } LOG__(APP, _T(\"start imcore lib done\"));\tLOG__(ERR, _T(\"start imcore lib failed!\")); } LOG__(APP, _T(\"start imcore lib done\")); bool IMLibCoreRunEvent() {\tLOG__(NET, _T(\"===============================================================================\")); //在这里启动任务队列处理线程 getOperationManager()-\u003estartup(); CAutoLock lock(\u0026g_lock); if (!netlib_is_running()) { #ifdef _MSC_VER unsigned int m_dwThreadID; //在这里启动网络IO线程 g_hThreadHandle = (HANDLE)_beginthreadex(0, 0, event_run, 0, 0, (unsigned*)\u0026m_dwThreadID); if (g_hThreadHandle \u003c (HANDLE)2) { m_dwThreadID = 0; g_hThreadHandle = 0; } return g_hThreadHandle \u003e(HANDLE)1; #else pthread_t pt; pthread_create(\u0026pt, NULL, event_run, NULL); #endif } return true; } 先看getOperationManager()-\u003estartup();：\nIMCoreErrorCode OperationManager::startup() { m_operationThread = std::thread([\u0026] { std::unique_lock \u003cstd::mutex\u003e lck(m_cvMutex); Operation* pOperation = nullptr; while (m_bContinue) { if (!m_bContinue) break; if (m_vecRealtimeOperations.empty()) m_CV.wait(lck); if (!m_bContinue) break; { std::lock_guard\u003cstd::mutex\u003e lock(m_mutexOperation); if (m_vecRealtimeOperations.empty()) continue; pOperation = m_vecRealtimeOperations.front(); m_vecRealtimeOperations.pop_front(); } if (!m_bContinue) break; if (pOperation) { pOperation-\u003eprocess(); pOperation-\u003erelease(); } } }); return IMCORE_OK; } 这里利用一个C++11的新语法lamda表达式来创建一个线程，线程函数就是lamda表达式的具体内容：先从队列中取出任务，然后执行。所有的任务都继承其基类Operation，而Operation又继承接口类IOperatio，任务类根据自己具体需要做什么来改写process()方法：\nclass NETWORK_DLL Operation : public IOperation { enum OperationState { OPERATION_IDLE = 0, OPERATION_STARTING, OPERATION_RUNNING, OPERATION_CANCELLING, OPERATION_FINISHED }; public: /** @name Constructors and Destructor*/ //@{ /** * Constructor */ Operation(); Operation(const std::string\u0026 name); /** * Destructor */ virtual ~Operation(); //@} public: virtual void processOpertion() = 0; public: virtual void process(); virtual void release(); inline std::string name() const { return m_name; } inline void set_name(__in std::string name){ m_name = name; } private: OperationState\tm_state; std::string\tm_name; }; struct NETWORK_DLL IOperation { public: virtual void process() = 0; //private: /** * 必须让容器来释放自己 * * @return void * @exception there is no any exception to throw. */ virtual void release() = 0; }; 这里我们介绍的任务队列我们称为队列A，下文中还有一个专门做http请求的队列，我们称为队列B。\n后半部分代码其实就是启动网络检测线程，检测网络数据读写：\ng_hThreadHandle = (HANDLE)_beginthreadex(0, 0, event_run, 0, 0, (unsigned*)\u0026m_dwThreadID); unsigned int __stdcall event_run(void* threadArgu) { LOG__(NET, _T(\"event_run\")); netlib_init(); netlib_set_running(); netlib_eventloop(); return NULL; } void netlib_eventloop(uint32_t wait_timeout) { CEventDispatch::Instance()-\u003eStartDispatch(wait_timeout); } void CEventDispatch::StartDispatch(uint32_t wait_timeout) { fd_set read_set, write_set, excep_set; timeval timeout; timeout.tv_sec = 1;\t//wait_timeout 1 second timeout.tv_usec = 0; while (running) { //_CheckTimer(); //_CheckLoop(); if (!m_read_set.fd_count \u0026\u0026 !m_write_set.fd_count \u0026\u0026 !m_excep_set.fd_count) { Sleep(MIN_TIMER_DURATION); continue; } m_lock.lock(); FD_ZERO(\u0026read_set); FD_ZERO(\u0026write_set); FD_ZERO(\u0026excep_set); memcpy(\u0026read_set, \u0026m_read_set, sizeof(fd_set)); memcpy(\u0026write_set, \u0026m_write_set, sizeof(fd_set)); memcpy(\u0026excep_set, \u0026m_excep_set, sizeof(fd_set)); m_lock.unlock(); if (!running) break; //for (int i = 0; i \u003c read_set.fd_count; i++) { //\tLOG__(NET, \"read fd: %d\\n\", read_set.fd_array[i]); //} int nfds = select(0, \u0026read_set, \u0026write_set, \u0026excep_set, \u0026timeout); if (nfds == SOCKET_ERROR) { //LOG__(NET, \"select failed, error code: %d\\n\", GetLastError()); Sleep(MIN_TIMER_DURATION); continue;\t// select again } if (nfds == 0) { continue; } for (u_int i = 0; i \u003c read_set.fd_count; i++) { //LOG__(NET, \"select return read count=%d\\n\", read_set.fd_count); SOCKET fd = read_set.fd_array[i]; CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd); if (pSocket) { pSocket-\u003eOnRead(); pSocket-\u003eReleaseRef(); } } for (u_int i = 0; i \u003c write_set.fd_count; i++) { //LOG__(NET, \"select return write count=%d\\n\", write_set.fd_count); SOCKET fd = write_set.fd_array[i]; CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd); if (pSocket) { pSocket-\u003eOnWrite(); pSocket-\u003eReleaseRef(); } } for (u_int i = 0; i \u003c excep_set.fd_count; i++) { LOG__(NET, _T(\"select return exception count=%d\"), excep_set.fd_count); SOCKET fd = excep_set.fd_array[i]; CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd); if (pSocket) { pSocket-\u003eOnClose(); pSocket-\u003eReleaseRef(); } } } } 我们举个具体的例子来说明这个三个线程的逻辑（任务队列A、网络线程和下文要介绍的专门处理http请求的任务队列B）和代理窗口的消息队列，以在登录对话框输入用户名和密码后接下来的步骤：\n//位于LoginDialog.cpp中 void LoginDialog::_DoLogin() { LOG__(APP,_T(\"User Clicked LoginBtn\")); m_ptxtTip-\u003eSetText(_T(\"\")); CDuiString userName = m_pedtUserName-\u003eGetText(); CDuiString password = m_pedtPassword-\u003eGetText(); if (userName.IsEmpty()) { CString csTip = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_USERNAME_EMPTY\")); m_ptxtTip-\u003eSetText(csTip); return; } if (password.IsEmpty()) { CString csTip = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_PASSWORD_EMPTY\")); m_ptxtTip-\u003eSetText(csTip); return; } module::TTConfig* pCfg = module::getSysConfigModule()-\u003egetSystemConfig(); pCfg-\u003euserName = userName; if (m_bPassChanged) { std::string sPass = util::cStringToString(CString(password)); char* pOutData = 0; uint32_t nOutLen = 0; int retCode = EncryptPass(sPass.c_str(), sPass.length(), \u0026pOutData, nOutLen); if (retCode == 0 \u0026\u0026 nOutLen \u003e 0 \u0026\u0026 pOutData != 0) { pCfg-\u003epassword = std::string(pOutData, nOutLen); Free(pOutData); } else { LOG__(ERR, _T(\"EncryptPass Failed!\")); CString csTip = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_LOGIN_ENCRYPT_PASE_FAIL\")); m_ptxtTip-\u003eSetText(csTip);\treturn; } } pCfg-\u003eisRememberPWD = m_pChkRememberPWD-\u003eGetCheck(); module::getSysConfigModule()-\u003esaveData(); CString csTxt = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_BTN_DOLOGIN\")); m_pBtnLogin-\u003eSetText(csTxt); m_pBtnLogin-\u003eSetEnabled(false); //连接登陆服务器 DoLoginServerParam param; DoLoginServerHttpOperation* pOper = new DoLoginServerHttpOperation( BIND_CALLBACK_1(LoginDialog::OnHttpCallbackOperation), param); module::getHttpPoolModule()-\u003epushHttpOperation(pOper); } 点击登录按钮之后，程序先对用户名和密码进行一些有效性校验，接着产生一个DoLoginServerHttpOperation对象，该类继承IHttpOperation，IHttpOperation再继承ICallbackOpertaion，ICallbackOpertaion再继承Operation类。这个任务会绑定一个任务完成之后的回调函数，即宏BIND_CALLBACK_1，这个宏实际上就是std::bind：\n#define BIND_CALLBACK_1(func) std::bind(\u0026func, this, placeholders::_1) #define BIND_CALLBACK_2(func)\tstd::bind(\u0026func, this, placeholders::_1, placeholders::_2) 往任务队列中放入任务的动作如下：\nvoid HttpPoolModule_Impl::pushHttpOperation(module::IHttpOperation* pOperaion, BOOL bHighPriority /*= FALSE*/) { if (NULL == pOperaion) { return; } CAutoLock lock(\u0026m_mtxLock); if (bHighPriority) m_lstHttpOpers.push_front(pOperaion); else m_lstHttpOpers.push_back(pOperaion); _launchThread(); ::ReleaseSemaphore(m_hSemaphore, 1, NULL); return; } 其中_launchThread()会启动一个线程，该线程函数是另外一个任务队列，专门处理http任务：\nBOOL HttpPoolModule_Impl::_launchThread() { if ((int)m_vecHttpThread.size() \u003e= MAX_THEAD_COUNT) { return TRUE; } TTHttpThread* pThread = new TTHttpThread(); PTR_FALSE(pThread); if (!pThread-\u003ecreate()) { return FALSE; } Sleep(300); m_vecHttpThread.push_back(pThread); return TRUE; } 线程函数最终实际执行代码如下：\nUInt32 TTHttpThread::process() { module::IHttpOperation * pHttpOper = NULL; HttpPoolModule_Impl *pPool = m_pInstance; while (m_bContinue) { if (WAIT_OBJECT_0 != ::WaitForSingleObject(pPool-\u003em_hSemaphore, INFINITE)) { break; } if (!m_bContinue) { break; } { CAutoLock lock(\u0026(pPool-\u003em_mtxLock)); if (pPool-\u003em_lstHttpOpers.empty()) pHttpOper = NULL; else { pHttpOper = pPool-\u003em_lstHttpOpers.front(); pPool-\u003em_lstHttpOpers.pop_front(); } } try { if (m_bContinue \u0026\u0026 pHttpOper) { pHttpOper-\u003eprocess(); pHttpOper-\u003erelease(); } } catch (...) { LOG__(ERR, _T(\"TTHttpThread: Failed to execute opertaion(0x%p)\"), pHttpOper); } } return 0; } 当这个http任务被任务队列执行时，实际执行DoLoginServerHttpOperation::processOpertion()，代码如下：\nvoid DoLoginServerHttpOperation::processOpertion() { module::TTConfig* pCfg = module::getSysConfigModule()-\u003egetSystemConfig(); LOG__(APP, _T(\"loginAddr = %s\"), pCfg-\u003eloginServIP); std::string\u0026 loginAddr = util::cStringToString(pCfg-\u003eloginServIP); std::string url = loginAddr; DoLoginServerParam* pPamram = new DoLoginServerParam(); pPamram-\u003eresMsg = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_LOGIN_HTTP_DEFERROR\")); Http::HttpResponse\tresponse; Http::HttpClient\tclient; //对于登录：url=http://192.168.226.128:8080/msg_server Http::HttpRequest\trequest(\"get\", url); if (!client.execute(\u0026request, \u0026response)) { CString csTemp = util::stringToCString(url); pPamram-\u003eresult = DOLOGIN_FAIL; LOG__(ERR,_T(\"failed %s\"), csTemp); asyncCallback(std::shared_ptr\u003cvoid\u003e(pPamram)); client.killSelf(); return; } /** { \"backupIP\" : \"localhost\", \"code\" : 0, \"discovery\" : \"http://127.0.0.1/api/discovery\", \"msfsBackup\" : \"http://127.0.0.1:8700/\", \"msfsPrior\" : \"http://127.0.0.1:8700/\", \"msg\" : \"\", \"port\" : \"8000\", \"priorIP\" : \"localhost\" } */ std::string body = response.getBody(); client.killSelf(); //json解析 try { Json::Reader reader; Json::Value root; if (!reader.parse(body, root)) { CString csTemp = util::stringToCString(body); LOG__(ERR, _T(\"parse data failed,%s\"), csTemp); pPamram-\u003eresult = DOLOGIN_FAIL; pPamram-\u003eresMsg = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_LOGIN_HTTP_JSONERROR\")); goto End; } int nCode = root.get(\"code\", \"\").asInt(); if (0 == nCode)//登陆成功 { LOG__(APP, _T(\"get msgSvr IP succeed!\")); pCfg-\u003emsgSevPriorIP = root.get(\"priorIP\", \"\").asString(); pCfg-\u003emsgSevBackupIP = root.get(\"backupIP\", \"\").asString(); std::string strPort = root.get(\"port\", \"\").asString(); pCfg-\u003emsgServPort = util::stringToInt32(strPort); pCfg-\u003efileSysAddr = util::stringToCString(root.get(\"msfsPrior\", \"\").asString()); pCfg-\u003efileSysBackUpAddr = util::stringToCString(root.get(\"msfsBackup\", \"\").asString()); pPamram-\u003eresult = DOLOGIN_SUCC; } else { LOG__(ERR, _T(\"get msgSvr IP failed! Code = %d\"),nCode); pPamram-\u003eresult = DOLOGIN_FAIL; CString csRetMsgTemp = util::stringToCString(root.get(\"msg\", \"\").asString()); if (!csRetMsgTemp.IsEmpty()) pPamram-\u003eresMsg = csRetMsgTemp; } } catch (...) { CString csTemp = util::stringToCString(body); LOG__(ERR,_T(\"parse json execption,%s\"), csTemp); pPamram-\u003eresult = DOLOGIN_FAIL; pPamram-\u003eresMsg = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_LOGIN_HTTP_JSONERROR\")); } End: asyncCallback(std::shared_ptr\u003cvoid\u003e(pPamram)); } 实际上是向login_server发送一个http请求，这是一个同步请求。得到的结果是一个json字符串，代码注释中已经给出。然后调用asyncCallback(std::shared_ptr(pPamram));参数pPamram携带了当前任务的回调函数指针：\n/** * 异步回调，借助UIEvent * * @param std::shared_ptr param * @return void * @exception there is no any exception to throw. */ void asyncCallback(std::shared_ptr\u003cvoid\u003e param) { CallbackOperationEvent* pEvent = new CallbackOperationEvent(m_callback, param); module::getEventManager()-\u003easynFireUIEvent(pEvent); } 这实际上产生了一个回调事件。也就是说队列B做http请求，操作完成后往代理窗口的消息队列中放入一个回调事件，这个事件通过代理窗口过程函数来处理的（这就是上文中第4点介绍的代理窗口过程的作用，实际上是利用windows消息队列来做任务处理（系统有现成的任务队列系统，为何不利用呢？））：\nmodule::IMCoreErrorCode UIEventManager::asynFireUIEvent(IN const IEvent* const pEvent) { assert(m_hWnd); assert(pEvent); if (0 == m_hWnd || 0 == pEvent) return IMCORE_ARGUMENT_ERROR; if (FALSE == ::PostMessage(m_hWnd, UI_EVENT_MSG, reinterpret_cast\u003cWPARAM\u003e(this), reinterpret_cast\u003cWPARAM\u003e(pEvent))) return IMCORE_WORK_POSTMESSAGE_ERROR; return IMCORE_OK; } 看到没有？向代理窗口的消息队列中投递一个UI_EVENT_MSG事件，并在消息参数LPARAM中传递了回调事件的对象指针。这样代理窗口过程函数就可以处理这个消息了：\nLRESULT _stdcall UIEventManager::_WindowProc(HWND hWnd , UINT message , WPARAM wparam , LPARAM lparam) { switch (message) { case UI_EVENT_MSG: reinterpret_cast\u003cUIEventManager*\u003e(wparam)-\u003e_processEvent(reinterpret_cast\u003cIEvent*\u003e(lparam), TRUE); break; case WM_TIMER: reinterpret_cast\u003cUIEventManager*\u003e(wparam)-\u003e_processTimer(); break; default: break; } return ::DefWindowProc(hWnd, message, wparam, lparam); } void UIEventManager::_processEvent(IEvent* pEvent, BOOL bRelease) { assert(pEvent); if (0 == pEvent) return; try { pEvent-\u003eprocess(); if (bRelease) pEvent-\u003erelease(); } catch (imcore::Exception *e) { LOG__(ERR, _T(\"event run exception\")); pEvent-\u003eonException(e); if (bRelease) pEvent-\u003erelease(); if (e) { LOG__(ERR, _T(\"event run exception:%s\"), util::stringToCString(e-\u003em_msg)); assert(FALSE); } } catch (...) { LOG__(ERR, _T(\"operation run exception,unknown reason\")); if (bRelease) pEvent-\u003erelease(); assert(FALSE); } } 根据C++的多态特性，pEvent-\u003eprocess()实际上调用的是CallbackOperationEvent.process()。代码如下：\nvirtual void process() { m_callback(m_param); } m_callback(m_param);调用的就是上文中介绍DoLoginServerHttpOperation操作的回调函数LoginDialog::OnHttpCallbackOperation()：\nvoid LoginDialog::OnHttpCallbackOperation(std::shared_ptr\u003cvoid\u003e param) { DoLoginServerParam* pParam = (DoLoginServerParam*)param.get(); if (DOLOGIN_SUCC == pParam-\u003eresult) { module::TTConfig* pCfg = module::getSysConfigModule()-\u003egetSystemConfig(); PTR_VOID(pCfg); LoginParam loginparam; loginparam.csUserName = pCfg-\u003euserName; loginparam.password = pCfg-\u003epassword; loginparam.csUserName.Trim(); LoginOperation* pOperation = new LoginOperation( BIND_CALLBACK_1(LoginDialog::OnOperationCallback), loginparam); imcore::IMLibCoreStartOperation(pOperation); } else { m_ptxtTip-\u003eSetText(pParam-\u003eresMsg); module::TTConfig* pCfg = module::getSysConfigModule()-\u003egetSystemConfig(); LOG__(ERR, _T(\"get MsgServer config faild,login server addres:%s:%d\"), pCfg-\u003eloginServIP,pCfg-\u003eloginServPort); CString csTxt = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_BTN_LOGIN\")); m_pBtnLogin-\u003eSetText(csTxt); m_pBtnLogin-\u003eSetEnabled(true); } } ok，终于到家了。但是这并没结束，我们只介绍了队列B和代理窗口消息队列，还有队列A呢？LoginDialog::OnHttpCallbackOperation()会根据获取的msg_server的情况来再次产生一个新的任务LoginOperation来放入队列A中，这次才是真正的用户登录，根据上面的介绍，LoginOperation任务从队列A中取出来之后，实际执行的是LoginOperation::processOpertion()：\nvoid LoginOperation::processOpertion() { LOG__(APP,_T(\"login start,uname:%s,status:%d\"), m_loginParam.csUserName , m_loginParam.mySelectedStatus); LoginParam* pParam = new LoginParam; pParam-\u003ecsUserName = m_loginParam.csUserName; pParam-\u003emySelectedStatus = m_loginParam.mySelectedStatus; //连接消息服务器 module::TTConfig* pCfg = module::getSysConfigModule()-\u003egetSystemConfig(); CString server = util::stringToCString(pCfg-\u003emsgSevPriorIP); LOG__(APP, _T(\"MsgServeIp:%s,Port:%d\"), server, pCfg-\u003emsgServPort); //8000端口 IM::Login::IMLoginRes* pImLoginResp = (IM::Login::IMLoginRes*)module::getTcpClientModule() -\u003edoLogin(server, pCfg-\u003emsgServPort,m_loginParam.csUserName,m_loginParam.password); if (0 == pImLoginResp || pImLoginResp-\u003eresult_code() != IM::BaseDefine::REFUSE_REASON_NONE || !pImLoginResp-\u003ehas_user_info()) { //TODO,若失败，尝试备用IP LOG__(ERR,_T(\"add:%s:%d,uname:%s,login for msg server failed\"),server,pCfg-\u003emsgServPort, m_loginParam.csUserName); if (pImLoginResp) { CString errInfo = util::stringToCString(pImLoginResp-\u003eresult_string()); pParam-\u003eerrInfo = errInfo; pParam-\u003eresult = LOGIN_FAIL; pParam-\u003eserver_result = pImLoginResp-\u003eresult_code(); LOG__(ERR, _T(\"error code :%d,error info:%s\"), pImLoginResp-\u003eresult_code(), errInfo); } else { pParam-\u003eresult = IM::BaseDefine::REFUSE_REASON_NO_MSG_SERVER; LOG__(ERR, _T(\"login msg server faild！\")); } asyncCallback(std::shared_ptr\u003cvoid\u003e(pParam)); return; } pParam-\u003eresult = LOGIN_OK; pParam-\u003eserverTime = pImLoginResp-\u003eserver_time(); pParam-\u003emySelectedStatus = pImLoginResp-\u003eonline_status(); //存储服务器端返回的userId IM::BaseDefine::UserInfo userInfo = pImLoginResp-\u003euser_info(); pCfg-\u003euserId = util::uint32ToString(userInfo.user_id()); pCfg-\u003ecsUserId = util::stringToCString(pCfg-\u003euserId); //登陆成功，创建自己的信息 module::UserInfoEntity myInfo; myInfo.sId = pCfg-\u003euserId; myInfo.csName = m_loginParam.csUserName; myInfo.onlineState = IM::BaseDefine::USER_STATUS_ONLINE; myInfo.csNickName = util::stringToCString(userInfo.user_nick_name()); myInfo.avatarUrl = userInfo.avatar_url(); myInfo.dId = util::uint32ToString(userInfo.department_id()); myInfo.department = myInfo.dId; myInfo.email = userInfo.email(); myInfo.gender = userInfo.user_gender(); myInfo.user_domain = userInfo.user_domain(); myInfo.telephone = userInfo.user_tel(); myInfo.status = userInfo.status(); myInfo.signature = userInfo.sign_info(); module::getUserListModule()-\u003ecreateUserInfo(myInfo); asyncCallback(std::shared_ptr\u003cvoid\u003e(pParam)); LOG__(APP, _T(\"login succeed! Name = %s Nickname = %s sId = %s status = %d\") , m_loginParam.csUserName , util::stringToCString(userInfo.user_nick_name()) , module::getSysConfigModule()-\u003eUserID() , m_loginParam.mySelectedStatus); //开始发送心跳包 module::getTcpClientModule()-\u003estartHeartbeat(); } 同理，数据包发生成功以后，会再往代理窗口的消息队列中产生一个回调事件，最终调用刚才说的LoginOperation绑定的回调函数：\nvoid asyncCallback(std::shared_ptr\u003cvoid\u003e param) { CallbackOperationEvent* pEvent = new CallbackOperationEvent(m_callback, param); module::getEventManager()-\u003easynFireUIEvent(pEvent); } void LoginDialog::OnOperationCallback(std::shared_ptr\u003cvoid\u003e param) { LoginParam* pLoginParam = (LoginParam*)param.get(); if (LOGIN_OK == pLoginParam-\u003eresult)\t//登陆成功 { Close(IDOK); //创建用户目录 _CreateUsersFolder(); //开启同步消息时间timer module::getSessionModule()-\u003estartSyncTimeTimer(); module::getSessionModule()-\u003esetTime(pLoginParam-\u003eserverTime); //通知服务器客户端初始化完毕,获取组织架构信息和群列表 module::getLoginModule()-\u003enotifyLoginDone(); } else\t//登陆失败处理 { module::getTcpClientModule()-\u003eshutdown(); if (IM::BaseDefine::REFUSE_REASON_NO_MSG_SERVER == pLoginParam-\u003eserver_result) { CString csTip = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_LOGIN_MSGSVR_FAIL\")); m_ptxtTip-\u003eSetText(csTip); } else if (!pLoginParam-\u003eerrInfo.IsEmpty()) { m_ptxtTip-\u003eSetText(pLoginParam-\u003eerrInfo); } else { CString errorCode = util::int32ToCString(pLoginParam-\u003eserver_result); CString csTip = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_LOGIN_UNKNOWN_ERROR\")); m_ptxtTip-\u003eSetText(csTip + CString(\":\") + errorCode); } } CString csTxt = util::getMultilingual()-\u003egetStringById(_T(\"STRID_LOGINDIALOG_BTN_LOGIN\")); m_pBtnLogin-\u003eSetText(csTxt); m_pBtnLogin-\u003eSetEnabled(true); } 至此，登录才成功。等等，那数据包是怎么发到服务器的呢？这也是一个重点，我们来详细地介绍一下，LoginOperation::processOpertion()中有这一行代码：\ndoLogin函数代码如下：\nIM::Login::IMLoginRes* TcpClientModule_Impl::doLogin(CString \u0026linkaddr, UInt16 port ,CString\u0026 uName,std::string\u0026 pass) { m_socketHandle = imcore::IMLibCoreConnect(util::cStringToString(linkaddr), port); imcore::IMLibCoreRegisterCallback(m_socketHandle, this); if(util::waitSingleObject(m_eventConnected, 5000)) { IM::Login::IMLoginReq imLoginReq; string\u0026 name = util::cStringToString(uName); imLoginReq.set_user_name(name); imLoginReq.set_password(pass); imLoginReq.set_online_status(IM::BaseDefine::USER_STATUS_ONLINE); imLoginReq.set_client_type(IM::BaseDefine::CLIENT_TYPE_WINDOWS); imLoginReq.set_client_version(\"win_10086\"); if (TCPCLIENT_STATE_OK != m_tcpClientState) return 0; sendPacket(IM::BaseDefine::SID_LOGIN, IM::BaseDefine::CID_LOGIN_REQ_USERLOGIN, ++g_seqNum , \u0026imLoginReq); m_pImLoginResp-\u003eClear(); util::waitSingleObject(m_eventReceived, 10000); } return m_pImLoginResp; } 这段代码先连接服务器，然后调用sendPacket()发送登录数据包。如何连接服务器使用了一些“奇技淫巧”，我们后面单独介绍。我们这里先来看sendPacket()发包代码：\nvoid TcpClientModule_Impl::sendPacket(UInt16 moduleId, UInt16 cmdId, UInt16 seq, google::protobuf::MessageLite* pbBody) { m_TTPBHeader.clear(); m_TTPBHeader.setModuleId(moduleId); m_TTPBHeader.setCommandId(cmdId); m_TTPBHeader.setSeqNumber(seq); _sendPacket(pbBody); } void TcpClientModule_Impl::_sendPacket(google::protobuf::MessageLite* pbBody) { UInt32 length = imcore::HEADER_LENGTH + pbBody-\u003eByteSize(); m_TTPBHeader.setLength(length); std::unique_ptr\u003cbyte\u003e data(new byte[length]); memset(data.get(), 0, length); memcpy(data.get(), m_TTPBHeader.getSerializeBuffer(), imcore::HEADER_LENGTH); if (!pbBody-\u003eSerializeToArray(data.get() + imcore::HEADER_LENGTH, pbBody-\u003eByteSize())) { LOG__(ERR, _T(\"pbBody SerializeToArray failed\")); return; } imcore::IMLibCoreWrite(m_socketHandle, data.get(), length); } 其实就是序列化成protobuf要求的格式，然后调用imcore::IMLibCoreWrite(m_socketHandle, data.get(), length);发出去：\nint IMLibCoreWrite(int key, uchar_t* data, uint32_t size) { int nRet = -1; int nHandle = key; CImConn* pConn = TcpSocketsManager::getInstance()-\u003eget_client_conn(nHandle); if (pConn) { pConn-\u003eSend((void*)data, size); } else { LOG__(NET, _T(\"connection is invalied:%d\"), key); } return nRet; } 先尝试着直接发送，如果目前tcp窗口太小发不出去，则暂且将数据放在发送缓冲区里面，并检测socket可写事件。这里就是和服务器一样的网络库的代码了，前面一系列的文章，我们已经介绍过了。\nint CImConn::Send(void* data, int len) { if (m_busy) { m_out_buf.Write(data, len); return len; } int offset = 0; int remain = len; while (remain \u003e 0) { int send_size = remain; if (send_size \u003e NETLIB_MAX_SOCKET_BUF_SIZE) { send_size = NETLIB_MAX_SOCKET_BUF_SIZE; } int ret = netlib_send(m_handle, (char*)data + offset, send_size); if (ret \u003c= 0) { ret = 0; break; } offset += ret; remain -= ret; } if (remain \u003e 0) { m_out_buf.Write((char*)data + offset, remain); m_busy = true; LOG__(NET, _T(\"send busy, remain=%d\"), m_out_buf.GetWriteOffset()); } return len; } 数据发出去以后，服务器应答登录包，网络线程会检测到socket可读事件：\nvoid CBaseSocket::OnRead() { if (m_state == SOCKET_STATE_LISTENING) { _AcceptNewSocket(); } else { u_long avail = 0; if ( (ioctlsocket(m_socket, FIONREAD, \u0026avail) == SOCKET_ERROR) || (avail == 0) ) { m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL); } else { m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL); } } } void imconn_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam) { NOTUSED_ARG(handle); NOTUSED_ARG(pParam); CImConn* pConn = TcpSocketsManager::getInstance()-\u003eget_client_conn(handle); if (!pConn) { //LOG__(NET, _T(\"connection is invalied:%d\"), handle); return; } pConn-\u003eAddRef(); //\tLOG__(NET, \"msg=%d, handle=%d\\n\", msg, handle); switch (msg) { case NETLIB_MSG_CONFIRM: pConn-\u003eonConnect(); break; case NETLIB_MSG_READ: pConn-\u003eOnRead(); break; case NETLIB_MSG_WRITE: pConn-\u003eOnWrite(); break; case NETLIB_MSG_CLOSE: pConn-\u003eOnClose(); break; default: LOG__(NET, _T(\"!!!imconn_callback error msg: %d\"), msg); break; } pConn-\u003eReleaseRef(); } void CImConn::OnRead() { for (;;) { uint32_t free_buf_len = m_in_buf.GetAllocSize() - m_in_buf.GetWriteOffset(); if (free_buf_len \u003c READ_BUF_SIZE) m_in_buf.Extend(READ_BUF_SIZE); int ret = netlib_recv(m_handle, m_in_buf.GetBuffer() + m_in_buf.GetWriteOffset(), READ_BUF_SIZE); if (ret \u003c= 0) break; m_in_buf.IncWriteOffset(ret); while (m_in_buf.GetWriteOffset() \u003e= imcore::HEADER_LENGTH) { uint32_t len = m_in_buf.GetWriteOffset(); uint32_t length = CByteStream::ReadUint32(m_in_buf.GetBuffer()); if (length \u003e len) break; try { imcore::TTPBHeader pbHeader; pbHeader.unSerialize((byte*)m_in_buf.GetBuffer(), imcore::HEADER_LENGTH); LOG__(NET, _T(\"OnRead moduleId:0x%x,commandId:0x%x\"), pbHeader.getModuleId(), pbHeader.getCommandId()); if (m_pTcpSocketCB) m_pTcpSocketCB-\u003eonReceiveData((const char*)m_in_buf.GetBuffer(), length); LOGBIN_F__(SOCK, \"OnRead\", m_in_buf.GetBuffer(), length); } catch (std::exception\u0026 ex) { assert(FALSE); LOGA__(NET, \"std::exception,info:%s\", ex.what()); if (m_pTcpSocketCB) m_pTcpSocketCB-\u003eonReceiveError(); } catch (...) { assert(FALSE); LOG__(NET, _T(\"unknown exception\")); if (m_pTcpSocketCB) m_pTcpSocketCB-\u003eonReceiveError(); } m_in_buf.Read(NULL, length); } } } 收取数据，并解包：\nvoid TcpClientModule_Impl::onReceiveData(const char* data, int32_t size) { if (m_pServerPingTimer) m_pServerPingTimer-\u003em_bHasReceivedPing = TRUE; imcore::TTPBHeader header; header.unSerialize((byte*)data, imcore::HEADER_LENGTH);\tif (IM::BaseDefine::CID_OTHER_HEARTBEAT == header.getCommandId() \u0026\u0026 IM::BaseDefine::SID_OTHER == header.getModuleId()) { //模块器端过来的心跳包，不跳到业务层派发 return; } LOG__(NET, _T(\"receiveData message moduleId:0x%x,commandId:0x%x\") , header.getModuleId(), header.getCommandId()); if (g_seqNum == header.getSeqNumber()) { m_pImLoginResp-\u003eParseFromArray(data + imcore::HEADER_LENGTH, size - imcore::HEADER_LENGTH); ::SetEvent(m_eventReceived); return; } //将网络包包装成任务放到逻辑任务队列里面去 _handlePacketOperation(data, size); } void TcpClientModule_Impl::_handlePacketOperation(const char* data, UInt32 size) { std::string copyInBuffer(data, size); imcore::IMLibCoreStartOperationWithLambda( [=]() { imcore::TTPBHeader header; header.unSerialize((byte*)copyInBuffer.data(),imcore::HEADER_LENGTH); module::IPduPacketParse* pModule = (module::IPduPacketParse*)__getModule(header.getModuleId()); if (!pModule) { assert(FALSE); LOG__(ERR, _T(\"module is null, moduleId:%d,commandId:%d\") , header.getModuleId(), header.getCommandId()); return; } std::string pbBody(copyInBuffer.data() + imcore::HEADER_LENGTH, size - imcore::HEADER_LENGTH); pModule-\u003eonPacket(header, pbBody); }); } 根据不同的命令号来做相应的处理：\nvoid UserListModule_Impl::onPacket(imcore::TTPBHeader\u0026 header, std::string\u0026 pbBody) { switch (header.getCommandId()) { case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE: _recentlistResponse(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_STATUS_NOTIFY: _userStatusNotify(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_USER_INFO_RESPONSE: _usersInfoResponse(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_REMOVE_SESSION_RES: _removeSessionResponse(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_ALL_USER_RESPONSE: _allUserlistResponse(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_USERS_STATUS_RESPONSE: _usersLineStatusResponse(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE: _changeAvatarResponse(pbBody); break; case IM::BaseDefine::CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY: _removeSessionNotify(pbBody); break; case IM::BaseDefine::CID_BUDDY_LIST_DEPARTMENT_RESPONSE: _departmentResponse(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY: _avatarChangeNotify(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE: _changeSignInfoResponse(pbBody); break; case IM::BaseDefine::BuddyListCmdID::CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY: _signInfoChangedNotify(pbBody); break; default: LOG__(ERR, _T(\"Unknow commandID:%d\"), header.getCommandId()); return; } } 每一个处理分支，都最终会产生一个事件放入代理窗口的消息队列中。这前面已经介绍过了。这里我不得不说一点，teamtalk对于其它数据包的应答都是走的上面的介绍的流程，但是对于登录的应答却是使用了一些特殊处理。听我慢慢道来：\n上文中发送了登录数据包之后，在那里等一个事件10秒钟，如果10秒内这个事件有信号，则认为登录成功。那么什么情况该事件会有信号呢？\n该事件在构造函数里面创建，默认无信号：\n当网络线程收到数据以后（上文逻辑流中介绍过了）：\n除了心跳包直接过滤以外，通过一个序列号（Seq，变量g_seqNum）唯一标识了登录数据包的应答，如果收到这个序列号的数据，则置信m_eventReceived。这样等待在那里的登录流程就可以返回了，同时也得到了登录应答，登录应答数据记录在成员变量m_pImLoginResp中。如果是其它的数据包，则走的流程是_handlePacketOperation(data, size);，处理逻辑上文也介绍了。\n至此，整个客户端程序结构就介绍完了，我们总结一下，实际上程序有如下几类线程：\n网络事件检测线程，用于接收和发送网络数据；\nhttp任务处理线程用于处理http操作；\n普通的任务处理线程，用于处理一般性的任务，比如登录；\nUI线程，界面逻辑处理，同时在UI线程里面有一个代理窗口的窗口过程函数，用于非UI线程与UI线程之间的数据流和逻辑中转，核心是利用PostMessage往代理线程投递事件，事件消息参数携带任务信息。\n至于，像聊天、查看用户信息这些业务性的内容，留给有兴趣的读者自己去研究吧。\n四、程序中使用的一些比较有意思的技巧摘录 唯一实例判断 很多程序只能启动一个实例，当你再次启动某个程序的实例时，会激活前一个实例，其实实现起来很简单，就是新建一个命名的Mutex，因为Mutex可以跨进程，当再次启动程序实例时，创建同名的Mutex，会无法创建，错误信息是已经存在。这是windows上非常常用的技巧，如果你从事windows开发，请你务必掌握它。看teamtalk的实现：\n#ifdef _DEBUG #define AppSingletonMutex _T(\"{7A666640-EDB3-44CC-954B-0C43F35A2E17}\") #else #define AppSingletonMutex _T(\"{5676532A-6F70-460D-A1F0-81D6E68F046A}\") #endif BOOL CteamtalkApp::_IsHaveInstance() { // 单实例运行 HANDLE hMutex = ::CreateMutex(NULL, TRUE, AppSingletonMutex); if (hMutex != NULL \u0026\u0026 GetLastError() == ERROR_ALREADY_EXISTS) { MessageBox(0, _T(\"上次程序运行还没完全退出，请稍后再启动！\"), _T(\"TeamTalk\"), MB_OK); return TRUE; } return FALSE; } socket函数connect()连接等待时长设定 传统的做法是将socket设置为非阻塞的，调用完connect函数之后，调用select函数检测socket是否可写，在select函数里面设置超时时间。代码如下：\n//为了调试方便，暂且注释掉 int ret = ::connect(m_hSocket, (struct sockaddr*)\u0026addrSrv, sizeof(addrSrv)); if (ret == 0) { m_bConnected = TRUE; return TRUE; } if (ret == SOCKET_ERROR \u0026\u0026 WSAGetLastError() != WSAEWOULDBLOCK) { return FALSE; } fd_set writeset; FD_ZERO(\u0026writeset); FD_SET(m_hSocket, \u0026writeset); struct timeval tv = { timeout, 0 }; if (::select(m_hSocket + 1, NULL, \u0026writeset, NULL, \u0026tv) != 1) { return FALSE; } return TRUE; 我们看看teamtalk里面怎么做的：\n​\n红色箭头的地方调用connect函数连接服务器，然后绿色的箭头等待一个事件有信号（内部使用WaitForSingleObject函数），那事件什么时候有信号呢？\n网络线程检测第一次到socket可写时，调用onConnectDone函数：\n实际做的事情还是和上面介绍的差不多。其实对于登录流程做成同步的，也是和这个类似，上文中我们介绍过。我早些年刚做windows网络通信方面的项目时，开始总是找不到好的处理等待登录请求应答的方法。这里是一种很不错的设置超时等待的方法。\nteamtalk的截图功能 不知道，你在使用qq这样的截图工具时，QQ截图工具能自动检测出某个窗口的范围。这个功能在teamtalk中也有实现，实现代码如下：\nBOOL ScreenCapture::initCapture(__in HWND hWnd) { //register hot key const std::wstring screenCaptureHotkeyName = L\"_SCREEN_CAPTURE_HOTKEY\"; int iHotkeyId = (int)GlobalAddAtom(screenCaptureHotkeyName.c_str()); if (!RegisterHotKey(hWnd, iHotkeyId, MOD_CONTROL | MOD_SHIFT, 0x51)) //ctrl + shift + Q { GlobalDeleteAtom(iHotkeyId); } m_iHotkeyId = iHotkeyId; m_hRegisterHotkeyWnd = hWnd; return createMsgWindow(); } 程序初始化时，注册截屏快捷键，这里是ctrl+shift+Q（QQ默认是ctrl+alt+A）。当点击截屏按钮之后，开始启动截图：\nHWND hDesktopWnd = GetDesktopWindow(); HDC hScreenDC = GetDC(hDesktopWnd); RECT rc = { 0 }; GetWindowRect(hDesktopWnd, \u0026rc); int cx = rc.right - rc.left; int cy = rc.bottom - rc.top; HBITMAP hBitmap = CreateCompatibleBitmap(hScreenDC, cx, cy); m_hMemDC = CreateCompatibleDC(hScreenDC); HGDIOBJ hOldBitmap = SelectObject(m_hMemDC, (HGDIOBJ)hBitmap); BitBlt(m_hMemDC, 0, 0, cx, cy, hScreenDC, 0, 0, SRCCOPY); m_hBkgMemDC = CreateCompatibleDC(hScreenDC); HBITMAP hBkgBitmap = CreateCompatibleBitmap(hScreenDC, cx, cy); SelectObject(m_hBkgMemDC, (HGDIOBJ)hBkgBitmap); BitBlt(m_hBkgMemDC, 0, 0, cx, cy, hScreenDC, 0, 0, SRCCOPY); HDC hMaskDC = CreateCompatibleDC(hScreenDC); HBITMAP hMaskBitmap = CreateCompatibleBitmap(hScreenDC, cx, cy); SelectObject(hMaskDC, (HGDIOBJ)hMaskBitmap); BLENDFUNCTION ftn = { AC_SRC_OVER, 0, 100, 0}; AlphaBlend(m_hBkgMemDC, 0, 0, cx, cy, hMaskDC, 0, 0, cx, cy, ftn); DeleteObject(hMaskBitmap); DeleteDC(hMaskDC); m_hDrawMemDC = CreateCompatibleDC(hScreenDC); HBITMAP hDrawBitmap = CreateCompatibleBitmap(hScreenDC, cx, cy); SelectObject(m_hDrawMemDC, hDrawBitmap); ReleaseDC(hDesktopWnd, hScreenDC); 实际上就是在桌面窗口上画图。再遍历当前所有有显示区域的窗口，并记录这些窗口的窗口句柄和矩形区域：\nfor (HWND hWnd = GetTopWindow(NULL); NULL != hWnd; hWnd = GetWindow(hWnd, GW_HWNDNEXT)) { if (!IsWindow(hWnd) || !IsWindowVisible(hWnd) || IsIconic(hWnd)) { continue; } RECT rcWnd = { 0 }; GetWindowRect(hWnd, \u0026rcWnd); adjustRectInScreen(rcWnd); if (ScreenCommon::isRectEmpty(rcWnd)) { continue; } wchar_t szTxt[MAX_PATH] = { 0 }; GetWindowText(hWnd, szTxt, MAX_PATH); if (wcslen(szTxt) \u003c= 0) { continue; } //combine the rect with the screen rect m_lsWndList.push_back(ScreenCaptureWndInfo(hWnd, rcWnd)); } return m_lsWndList.size() \u003e 0; 然后显示一个截图工具：\nBOOL UIScreenCaptureMgr::createWindows() { m_hBkgUI = BkgroundUI::Instance()-\u003ecreateWindow(); wchar_t szImg[MAX_PATH] = {0}; GetModuleFileName(NULL, szImg, MAX_PATH); PathRemoveFileSpec(szImg); PathRemoveFileSpec(szImg); std::wstring strBkgPic = std::wstring(szImg) + L\"\\\\gui\\\\ScreenCapture\\\\sc_toolbar_normal.png\"; std::wstring strHoverPic = std::wstring(szImg) + L\"\\\\gui\\\\ScreenCapture\\\\sc_toolbar_hover.png\"; std::wstring strSelPic = std::wstring(szImg) + L\"\\\\gui\\\\ScreenCapture\\\\sc_toolbar_select.png\"; EditToolbarInfo toolBarInfo = { 0, 0, 193, 37, strBkgPic, strHoverPic, strSelPic, { { 9, 5, 35, 31 }, { 43, 5, 69, 31 }, { 85, 5, 112, 31 }, { 119, 5, 185, 31 } } }; m_hEditToolBarUI = EditToolbarUI::Instance()-\u003ecreateWindow(toolBarInfo, m_hBkgUI); SetWindowPos(m_hBkgUI, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE); forceForgroundWindow(m_hBkgUI); ShowWindow(m_hBkgUI, SW_SHOW); return TRUE; } 然后安装一个消息钩子（hook）：\nBOOL ScreenCapture::installMsgHook(BOOL bInstall) { BOOL result = FALSE; if (bInstall) { if (!m_hMouseHook) { m_hMouseHook = SetWindowsHookEx(WH_MOUSE, MouseProc, NULL, GetCurrentThreadId()); result = (NULL != m_hMouseHook); } } else { UnhookWindowsHookEx(m_hMouseHook); m_hMouseHook = NULL; result = TRUE; } return result; } LRESULT ScreenCapture::MouseProc(_In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam) { PMOUSEHOOKSTRUCT pHookInfo = (PMOUSEHOOKSTRUCT)lParam; int xPos = pHookInfo-\u003ept.x; int yPos = pHookInfo-\u003ept.y; LRESULT lResHandled = CallNextHookEx(ScreenCapture::getInstance()-\u003egetMouseHook(), nCode, wParam, lParam); if (WM_LBUTTONDBLCLK == wParam ) { ScreenCommon::postNotifyMessage(WM_SNAPSHOT_FINISH_CAPTURE, 0, 0); } else if (WM_RBUTTONDBLCLK == wParam) { ScreenCommon::postNotifyMessage(WM_SNAPSHOT_CANCEL_CPATURE, 0, 0); } else if (WM_LBUTTONDOWN == wParam) { if (CM_AUTO_SELECT == CaptureModeMgr::Instance()-\u003egetMode()) { CaptureModeMgr::Instance()-\u003echangeMode(CM_MANAL_SELECT); } } CaptureModeMgr::Instance()-\u003ehandleMouseMsg(wParam, xPos, yPos); return lResHandled; } 在钩子函数中，如果出现鼠标双击事件，则表示取消截图；如果出现双击事件，则表示完成截图。如果鼠标按下则表示开始绘制截图区域，然后处理鼠标移动事件：\nvoid CaptureModeMgr::handleMouseMsg(__in UINT uMsg, __in int xPos, __in int yPos) { IModeMsgHandler *msgHandler = getModeHandler(); if (!msgHandler) return; if (WM_MOUSEMOVE == uMsg) { msgHandler-\u003eonMouseMove(xPos, yPos); } else if (WM_LBUTTONDOWN == uMsg) { msgHandler-\u003eonLButtonDown(xPos, yPos); } else if (WM_LBUTTONUP == uMsg) { msgHandler-\u003eonLButtonUp(xPos, yPos); } else if (WM_LBUTTONDBLCLK == uMsg) { msgHandler-\u003eonLButtonDBClick(xPos, yPos); } } 选取区域结束时，将选择的区域保存为位图并存至某个路径下：\nvoid ScreenCapture::finishCapture() { RECT rcSelect = {0}; UIScreenCaptureMgr::Instance()-\u003esendBkgMessage(WM_SNAPSHOT_TEST_SELECT_RECT, (WPARAM)\u0026rcSelect, 0); rcSelect.left += 2; rcSelect.top += 2; rcSelect.right -= 2; rcSelect.bottom -= 2; if (!ScreenCommon::isRectEmpty(rcSelect)) { ScreenSnapshot::Instance()-\u003esaveRect(rcSelect, m_strSavePath); } cancelCapture(); if (m_callBack) m_callBack-\u003eonScreenCaptureFinish(m_strSavePath); }\tRECT rcSelect = {0}; UIScreenCaptureMgr::Instance()-\u003esendBkgMessage(WM_SNAPSHOT_TEST_SELECT_RECT, (WPARAM)\u0026rcSelect, 0); rcSelect.left += 2; rcSelect.top += 2; rcSelect.right -= 2; rcSelect.bottom -= 2; if (!ScreenCommon::isRectEmpty(rcSelect)) { ScreenSnapshot::Instance()-\u003esaveRect(rcSelect, m_strSavePath); } cancelCapture(); if (m_callBack) m_callBack-\u003eonScreenCaptureFinish(m_strSavePath); } BOOL ScreenSnapshot::saveRect(__in RECT \u0026rc, __in std::wstring \u0026savePath) { snapshotScreen(); CxImage img; int cx = rc.right - rc.left; int cy = rc.bottom - rc.top; HDC hSaveDC = CreateCompatibleDC(m_hMemDC); HBITMAP hBitmap = CreateCompatibleBitmap(m_hMemDC, cx, cy); HBITMAP hSaveBitmap = (HBITMAP)SelectObject(hSaveDC, (HGDIOBJ)hBitmap); BitBlt(hSaveDC, 0, 0, cx, cy, m_hMemDC, rc.left, rc.top, SRCCOPY); hBitmap = (HBITMAP)SelectObject(hSaveDC, (HBITMAP)hSaveBitmap); BOOL result = FALSE; do { if (!img.CreateFromHBITMAP(hBitmap)) { break; } if (!img.Save(savePath.c_str(), CXIMAGE_FORMAT_BMP)) { break; } result = TRUE; } while (FALSE); DeleteObject((HGDIOBJ)hBitmap); DeleteDC(hSaveDC); return result; } 注意整个过程使用了一个神奇的windows API，你没看错，它叫mouse_event，很少有windows API长成这个样子。利用这个api可以用程序模拟鼠标很多事件，后面有时间我会专门介绍一下这个有用的API函数。当然，关于截图的描述，你可能有点迷糊。没关系，后面我会专门写一篇文章细致地探究下teamtalk的屏幕截图效果实现，因为这里面有价值的东西很多。\n线程的创建 IMCoreErrorCode OperationManager::startup() { m_operationThread = std::thread([\u0026] { std::unique_lock \u003cstd::mutex\u003e lck(m_cvMutex); Operation* pOperation = nullptr; while (m_bContinue) { if (!m_bContinue) break; if (m_vecRealtimeOperations.empty()) m_CV.wait(lck); if (!m_bContinue) break; { std::lock_guard\u003cstd::mutex\u003e lock(m_mutexOperation); if (m_vecRealtimeOperations.empty()) continue; pOperation = m_vecRealtimeOperations.front(); m_vecRealtimeOperations.pop_front(); } if (!m_bContinue) break; if (pOperation) { pOperation-\u003eprocess(); pOperation-\u003erelease(); } } }); return IMCORE_OK; } 这是利用lamda表达式创建一个线程典型的语法，其中m_operationThread是一个成员变量，类型是std::thread，std::thread([\u0026]中括号中的\u0026符号表示该lamda表达式以引用的方式捕获了所有外部的自动变量，这是在一个成员函数里面，也就是说在线程函数里面可以以引用的方式使用该类的所有成员变量。这个语法值得大家学习。\nteamtalk的httpclient工程可以直接拿来使用，作者主页：http://xiangwangfeng.com，github链接：https://github.com/xiangwangfeng/httpclient。 另外teamtalk pc端大量使用C++11的语法和一些替代原来平常的写法，这个就不专门列出来了，后面我将会专门写一篇文章来介绍C++11中那些好用的工程级技巧。\n好了，这篇文章就到此为止了。限于作者水平有限，文中难免有错漏和不足，欢迎批评指正。 ",
  "wordCount" : "3212",
  "inLanguage": "en",
  "datePublished": "2021-01-11T09:20:42Z",
  "dateModified": "2021-01-11T09:20:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://haokiu.com/ee4c77c4daf64f5f821d76808ec0b8b3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "haokiu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://haokiu.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://haokiu.com/">Home</a>&nbsp;»&nbsp;<a href="https://haokiu.com/1/">1s</a></div>
    <h1 class="post-title">
      11 pc客户端源码分析
    </h1>
    <div class="post-meta"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#11-pc%e5%ae%a2%e6%88%b7%e7%ab%af%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" aria-label="11 pc客户端源码分析">11 pc客户端源码分析</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e4%b8%80%e7%a8%8b%e5%ba%8f%e5%8a%9f%e8%83%bd" aria-label="一、程序功能">一、程序功能</a></li>
                <li>
                    <a href="#%e4%ba%8c%e7%bc%96%e8%af%91%e6%96%b9%e6%b3%95%e4%b8%8e%e9%a1%b9%e7%9b%ae%e5%b7%a5%e7%a8%8b%e6%96%87%e4%bb%b6%e4%bb%8b%e7%bb%8d" aria-label="二、编译方法与项目工程文件介绍">二、编译方法与项目工程文件介绍</a></li>
                <li>
                    <a href="#%e4%b8%89%e7%a8%8b%e5%ba%8f%e6%80%bb%e4%bd%93%e6%a1%86%e6%9e%b6%e4%bb%8b%e7%bb%8d" aria-label="三、程序总体框架介绍">三、程序总体框架介绍</a></li>
                <li>
                    <a href="#%e5%9b%9b%e7%a8%8b%e5%ba%8f%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%9a%84%e4%b8%80%e4%ba%9b%e6%af%94%e8%be%83%e6%9c%89%e6%84%8f%e6%80%9d%e7%9a%84%e6%8a%80%e5%b7%a7%e6%91%98%e5%bd%95" aria-label="四、程序中使用的一些比较有意思的技巧摘录">四、程序中使用的一些比较有意思的技巧摘录</a>
                </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="11-pc客户端源码分析">11 pc客户端源码分析</h1>
<p><strong>——写在前面的话</strong></p>
<p>在要不要写这篇文章的纠结中挣扎了好久，就我个人而已，我接触windows编程，已经六七个年头了，尤其是在我读研的三年内，基本心思都是花在学习和研究windows程序上了。我很庆幸我当初学习windows程序走了一条正确的路线：先是学习常用的windows程序原理和基本API，再学习的mfc、wtl等一些常用的框架和类库，同时看了大量windows项目的源码，如金山卫士的开源代码、filezilla、电驴源码等等。个人觉得，基础真的很重要，拿windows开发来说，当你掌握了windows的程序的基本原理，我列一下大致范围：</p>
<ol>
<li>
<p>windows消息机制（消息如何产生、如何发送、如何处理，常见的消息有哪些、消息的优先级、如何自定义消息、窗体消息、常用控件消息）</p>
</li>
<li>
<p>gdi原理（要熟悉gdi的各种对象，如画笔、画刷、字体、区域、裁剪、位图等，熟悉它们的API，熟悉各种gdi绘图API、当然最好也要熟悉一整套的gdi+的类，gdi与gdi+的区别）</p>
</li>
<li>
<p>windows进程与线程的概念（进程的概念、如何创建、如何结束、跨进程如何通信；线程的创建与销毁、线程间的同步与资源保护，熟悉windows常用的线程同步对象：临界区、事件、互斥体、信号量等）</p>
</li>
<li>
<p>windows内存管理（清晰地掌握一个进程地址空间的内存分布、windows堆的创建与管理等）</p>
</li>
<li>
<p>dll技术（dll的生成、变量的导出、函数的导出、类的导出、如何查看dll导出哪些函数、隐式dll的加载、显示dll的加载、远程dll注入技术等）</p>
</li>
<li>
<p>PE文件（一个PE文件的结构、有哪些节、如何修改、分别映射到进程地址空间的什么位置等）</p>
</li>
<li>
<p>windows SEH（结构化异常处理）</p>
</li>
<li>
<p>windows socket编程</p>
</li>
<li>
<p>windows读写文件技术（像CreateFile、WriteFile、GetFileSize等这些API应该熟练掌握、内存映射技术）</p>
</li>
</ol>
<p>当然很多必备的技术也不好归类到windows技术下面，比如socket编程，这涉及到很多网络的知识，比如tcp的三次握手，数据的收发等，还有就是各种字符编码的知识、以及之间的相互转换，又比如一系列的CRT函数及其对应的宽字符版本。当然如果你搞windows开发，一定要熟悉开发工具Visual Studio，熟悉其工程项目的大多数属性配置，而且要做到知其然也知其所以然。如果不是不能跨平台，我敢说VS是史上最好最强大的开发工具，没有之一！我已经有好几年年不做windows开发了，目前主要从事linux开发，但windows的很多设计思想真的很好，非常值得借鉴，而且从编码风格来说，虽然看起来有点怪异，但是非常规范和易懂。</p>
<p>有了基础知识，你可以轻松地对工作中的一些问题给出解决方案，也能轻松阅读和使用市面上的那些库，比如，如果你深刻理解windows GDI，你不会在一个群里大喊，duilib某个属性为什么不起作用，你可以直接去阅读它的画法代码，如果是bug你可以改bug，如果只是你使用错误，你可以了解到正确的使用方法。所以基础这个东西，在短时间内，可能让你看不出与其他人的差别，但是从长远来看，它决定着你在技术上走的高度与深度。套用侯捷先生的一句话：勿在浮沙筑高台。</p>
<p><strong>—— 正题</strong></p>
<p>上面简单地介绍了下，我个人学习windows程序设计的一些心得吧。扯的有点远了，让我们回到正题上来，来分析TeamTalk的源码吧。当然这篇文章与前面介绍的不一样，我们不仅介绍程序的正题设计思路，还会介绍一些有意义的细节，比如一些windows开发中常用的一些细节。</p>
<h3 id="一程序功能">一、程序功能</h3>
<p>我们来先看下TeamTalk pc客户端包括哪些功能：TeamTalk因为开发的初衷是用于企业内部的即时通讯软件，所以，不提供对外注册的功能，一个员工的加入一般是人事部门在后台管理系统来新增该员工信息。其功能包括登录、聊天、群聊和建讨论组，当然聊天过程中可以发文字、表情、图片和文件，还包括查看聊天记录和简单地查看某个员工的个人信息，业务功能其实不多的。下面是一些功能截图：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/9abe83afc234a08f8404e72d0ab2c20e.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/8e1837eae83ec24dc42e7e32a9a09bf3.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/01908ace09cf8199861ddc8ef3f240e1.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/d1eb35a1a76764b4ef5d7bb38c71a1ba.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/cce3c3c60c8d12390d950ac33c333195.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/de010fd412f2506c7e95f08643694ced.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/39e9d850d1c1982bb7163721718821b9.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<h3 id="二编译方法与项目工程文件介绍">二、编译方法与项目工程文件介绍</h3>
<ol>
<li>TeamTalk的pc客户端的下载地址是：https://github.com/baloonwj/TeamTalk</li>
</ol>
<p>代码包括服务器端代码、pc端、mac端、安卓和IOS端，还有web端所有代码。</p>
<p>pc客户端代码的编译方法很简单：用VS2013打开win-client\solution目录下的teamtalk.sln，编译即可。你的VS版本至少要是VS2013，因为代码中大量使用了C++11的东西，VS2013以下版本是不支持C++11的语法的。当然，如果你是VS2015的话，可以参考这篇文章来进行修改和编译：http://www.07net01.com/linux/2017/01/1795569.html</p>
<p>打开teamtalk.sln之后，总共有10个解决方法，如下图所示：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/d2b410437199a139a3e5b22dd52c3ede.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>其中teamtalk是主工程，你应该将它设置成启动工程，编译完成之后就可以调试了。你可以自己配置服务器来连接进行调试，我也可以连接我的测试服务器，具体参见<a href="http://blog.csdn.net/analogous_love/article/details/72723704">《TeamTalk源码分析（十） —— 开放一个TeamTalk测试服务器地址和几个测试账号》</a>。下面先大致介绍一个各个工程的作用：</p>
<ol>
<li>
<p>Duilib是teamtalk使用的一款开源界面库，该界面库模仿web开发中的布局技术，使用xml文件来布局windows界面，并且在主窗口上绘制所有子控件，也就是所谓的directUI技术；</p>
</li>
<li>
<p>GifSmiley是程序中用来解析和显示gif格式的图片的库，以支持gif图片的动画效果；</p>
</li>
<li>
<p>httpclient功能是程序中使用的http请求库，登录前程序会先连接服务器的login_server以获得后续需要登录的msg_server的ip地址和端口号 等信息，这里就是使用的http协议，同时聊天过程中收发的聊天图片与图片服务器msfs也使用http协议来收发这些图片；</p>
</li>
<li>
<p>libogg是一个语音库，用来解析声音文件的，因为pc客户端可能会收到移动端的语音聊天，相比较传统的*.wav、<em>.mp3、</em>.wma，*.ogg格式的不仅音质高，而且音频文件的体积小，腾讯的QQ游戏英雄杀中的语音也是使用这个格式的。</p>
</li>
<li>
<p>libspeex是一个音频压缩库；</p>
</li>
<li>
<p>Modules就是TeamTalk中使用的各种库了，展开来看下你就明白了：</p>
</li>
</ol>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/c03c8f2a86e641a2352392cd578e4f4c.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<ol start="7">
<li>
<p>network是teamtalk使用的网络通信的代码，其实teamtalk pc端和服务器端使用的是同一套网络通信库，只不过如果服务器运行在linux下，其核心的IO复用模型是epoll，而pc客户端使用的IO复用模型是select；</p>
</li>
<li>
<p>speexdec 也是和ogg格式相关的编码和解码器；</p>
</li>
<li>
<p>teamtalk是主程序入口工程；</p>
</li>
<li>
<p>utility包含了teamtalk中用到的一些工具类工程，比如sqlite的包装接口、md5工具类等。</p>
</li>
</ol>
<p>除了上面介绍的一些库以外，程序还使用了sqlite库、谷歌protobuf库、日志库yaolog等。关于yaolog可参见http://blog.csdn.net/gemo/article/details/8499692，这个日志库比较有意思的地方是可以单独打印出网络通信中的字节流的二进制形式，推荐一下，效果如下图所示（位于win-client\bin\teamtalk\Debug\log\socket.log文件中）：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/2ee9a862ca6635ebc550911ef326fa27.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<h3 id="三程序总体框架介绍">三、程序总体框架介绍</h3>
<p>整个程序使用了mfc框架来做一个架子，而所有的窗口和对话框都使用的是duilib，关于duilib网上有很多资料，这里不介绍duilib细节的东西了。一个mfc程序框架，使用起来也很简单，就是定义一个类集成mfc的CWinApp类，并改写其InitInstance()方法，mfc内部会替我们做好消息循环的步骤。TeamTalk相关的代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//位于teamtalk.h中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CteamtalkApp</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> CWinApp
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	CteamtalkApp();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> BOOL InitInstance();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> BOOL <span style="color:#a6e22e">ExitInstance</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  创建用户目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @return  BOOL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @exception there is no any exception to throw.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>	
</span></span><span style="display:flex;"><span>	BOOL _CreateUsersFolder();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * 创建主窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @return  BOOL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @exception there is no any exception to throw.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>	
</span></span><span style="display:flex;"><span>	BOOL <span style="color:#a6e22e">_CreateMainDialog</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* 销毁主窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @return  BOOL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @exception there is no any exception to throw.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>	BOOL <span style="color:#a6e22e">_DestroyMainDialog</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* 判断是否是单实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @return  BOOL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @exception there is no any exception to throw.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>	BOOL <span style="color:#a6e22e">_IsHaveInstance</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_InitLog</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	MainDialog<span style="color:#f92672">*</span>						m_pMainDialog;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在teamtalk.cpp中定义了唯一的全局对象CteamtalkApp对象：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/9305e7fb0e183176daebc109dd8d385e.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>接着，所有的初始化工作就是写在CteamtalkApp::InitInstance()方法中了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL CteamtalkApp<span style="color:#f92672">::</span>InitInstance()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	INITCOMMONCONTROLSEX InitCtrls;
</span></span><span style="display:flex;"><span>	InitCtrls.dwSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(InitCtrls);
</span></span><span style="display:flex;"><span>	InitCtrls.dwICC <span style="color:#f92672">=</span> ICC_WIN95_CLASSES;
</span></span><span style="display:flex;"><span>	InitCommonControlsEx(<span style="color:#f92672">&amp;</span>InitCtrls);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//log init
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	_InitLog();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Verify that the version of the library that we linked against is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// compatible with the version of the headers we compiled against.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	GOOGLE_PROTOBUF_VERIFY_VERSION;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;===================================VersionNO:%d======BulidTime：%s--%s==========================&#34;</span>)
</span></span><span style="display:flex;"><span>		, TEAMTALK_VERSION, util<span style="color:#f92672">::</span>utf8ToCString(__DATE__), util<span style="color:#f92672">::</span>utf8ToCString(__TIME__));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>__super<span style="color:#f92672">::</span>InitInstance())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;__super::InitInstance failed.&#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	AfxEnableControlContainer();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//为了调试方便，暂且注释掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//if (_IsHaveInstance())
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	LOG__(ERR, _T(&#34;Had one instance,this will exit&#34;));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	HWND hwndMain = FindWindow(_T(&#34;TeamTalkMainDialog&#34;), NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	if (hwndMain)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//		::SendMessage(hwndMain, WM_START_MOGUTALKINSTANCE, NULL, NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//	return FALSE;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//start imcore lib
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//在这里启动任务队列和网络IO线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>imcore<span style="color:#f92672">::</span>IMLibCoreRunEvent())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;start imcore lib failed!&#34;</span>));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;start imcore lib done&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//start ui event
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//在这里创建代理窗口并启动定时器定时处理任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (module<span style="color:#f92672">::</span>getEventManager()<span style="color:#f92672">-&gt;</span>startup() <span style="color:#f92672">!=</span> imcore<span style="color:#f92672">::</span>IMCORE_OK)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;start ui event failed&#34;</span>));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;start ui event done&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//create user folders
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	_CreateUsersFolder();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//duilib初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	CPaintManagerUI<span style="color:#f92672">::</span>SetInstance(AfxGetInstanceHandle());
</span></span><span style="display:flex;"><span>	CPaintManagerUI<span style="color:#f92672">::</span>SetResourcePath(CPaintManagerUI<span style="color:#f92672">::</span>GetInstancePath() <span style="color:#f92672">+</span> _T(<span style="color:#e6db74">&#34;..</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">gui</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span>));<span style="color:#75715e">//track这个设置了路径，会导致base里设置的无效。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#f92672">::</span>CoInitialize(NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">::</span>OleInitialize(NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//无需配置server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	module<span style="color:#f92672">::</span>TTConfig<span style="color:#f92672">*</span> pCfg <span style="color:#f92672">=</span> module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>getSystemConfig();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pCfg <span style="color:#f92672">&amp;&amp;</span> pCfg<span style="color:#f92672">-&gt;</span>loginServIP.IsEmpty())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>showServerConfigDialog(NULL))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			LOG__(APP, _T(<span style="color:#e6db74">&#34;server config canceled&#34;</span>));
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>module<span style="color:#f92672">::</span>getLoginModule()<span style="color:#f92672">-&gt;</span>showLoginDialog())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;login canceled&#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	LOG__(APP,_T(<span style="color:#e6db74">&#34;login success&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//创建主窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_CreateMainDialog())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;Create MianDialog failed&#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;Create MianDialog done&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CPaintManagerUI<span style="color:#f92672">::</span>MessageLoop();
</span></span><span style="display:flex;"><span>	CPaintManagerUI<span style="color:#f92672">::</span>Term();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码大致做了以下工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 1. 初始化yaolog日志库
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2. google protobuf的版本号检测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3. 启动网络通信线程检测网络数据读写，再启动一个线程创建一个队列，如果队列中有任务，则取出该任务执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 4. 创建支线程与UI线程的桥梁——代理窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 5. 创建用户文件夹
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 6. 配置duilib的资源文件路径、初始化com库、初始化ole库 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 7. 如果没有配置登录服务器的地址，则显示配置对话框
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 8. 显示登录对话框
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 9. 登录成功后，登录对话框销毁，显示主对话框
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 10. 启动duilib的消息循环（也就是说不使用mfc的消息循环）
</span></span></span></code></pre></div><p>其它的没什么好介绍的，我们来重点介绍下第3点和第4点。先说第3点，在第3点中又会牵扯出第4点，网络通信线程的启动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//start imcore lib
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//在这里启动任务队列和网络IO线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>imcore<span style="color:#f92672">::</span>IMLibCoreRunEvent())
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	LOG__(ERR, _T(<span style="color:#e6db74">&#34;start imcore lib failed!&#34;</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LOG__(APP, _T(<span style="color:#e6db74">&#34;start imcore lib done&#34;</span>));	LOG__(ERR, _T(<span style="color:#e6db74">&#34;start imcore lib failed!&#34;</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LOG__(APP, _T(<span style="color:#e6db74">&#34;start imcore lib done&#34;</span>));
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">IMLibCoreRunEvent</span>()
</span></span><span style="display:flex;"><span>{	
</span></span><span style="display:flex;"><span>	LOG__(NET, _T(<span style="color:#e6db74">&#34;===============================================================================&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//在这里启动任务队列处理线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	getOperationManager()<span style="color:#f92672">-&gt;</span>startup();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CAutoLock lock(<span style="color:#f92672">&amp;</span>g_lock);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>netlib_is_running())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _MSC_VER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> m_dwThreadID;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//在这里启动网络IO线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		g_hThreadHandle <span style="color:#f92672">=</span> (HANDLE)_beginthreadex(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, event_run, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, (<span style="color:#66d9ef">unsigned</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>m_dwThreadID);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (g_hThreadHandle <span style="color:#f92672">&lt;</span> (HANDLE)<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_dwThreadID <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			g_hThreadHandle <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> g_hThreadHandle <span style="color:#f92672">&gt;</span>(HANDLE)<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		pthread_t pt;
</span></span><span style="display:flex;"><span>		pthread_create(<span style="color:#f92672">&amp;</span>pt, NULL, event_run, NULL);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>先看getOperationManager()-&gt;startup();：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>IMCoreErrorCode OperationManager<span style="color:#f92672">::</span>startup()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_operationThread <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>([<span style="color:#f92672">&amp;</span>]
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>unique_lock <span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lck(m_cvMutex);
</span></span><span style="display:flex;"><span>		Operation<span style="color:#f92672">*</span> pOperation <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (m_bContinue)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_bContinue)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (m_vecRealtimeOperations.empty())
</span></span><span style="display:flex;"><span>				m_CV.wait(lck);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_bContinue)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(m_mutexOperation);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (m_vecRealtimeOperations.empty())
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>				pOperation <span style="color:#f92672">=</span> m_vecRealtimeOperations.front();
</span></span><span style="display:flex;"><span>				m_vecRealtimeOperations.pop_front();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_bContinue)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pOperation)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pOperation<span style="color:#f92672">-&gt;</span>process();
</span></span><span style="display:flex;"><span>				pOperation<span style="color:#f92672">-&gt;</span>release();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> IMCORE_OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里利用一个C++11的新语法lamda表达式来创建一个线程，线程函数就是lamda表达式的具体内容：先从队列中取出任务，然后执行。所有的任务都继承其基类Operation，而Operation又继承接口类IOperatio，任务类根据自己具体需要做什么来改写process()方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NETWORK_DLL</span> Operation : <span style="color:#66d9ef">public</span> IOperation
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">OperationState</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		OPERATION_IDLE <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>		OPERATION_STARTING,
</span></span><span style="display:flex;"><span>		OPERATION_RUNNING,
</span></span><span style="display:flex;"><span>		OPERATION_CANCELLING,
</span></span><span style="display:flex;"><span>		OPERATION_FINISHED
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** @name Constructors and Destructor*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Constructor 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    Operation();
</span></span><span style="display:flex;"><span>	Operation(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> name);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Destructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Operation();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> processOpertion() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> process();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">release</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> std<span style="color:#f92672">::</span>string name() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> m_name; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_name</span>(__in std<span style="color:#f92672">::</span>string name){ m_name <span style="color:#f92672">=</span> name; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	OperationState			m_state;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string				m_name;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NETWORK_DLL</span> IOperation
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> process() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//private:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* 必须让容器来释放自己
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @return  void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @exception there is no any exception to throw.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">release</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>这里我们介绍的任务队列我们称为队列A，下文中还有一个专门做http请求的队列，我们称为队列B。</p>
<p>后半部分代码其实就是启动网络检测线程，检测网络数据读写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>g_hThreadHandle <span style="color:#f92672">=</span> (HANDLE)_beginthreadex(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, event_run, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, (<span style="color:#66d9ef">unsigned</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>m_dwThreadID);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">event_run</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> threadArgu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	LOG__(NET,  _T(<span style="color:#e6db74">&#34;event_run&#34;</span>));
</span></span><span style="display:flex;"><span>	netlib_init();
</span></span><span style="display:flex;"><span>	netlib_set_running();
</span></span><span style="display:flex;"><span>	netlib_eventloop();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">netlib_eventloop</span>(<span style="color:#66d9ef">uint32_t</span> wait_timeout)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CEventDispatch<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>StartDispatch(wait_timeout);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CEventDispatch<span style="color:#f92672">::</span>StartDispatch(<span style="color:#66d9ef">uint32_t</span> wait_timeout)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	fd_set read_set, write_set, excep_set;
</span></span><span style="display:flex;"><span>	timeval timeout;
</span></span><span style="display:flex;"><span>	timeout.tv_sec <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;	<span style="color:#75715e">//wait_timeout 1 second
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	timeout.tv_usec <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (running)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//_CheckTimer();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//_CheckLoop();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_read_set.fd_count <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>m_write_set.fd_count <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>m_excep_set.fd_count)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			Sleep(MIN_TIMER_DURATION);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_lock.lock();
</span></span><span style="display:flex;"><span>		FD_ZERO(<span style="color:#f92672">&amp;</span>read_set);
</span></span><span style="display:flex;"><span>		FD_ZERO(<span style="color:#f92672">&amp;</span>write_set);
</span></span><span style="display:flex;"><span>		FD_ZERO(<span style="color:#f92672">&amp;</span>excep_set);
</span></span><span style="display:flex;"><span>		memcpy(<span style="color:#f92672">&amp;</span>read_set, <span style="color:#f92672">&amp;</span>m_read_set, <span style="color:#66d9ef">sizeof</span>(fd_set));
</span></span><span style="display:flex;"><span>		memcpy(<span style="color:#f92672">&amp;</span>write_set, <span style="color:#f92672">&amp;</span>m_write_set, <span style="color:#66d9ef">sizeof</span>(fd_set));
</span></span><span style="display:flex;"><span>		memcpy(<span style="color:#f92672">&amp;</span>excep_set, <span style="color:#f92672">&amp;</span>m_excep_set, <span style="color:#66d9ef">sizeof</span>(fd_set));
</span></span><span style="display:flex;"><span>		m_lock.unlock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>running)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//for (int i = 0; i &lt; read_set.fd_count; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//	LOG__(NET,  &#34;read fd: %d\n&#34;, read_set.fd_array[i]);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> nfds <span style="color:#f92672">=</span> select(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>read_set, <span style="color:#f92672">&amp;</span>write_set, <span style="color:#f92672">&amp;</span>excep_set, <span style="color:#f92672">&amp;</span>timeout);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (nfds <span style="color:#f92672">==</span> SOCKET_ERROR)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//LOG__(NET,  &#34;select failed, error code: %d\n&#34;, GetLastError());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			Sleep(MIN_TIMER_DURATION);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;			<span style="color:#75715e">// select again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (nfds <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (u_int i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> read_set.fd_count; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//LOG__(NET,  &#34;select return read count=%d\n&#34;, read_set.fd_count);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			SOCKET fd <span style="color:#f92672">=</span> read_set.fd_array[i];
</span></span><span style="display:flex;"><span>			CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket((net_handle_t)fd);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pSocket)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>OnRead();
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (u_int i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> write_set.fd_count; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//LOG__(NET,  &#34;select return write count=%d\n&#34;, write_set.fd_count);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			SOCKET fd <span style="color:#f92672">=</span> write_set.fd_array[i];
</span></span><span style="display:flex;"><span>			CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket((net_handle_t)fd);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pSocket)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>OnWrite();
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (u_int i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> excep_set.fd_count; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			LOG__(NET,  _T(<span style="color:#e6db74">&#34;select return exception count=%d&#34;</span>), excep_set.fd_count);
</span></span><span style="display:flex;"><span>			SOCKET fd <span style="color:#f92672">=</span> excep_set.fd_array[i];
</span></span><span style="display:flex;"><span>			CBaseSocket<span style="color:#f92672">*</span> pSocket <span style="color:#f92672">=</span> FindBaseSocket((net_handle_t)fd);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pSocket)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>OnClose();
</span></span><span style="display:flex;"><span>				pSocket<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们举个具体的例子来说明这个三个线程的逻辑（任务队列A、网络线程和下文要介绍的专门处理http请求的任务队列B）和代理窗口的消息队列，以在登录对话框输入用户名和密码后接下来的步骤：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//位于LoginDialog.cpp中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> LoginDialog<span style="color:#f92672">::</span>_DoLogin()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	LOG__(APP,_T(<span style="color:#e6db74">&#34;User Clicked LoginBtn&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_ptxtTip<span style="color:#f92672">-&gt;</span>SetText(_T(<span style="color:#e6db74">&#34;&#34;</span>));
</span></span><span style="display:flex;"><span>	CDuiString userName <span style="color:#f92672">=</span> m_pedtUserName<span style="color:#f92672">-&gt;</span>GetText();
</span></span><span style="display:flex;"><span>	CDuiString password <span style="color:#f92672">=</span> m_pedtPassword<span style="color:#f92672">-&gt;</span>GetText();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (userName.IsEmpty())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		CString csTip <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_USERNAME_EMPTY&#34;</span>));
</span></span><span style="display:flex;"><span>		m_ptxtTip<span style="color:#f92672">-&gt;</span>SetText(csTip);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (password.IsEmpty())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		CString csTip <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_PASSWORD_EMPTY&#34;</span>));
</span></span><span style="display:flex;"><span>		m_ptxtTip<span style="color:#f92672">-&gt;</span>SetText(csTip);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	module<span style="color:#f92672">::</span>TTConfig<span style="color:#f92672">*</span> pCfg <span style="color:#f92672">=</span> module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>getSystemConfig();
</span></span><span style="display:flex;"><span>	pCfg<span style="color:#f92672">-&gt;</span>userName <span style="color:#f92672">=</span> userName;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_bPassChanged)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>string sPass <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>cStringToString(CString(password));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pOutData <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint32_t</span> nOutLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> retCode <span style="color:#f92672">=</span> EncryptPass(sPass.c_str(), sPass.length(), <span style="color:#f92672">&amp;</span>pOutData, nOutLen);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (retCode <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> nOutLen <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> pOutData <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			pCfg<span style="color:#f92672">-&gt;</span>password <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>string(pOutData, nOutLen);
</span></span><span style="display:flex;"><span>			Free(pOutData);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;EncryptPass Failed!&#34;</span>));
</span></span><span style="display:flex;"><span>			CString csTip <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_LOGIN_ENCRYPT_PASE_FAIL&#34;</span>));
</span></span><span style="display:flex;"><span>			m_ptxtTip<span style="color:#f92672">-&gt;</span>SetText(csTip);			
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pCfg<span style="color:#f92672">-&gt;</span>isRememberPWD <span style="color:#f92672">=</span> m_pChkRememberPWD<span style="color:#f92672">-&gt;</span>GetCheck();
</span></span><span style="display:flex;"><span>	module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>saveData();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CString csTxt <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_BTN_DOLOGIN&#34;</span>));
</span></span><span style="display:flex;"><span>	m_pBtnLogin<span style="color:#f92672">-&gt;</span>SetText(csTxt);
</span></span><span style="display:flex;"><span>	m_pBtnLogin<span style="color:#f92672">-&gt;</span>SetEnabled(false);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//连接登陆服务器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	DoLoginServerParam param;
</span></span><span style="display:flex;"><span>	DoLoginServerHttpOperation<span style="color:#f92672">*</span> pOper <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DoLoginServerHttpOperation(
</span></span><span style="display:flex;"><span>		BIND_CALLBACK_1(LoginDialog<span style="color:#f92672">::</span>OnHttpCallbackOperation), param);
</span></span><span style="display:flex;"><span>	module<span style="color:#f92672">::</span>getHttpPoolModule()<span style="color:#f92672">-&gt;</span>pushHttpOperation(pOper);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>点击登录按钮之后，程序先对用户名和密码进行一些有效性校验，接着产生一个DoLoginServerHttpOperation对象，该类继承IHttpOperation，IHttpOperation再继承ICallbackOpertaion，ICallbackOpertaion再继承Operation类。这个任务会绑定一个任务完成之后的回调函数，即宏BIND_CALLBACK_1，这个宏实际上就是std::bind：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define BIND_CALLBACK_1(func)   std::bind(&amp;func, this, placeholders::_1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define BIND_CALLBACK_2(func)	std::bind(&amp;func, this, placeholders::_1, placeholders::_2)
</span></span></span></code></pre></div><p>往任务队列中放入任务的动作如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> HttpPoolModule_Impl<span style="color:#f92672">::</span>pushHttpOperation(module<span style="color:#f92672">::</span>IHttpOperation<span style="color:#f92672">*</span> pOperaion, BOOL bHighPriority <span style="color:#75715e">/*= FALSE*/</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> pOperaion)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CAutoLock <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span>m_mtxLock);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (bHighPriority)
</span></span><span style="display:flex;"><span>		m_lstHttpOpers.push_front(pOperaion);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		m_lstHttpOpers.push_back(pOperaion);
</span></span><span style="display:flex;"><span>	_launchThread();
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">::</span>ReleaseSemaphore(m_hSemaphore, <span style="color:#ae81ff">1</span>, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中_launchThread()会启动一个线程，该线程函数是另外一个任务队列，专门处理http任务：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL HttpPoolModule_Impl<span style="color:#f92672">::</span>_launchThread()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">int</span>)m_vecHttpThread.size() <span style="color:#f92672">&gt;=</span> MAX_THEAD_COUNT)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	TTHttpThread<span style="color:#f92672">*</span> pThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TTHttpThread();
</span></span><span style="display:flex;"><span>	PTR_FALSE(pThread);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pThread<span style="color:#f92672">-&gt;</span>create())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	Sleep(<span style="color:#ae81ff">300</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_vecHttpThread.push_back(pThread);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>线程函数最终实际执行代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>UInt32 TTHttpThread<span style="color:#f92672">::</span>process()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	module<span style="color:#f92672">::</span>IHttpOperation <span style="color:#f92672">*</span> pHttpOper <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	HttpPoolModule_Impl <span style="color:#f92672">*</span>pPool <span style="color:#f92672">=</span> m_pInstance;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (m_bContinue)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (WAIT_OBJECT_0 <span style="color:#f92672">!=</span> <span style="color:#f92672">::</span>WaitForSingleObject(pPool<span style="color:#f92672">-&gt;</span>m_hSemaphore, INFINITE))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_bContinue)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			CAutoLock <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span>(pPool<span style="color:#f92672">-&gt;</span>m_mtxLock));
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pPool<span style="color:#f92672">-&gt;</span>m_lstHttpOpers.empty())
</span></span><span style="display:flex;"><span>				pHttpOper <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pHttpOper <span style="color:#f92672">=</span> pPool<span style="color:#f92672">-&gt;</span>m_lstHttpOpers.front();
</span></span><span style="display:flex;"><span>				pPool<span style="color:#f92672">-&gt;</span>m_lstHttpOpers.pop_front();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (m_bContinue <span style="color:#f92672">&amp;&amp;</span> pHttpOper)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pHttpOper<span style="color:#f92672">-&gt;</span>process();
</span></span><span style="display:flex;"><span>				pHttpOper<span style="color:#f92672">-&gt;</span>release();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">catch</span> (...)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;TTHttpThread: Failed to execute opertaion(0x%p)&#34;</span>), pHttpOper);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当这个http任务被任务队列执行时，实际执行DoLoginServerHttpOperation::processOpertion()，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> DoLoginServerHttpOperation<span style="color:#f92672">::</span>processOpertion()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	module<span style="color:#f92672">::</span>TTConfig<span style="color:#f92672">*</span> pCfg <span style="color:#f92672">=</span> module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>getSystemConfig();
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;loginAddr = %s&#34;</span>), pCfg<span style="color:#f92672">-&gt;</span>loginServIP);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> loginAddr <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>cStringToString(pCfg<span style="color:#f92672">-&gt;</span>loginServIP);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string url <span style="color:#f92672">=</span> loginAddr;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	DoLoginServerParam<span style="color:#f92672">*</span> pPamram <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DoLoginServerParam();
</span></span><span style="display:flex;"><span>	pPamram<span style="color:#f92672">-&gt;</span>resMsg <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_LOGIN_HTTP_DEFERROR&#34;</span>));
</span></span><span style="display:flex;"><span>	Http<span style="color:#f92672">::</span>HttpResponse	response;
</span></span><span style="display:flex;"><span>	Http<span style="color:#f92672">::</span>HttpClient	client;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//对于登录：url=http://192.168.226.128:8080/msg_server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Http<span style="color:#f92672">::</span>HttpRequest	request(<span style="color:#e6db74">&#34;get&#34;</span>, url);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>client.execute(<span style="color:#f92672">&amp;</span>request, <span style="color:#f92672">&amp;</span>response))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		CString csTemp <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(url);
</span></span><span style="display:flex;"><span>		pPamram<span style="color:#f92672">-&gt;</span>result <span style="color:#f92672">=</span> DOLOGIN_FAIL;
</span></span><span style="display:flex;"><span>		LOG__(ERR,_T(<span style="color:#e6db74">&#34;failed %s&#34;</span>), csTemp);
</span></span><span style="display:flex;"><span>		asyncCallback(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>(pPamram));
</span></span><span style="display:flex;"><span>		client.killSelf();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           &#34;backupIP&#34; : &#34;localhost&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           &#34;code&#34; : 0,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           &#34;discovery&#34; : &#34;http://127.0.0.1/api/discovery&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           &#34;msfsBackup&#34; : &#34;http://127.0.0.1:8700/&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           &#34;msfsPrior&#34; : &#34;http://127.0.0.1:8700/&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           &#34;msg&#34; : &#34;&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           &#34;port&#34; : &#34;8000&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           &#34;priorIP&#34; : &#34;localhost&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string body <span style="color:#f92672">=</span> response.getBody();
</span></span><span style="display:flex;"><span>	client.killSelf();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//json解析
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		Json<span style="color:#f92672">::</span>Reader reader;
</span></span><span style="display:flex;"><span>		Json<span style="color:#f92672">::</span>Value root;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>reader.parse(body, root))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			CString csTemp <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(body);
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;parse data failed,%s&#34;</span>), csTemp);
</span></span><span style="display:flex;"><span>			pPamram<span style="color:#f92672">-&gt;</span>result <span style="color:#f92672">=</span> DOLOGIN_FAIL;
</span></span><span style="display:flex;"><span>			pPamram<span style="color:#f92672">-&gt;</span>resMsg <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_LOGIN_HTTP_JSONERROR&#34;</span>));
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> End;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nCode <span style="color:#f92672">=</span> root.get(<span style="color:#e6db74">&#34;code&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).asInt();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> nCode)<span style="color:#75715e">//登陆成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		{
</span></span><span style="display:flex;"><span>			LOG__(APP, _T(<span style="color:#e6db74">&#34;get msgSvr IP succeed!&#34;</span>));
</span></span><span style="display:flex;"><span>			pCfg<span style="color:#f92672">-&gt;</span>msgSevPriorIP <span style="color:#f92672">=</span> root.get(<span style="color:#e6db74">&#34;priorIP&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).asString();
</span></span><span style="display:flex;"><span>			pCfg<span style="color:#f92672">-&gt;</span>msgSevBackupIP <span style="color:#f92672">=</span> root.get(<span style="color:#e6db74">&#34;backupIP&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).asString();
</span></span><span style="display:flex;"><span>			std<span style="color:#f92672">::</span>string strPort <span style="color:#f92672">=</span> root.get(<span style="color:#e6db74">&#34;port&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).asString();
</span></span><span style="display:flex;"><span>			pCfg<span style="color:#f92672">-&gt;</span>msgServPort <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToInt32(strPort);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			pCfg<span style="color:#f92672">-&gt;</span>fileSysAddr <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(root.get(<span style="color:#e6db74">&#34;msfsPrior&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).asString());
</span></span><span style="display:flex;"><span>			pCfg<span style="color:#f92672">-&gt;</span>fileSysBackUpAddr <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(root.get(<span style="color:#e6db74">&#34;msfsBackup&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).asString());
</span></span><span style="display:flex;"><span>			pPamram<span style="color:#f92672">-&gt;</span>result <span style="color:#f92672">=</span> DOLOGIN_SUCC;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;get msgSvr IP failed! Code = %d&#34;</span>),nCode);
</span></span><span style="display:flex;"><span>			pPamram<span style="color:#f92672">-&gt;</span>result <span style="color:#f92672">=</span> DOLOGIN_FAIL;
</span></span><span style="display:flex;"><span>			CString csRetMsgTemp <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(root.get(<span style="color:#e6db74">&#34;msg&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).asString());
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>csRetMsgTemp.IsEmpty())
</span></span><span style="display:flex;"><span>				pPamram<span style="color:#f92672">-&gt;</span>resMsg <span style="color:#f92672">=</span> csRetMsgTemp;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">catch</span> (...)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		CString csTemp <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(body);
</span></span><span style="display:flex;"><span>		LOG__(ERR,_T(<span style="color:#e6db74">&#34;parse json execption,%s&#34;</span>), csTemp);
</span></span><span style="display:flex;"><span>		pPamram<span style="color:#f92672">-&gt;</span>result <span style="color:#f92672">=</span> DOLOGIN_FAIL;
</span></span><span style="display:flex;"><span>		pPamram<span style="color:#f92672">-&gt;</span>resMsg <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_LOGIN_HTTP_JSONERROR&#34;</span>));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>End:
</span></span><span style="display:flex;"><span>	asyncCallback(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>(pPamram));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上是向login_server发送一个http请求，这是一个同步请求。得到的结果是一个json字符串，代码注释中已经给出。然后调用asyncCallback(std::shared_ptr<!-- raw HTML omitted -->(pPamram));参数pPamram携带了当前任务的回调函数指针：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 异步回调，借助UIEvent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param   std::shared_ptr&lt;void&gt; param
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @return  void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @exception there is no any exception to throw.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">asyncCallback</span>(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span> param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CallbackOperationEvent<span style="color:#f92672">*</span> pEvent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CallbackOperationEvent(m_callback, param);
</span></span><span style="display:flex;"><span>	module<span style="color:#f92672">::</span>getEventManager()<span style="color:#f92672">-&gt;</span>asynFireUIEvent(pEvent);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这实际上产生了一个回调事件。也就是说队列B做http请求，操作完成后往代理窗口的消息队列中放入一个回调事件，这个事件通过代理窗口过程函数来处理的（这就是上文中第4点介绍的代理窗口过程的作用，实际上是利用windows消息队列来做任务处理（系统有现成的任务队列系统，为何不利用呢？））：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>module<span style="color:#f92672">::</span>IMCoreErrorCode UIEventManager<span style="color:#f92672">::</span>asynFireUIEvent(IN <span style="color:#66d9ef">const</span> IEvent<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> pEvent)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	assert(m_hWnd);
</span></span><span style="display:flex;"><span>	assert(pEvent);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> m_hWnd <span style="color:#f92672">||</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> pEvent)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> IMCORE_ARGUMENT_ERROR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (FALSE <span style="color:#f92672">==</span> <span style="color:#f92672">::</span>PostMessage(m_hWnd, UI_EVENT_MSG, <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>WPARAM<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">this</span>), <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>WPARAM<span style="color:#f92672">&gt;</span>(pEvent)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> IMCORE_WORK_POSTMESSAGE_ERROR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> IMCORE_OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>看到没有？向代理窗口的消息队列中投递一个UI_EVENT_MSG事件，并在消息参数LPARAM中传递了回调事件的对象指针。这样代理窗口过程函数就可以处理这个消息了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LRESULT _stdcall UIEventManager<span style="color:#f92672">::</span>_WindowProc(HWND hWnd
</span></span><span style="display:flex;"><span>											, UINT message
</span></span><span style="display:flex;"><span>											, WPARAM wparam
</span></span><span style="display:flex;"><span>											, LPARAM lparam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (message)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> UI_EVENT_MSG:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>UIEventManager<span style="color:#f92672">*&gt;</span>(wparam)<span style="color:#f92672">-&gt;</span>_processEvent(<span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>IEvent<span style="color:#f92672">*&gt;</span>(lparam), TRUE);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> WM_TIMER:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>UIEventManager<span style="color:#f92672">*&gt;</span>(wparam)<span style="color:#f92672">-&gt;</span>_processTimer();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span>DefWindowProc(hWnd, message, wparam, lparam);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> UIEventManager<span style="color:#f92672">::</span>_processEvent(IEvent<span style="color:#f92672">*</span> pEvent, BOOL bRelease)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	assert(pEvent);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> pEvent)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		pEvent<span style="color:#f92672">-&gt;</span>process();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (bRelease)
</span></span><span style="display:flex;"><span>			pEvent<span style="color:#f92672">-&gt;</span>release();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">catch</span> (imcore<span style="color:#f92672">::</span>Exception <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;event run exception&#34;</span>));
</span></span><span style="display:flex;"><span>		pEvent<span style="color:#f92672">-&gt;</span>onException(e);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (bRelease)
</span></span><span style="display:flex;"><span>			pEvent<span style="color:#f92672">-&gt;</span>release();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (e)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;event run exception:%s&#34;</span>), util<span style="color:#f92672">::</span>stringToCString(e<span style="color:#f92672">-&gt;</span>m_msg));
</span></span><span style="display:flex;"><span>			assert(FALSE);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">catch</span> (...)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;operation run exception,unknown reason&#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (bRelease)
</span></span><span style="display:flex;"><span>			pEvent<span style="color:#f92672">-&gt;</span>release();
</span></span><span style="display:flex;"><span>		assert(FALSE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>根据C++的多态特性，pEvent-&gt;process()实际上调用的是CallbackOperationEvent.process()。代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">process</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		m_callback(m_param);
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>m_callback(m_param);调用的就是上文中介绍DoLoginServerHttpOperation操作的回调函数LoginDialog::OnHttpCallbackOperation()：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> LoginDialog<span style="color:#f92672">::</span>OnHttpCallbackOperation(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span> param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DoLoginServerParam<span style="color:#f92672">*</span> pParam <span style="color:#f92672">=</span> (DoLoginServerParam<span style="color:#f92672">*</span>)param.get();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (DOLOGIN_SUCC <span style="color:#f92672">==</span> pParam<span style="color:#f92672">-&gt;</span>result)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>TTConfig<span style="color:#f92672">*</span> pCfg <span style="color:#f92672">=</span> module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>getSystemConfig();
</span></span><span style="display:flex;"><span>		PTR_VOID(pCfg);
</span></span><span style="display:flex;"><span>		LoginParam loginparam;
</span></span><span style="display:flex;"><span>		loginparam.csUserName <span style="color:#f92672">=</span> pCfg<span style="color:#f92672">-&gt;</span>userName;
</span></span><span style="display:flex;"><span>		loginparam.password <span style="color:#f92672">=</span> pCfg<span style="color:#f92672">-&gt;</span>password;
</span></span><span style="display:flex;"><span>		loginparam.csUserName.Trim();
</span></span><span style="display:flex;"><span>		LoginOperation<span style="color:#f92672">*</span> pOperation <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LoginOperation(
</span></span><span style="display:flex;"><span>			BIND_CALLBACK_1(LoginDialog<span style="color:#f92672">::</span>OnOperationCallback), loginparam);
</span></span><span style="display:flex;"><span>		imcore<span style="color:#f92672">::</span>IMLibCoreStartOperation(pOperation);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		m_ptxtTip<span style="color:#f92672">-&gt;</span>SetText(pParam<span style="color:#f92672">-&gt;</span>resMsg);
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>TTConfig<span style="color:#f92672">*</span> pCfg <span style="color:#f92672">=</span> module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>getSystemConfig();
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;get MsgServer config faild,login server addres:%s:%d&#34;</span>), pCfg<span style="color:#f92672">-&gt;</span>loginServIP,pCfg<span style="color:#f92672">-&gt;</span>loginServPort);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		CString csTxt <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_BTN_LOGIN&#34;</span>));
</span></span><span style="display:flex;"><span>		m_pBtnLogin<span style="color:#f92672">-&gt;</span>SetText(csTxt);
</span></span><span style="display:flex;"><span>		m_pBtnLogin<span style="color:#f92672">-&gt;</span>SetEnabled(true);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ok，终于到家了。但是这并没结束，我们只介绍了队列B和代理窗口消息队列，还有队列A呢？LoginDialog::OnHttpCallbackOperation()会根据获取的msg_server的情况来再次产生一个新的任务LoginOperation来放入队列A中，这次才是真正的用户登录，根据上面的介绍，LoginOperation任务从队列A中取出来之后，实际执行的是LoginOperation::processOpertion()：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> LoginOperation<span style="color:#f92672">::</span>processOpertion()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	LOG__(APP,_T(<span style="color:#e6db74">&#34;login start,uname:%s,status:%d&#34;</span>), m_loginParam.csUserName
</span></span><span style="display:flex;"><span>		, m_loginParam.mySelectedStatus);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LoginParam<span style="color:#f92672">*</span> pParam <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LoginParam;
</span></span><span style="display:flex;"><span>	pParam<span style="color:#f92672">-&gt;</span>csUserName <span style="color:#f92672">=</span> m_loginParam.csUserName;
</span></span><span style="display:flex;"><span>	pParam<span style="color:#f92672">-&gt;</span>mySelectedStatus <span style="color:#f92672">=</span> m_loginParam.mySelectedStatus;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//连接消息服务器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	module<span style="color:#f92672">::</span>TTConfig<span style="color:#f92672">*</span> pCfg <span style="color:#f92672">=</span> module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>getSystemConfig();
</span></span><span style="display:flex;"><span>	CString server <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(pCfg<span style="color:#f92672">-&gt;</span>msgSevPriorIP);
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;MsgServeIp:%s,Port:%d&#34;</span>), server, pCfg<span style="color:#f92672">-&gt;</span>msgServPort);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//8000端口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	IM<span style="color:#f92672">::</span>Login<span style="color:#f92672">::</span>IMLoginRes<span style="color:#f92672">*</span> pImLoginResp <span style="color:#f92672">=</span> (IM<span style="color:#f92672">::</span>Login<span style="color:#f92672">::</span>IMLoginRes<span style="color:#f92672">*</span>)module<span style="color:#f92672">::</span>getTcpClientModule()
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">-&gt;</span>doLogin(server, pCfg<span style="color:#f92672">-&gt;</span>msgServPort,m_loginParam.csUserName,m_loginParam.password);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> pImLoginResp <span style="color:#f92672">||</span> pImLoginResp<span style="color:#f92672">-&gt;</span>result_code() <span style="color:#f92672">!=</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>REFUSE_REASON_NONE 
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">||</span> <span style="color:#f92672">!</span>pImLoginResp<span style="color:#f92672">-&gt;</span>has_user_info())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//TODO,若失败，尝试备用IP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		LOG__(ERR,_T(<span style="color:#e6db74">&#34;add:%s:%d,uname:%s,login for msg server failed&#34;</span>),server,pCfg<span style="color:#f92672">-&gt;</span>msgServPort, m_loginParam.csUserName);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (pImLoginResp)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			CString errInfo <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(pImLoginResp<span style="color:#f92672">-&gt;</span>result_string());
</span></span><span style="display:flex;"><span>			pParam<span style="color:#f92672">-&gt;</span>errInfo <span style="color:#f92672">=</span> errInfo;
</span></span><span style="display:flex;"><span>			pParam<span style="color:#f92672">-&gt;</span>result <span style="color:#f92672">=</span> LOGIN_FAIL;
</span></span><span style="display:flex;"><span>			pParam<span style="color:#f92672">-&gt;</span>server_result <span style="color:#f92672">=</span> pImLoginResp<span style="color:#f92672">-&gt;</span>result_code();
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;error code :%d,error info:%s&#34;</span>), pImLoginResp<span style="color:#f92672">-&gt;</span>result_code(), errInfo);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			pParam<span style="color:#f92672">-&gt;</span>result <span style="color:#f92672">=</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>REFUSE_REASON_NO_MSG_SERVER;
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;login msg server faild！&#34;</span>));
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		asyncCallback(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>(pParam));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	pParam<span style="color:#f92672">-&gt;</span>result <span style="color:#f92672">=</span> LOGIN_OK;
</span></span><span style="display:flex;"><span>	pParam<span style="color:#f92672">-&gt;</span>serverTime <span style="color:#f92672">=</span> pImLoginResp<span style="color:#f92672">-&gt;</span>server_time();
</span></span><span style="display:flex;"><span>	pParam<span style="color:#f92672">-&gt;</span>mySelectedStatus <span style="color:#f92672">=</span> pImLoginResp<span style="color:#f92672">-&gt;</span>online_status();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//存储服务器端返回的userId
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>UserInfo userInfo <span style="color:#f92672">=</span> pImLoginResp<span style="color:#f92672">-&gt;</span>user_info();
</span></span><span style="display:flex;"><span>	pCfg<span style="color:#f92672">-&gt;</span>userId <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>uint32ToString(userInfo.user_id());
</span></span><span style="display:flex;"><span>	pCfg<span style="color:#f92672">-&gt;</span>csUserId <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(pCfg<span style="color:#f92672">-&gt;</span>userId);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//登陆成功，创建自己的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	module<span style="color:#f92672">::</span>UserInfoEntity myInfo;
</span></span><span style="display:flex;"><span>	myInfo.sId <span style="color:#f92672">=</span> pCfg<span style="color:#f92672">-&gt;</span>userId;
</span></span><span style="display:flex;"><span>	myInfo.csName <span style="color:#f92672">=</span> m_loginParam.csUserName;
</span></span><span style="display:flex;"><span>	myInfo.onlineState <span style="color:#f92672">=</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>USER_STATUS_ONLINE;
</span></span><span style="display:flex;"><span>	myInfo.csNickName <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>stringToCString(userInfo.user_nick_name());
</span></span><span style="display:flex;"><span>	myInfo.avatarUrl <span style="color:#f92672">=</span> userInfo.avatar_url();
</span></span><span style="display:flex;"><span>	myInfo.dId <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>uint32ToString(userInfo.department_id());
</span></span><span style="display:flex;"><span>	myInfo.department <span style="color:#f92672">=</span> myInfo.dId;
</span></span><span style="display:flex;"><span>	myInfo.email <span style="color:#f92672">=</span> userInfo.email();
</span></span><span style="display:flex;"><span>	myInfo.gender <span style="color:#f92672">=</span> userInfo.user_gender();
</span></span><span style="display:flex;"><span>	myInfo.user_domain <span style="color:#f92672">=</span> userInfo.user_domain();
</span></span><span style="display:flex;"><span>	myInfo.telephone <span style="color:#f92672">=</span> userInfo.user_tel();
</span></span><span style="display:flex;"><span>	myInfo.status <span style="color:#f92672">=</span> userInfo.status();
</span></span><span style="display:flex;"><span>    myInfo.signature <span style="color:#f92672">=</span> userInfo.sign_info();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	module<span style="color:#f92672">::</span>getUserListModule()<span style="color:#f92672">-&gt;</span>createUserInfo(myInfo);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	asyncCallback(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>(pParam));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LOG__(APP, _T(<span style="color:#e6db74">&#34;login succeed! Name = %s Nickname = %s sId = %s status = %d&#34;</span>)
</span></span><span style="display:flex;"><span>		, m_loginParam.csUserName
</span></span><span style="display:flex;"><span>		, util<span style="color:#f92672">::</span>stringToCString(userInfo.user_nick_name())
</span></span><span style="display:flex;"><span>		, module<span style="color:#f92672">::</span>getSysConfigModule()<span style="color:#f92672">-&gt;</span>UserID()
</span></span><span style="display:flex;"><span>		, m_loginParam.mySelectedStatus);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//开始发送心跳包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	module<span style="color:#f92672">::</span>getTcpClientModule()<span style="color:#f92672">-&gt;</span>startHeartbeat();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同理，数据包发生成功以后，会再往代理窗口的消息队列中产生一个回调事件，最终调用刚才说的LoginOperation绑定的回调函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">asyncCallback</span>(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span> param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	CallbackOperationEvent<span style="color:#f92672">*</span> pEvent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CallbackOperationEvent(m_callback, param);
</span></span><span style="display:flex;"><span>	module<span style="color:#f92672">::</span>getEventManager()<span style="color:#f92672">-&gt;</span>asynFireUIEvent(pEvent);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> LoginDialog<span style="color:#f92672">::</span>OnOperationCallback(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span> param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	LoginParam<span style="color:#f92672">*</span> pLoginParam <span style="color:#f92672">=</span> (LoginParam<span style="color:#f92672">*</span>)param.get();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (LOGIN_OK <span style="color:#f92672">==</span> pLoginParam<span style="color:#f92672">-&gt;</span>result)	<span style="color:#75715e">//登陆成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	{
</span></span><span style="display:flex;"><span>		Close(IDOK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//创建用户目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		_CreateUsersFolder();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//开启同步消息时间timer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		module<span style="color:#f92672">::</span>getSessionModule()<span style="color:#f92672">-&gt;</span>startSyncTimeTimer();
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>getSessionModule()<span style="color:#f92672">-&gt;</span>setTime(pLoginParam<span style="color:#f92672">-&gt;</span>serverTime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//通知服务器客户端初始化完毕,获取组织架构信息和群列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		module<span style="color:#f92672">::</span>getLoginModule()<span style="color:#f92672">-&gt;</span>notifyLoginDone();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>	<span style="color:#75715e">//登陆失败处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	{
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>getTcpClientModule()<span style="color:#f92672">-&gt;</span>shutdown();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>REFUSE_REASON_NO_MSG_SERVER <span style="color:#f92672">==</span> pLoginParam<span style="color:#f92672">-&gt;</span>server_result)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			CString csTip <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_LOGIN_MSGSVR_FAIL&#34;</span>));
</span></span><span style="display:flex;"><span>			m_ptxtTip<span style="color:#f92672">-&gt;</span>SetText(csTip);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#f92672">!</span>pLoginParam<span style="color:#f92672">-&gt;</span>errInfo.IsEmpty())
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_ptxtTip<span style="color:#f92672">-&gt;</span>SetText(pLoginParam<span style="color:#f92672">-&gt;</span>errInfo);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			CString errorCode <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>int32ToCString(pLoginParam<span style="color:#f92672">-&gt;</span>server_result);
</span></span><span style="display:flex;"><span>			CString csTip <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_LOGIN_UNKNOWN_ERROR&#34;</span>));
</span></span><span style="display:flex;"><span>			m_ptxtTip<span style="color:#f92672">-&gt;</span>SetText(csTip <span style="color:#f92672">+</span> CString(<span style="color:#e6db74">&#34;:&#34;</span>) <span style="color:#f92672">+</span> errorCode);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CString csTxt <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>getMultilingual()<span style="color:#f92672">-&gt;</span>getStringById(_T(<span style="color:#e6db74">&#34;STRID_LOGINDIALOG_BTN_LOGIN&#34;</span>));
</span></span><span style="display:flex;"><span>	m_pBtnLogin<span style="color:#f92672">-&gt;</span>SetText(csTxt);
</span></span><span style="display:flex;"><span>	m_pBtnLogin<span style="color:#f92672">-&gt;</span>SetEnabled(true);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>至此，登录才成功。等等，那数据包是怎么发到服务器的呢？这也是一个重点，我们来详细地介绍一下，LoginOperation::processOpertion()中有这一行代码：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/43bdad1233e8c503d84540dc9c2c0bc1.png" alt=""  />
</p>
<p>doLogin函数代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>IM<span style="color:#f92672">::</span>Login<span style="color:#f92672">::</span>IMLoginRes<span style="color:#f92672">*</span> TcpClientModule_Impl<span style="color:#f92672">::</span>doLogin(CString <span style="color:#f92672">&amp;</span>linkaddr, UInt16 port
</span></span><span style="display:flex;"><span>	,CString<span style="color:#f92672">&amp;</span> uName,std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> pass)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_socketHandle <span style="color:#f92672">=</span> imcore<span style="color:#f92672">::</span>IMLibCoreConnect(util<span style="color:#f92672">::</span>cStringToString(linkaddr), port);
</span></span><span style="display:flex;"><span>	imcore<span style="color:#f92672">::</span>IMLibCoreRegisterCallback(m_socketHandle, <span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(util<span style="color:#f92672">::</span>waitSingleObject(m_eventConnected, <span style="color:#ae81ff">5000</span>))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		IM<span style="color:#f92672">::</span>Login<span style="color:#f92672">::</span>IMLoginReq imLoginReq;
</span></span><span style="display:flex;"><span>		string<span style="color:#f92672">&amp;</span> name <span style="color:#f92672">=</span> util<span style="color:#f92672">::</span>cStringToString(uName);
</span></span><span style="display:flex;"><span>		imLoginReq.set_user_name(name);
</span></span><span style="display:flex;"><span>		imLoginReq.set_password(pass);
</span></span><span style="display:flex;"><span>		imLoginReq.set_online_status(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>USER_STATUS_ONLINE);
</span></span><span style="display:flex;"><span>		imLoginReq.set_client_type(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CLIENT_TYPE_WINDOWS);
</span></span><span style="display:flex;"><span>		imLoginReq.set_client_version(<span style="color:#e6db74">&#34;win_10086&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (TCPCLIENT_STATE_OK <span style="color:#f92672">!=</span> m_tcpClientState)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		sendPacket(IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SID_LOGIN, IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_LOGIN_REQ_USERLOGIN, <span style="color:#f92672">++</span>g_seqNum
</span></span><span style="display:flex;"><span>			, <span style="color:#f92672">&amp;</span>imLoginReq);
</span></span><span style="display:flex;"><span>		m_pImLoginResp<span style="color:#f92672">-&gt;</span>Clear();
</span></span><span style="display:flex;"><span>		util<span style="color:#f92672">::</span>waitSingleObject(m_eventReceived, <span style="color:#ae81ff">10000</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> m_pImLoginResp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段代码先连接服务器，然后调用sendPacket()发送登录数据包。如何连接服务器使用了一些“奇技淫巧”，我们后面单独介绍。我们这里先来看sendPacket()发包代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TcpClientModule_Impl<span style="color:#f92672">::</span>sendPacket(UInt16 moduleId, UInt16 cmdId, UInt16 seq, google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>MessageLite<span style="color:#f92672">*</span> pbBody)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_TTPBHeader.clear();
</span></span><span style="display:flex;"><span>	m_TTPBHeader.setModuleId(moduleId);
</span></span><span style="display:flex;"><span>	m_TTPBHeader.setCommandId(cmdId);
</span></span><span style="display:flex;"><span>	m_TTPBHeader.setSeqNumber(seq);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_sendPacket(pbBody);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TcpClientModule_Impl<span style="color:#f92672">::</span>_sendPacket(google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>MessageLite<span style="color:#f92672">*</span> pbBody)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	UInt32 length <span style="color:#f92672">=</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH <span style="color:#f92672">+</span> pbBody<span style="color:#f92672">-&gt;</span>ByteSize();
</span></span><span style="display:flex;"><span>	m_TTPBHeader.setLength(length);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>byte<span style="color:#f92672">&gt;</span> data(<span style="color:#66d9ef">new</span> byte[length]);
</span></span><span style="display:flex;"><span>	memset(data.get(), <span style="color:#ae81ff">0</span>, length);
</span></span><span style="display:flex;"><span>	memcpy(data.get(), m_TTPBHeader.getSerializeBuffer(), imcore<span style="color:#f92672">::</span>HEADER_LENGTH);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pbBody<span style="color:#f92672">-&gt;</span>SerializeToArray(data.get() <span style="color:#f92672">+</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH, pbBody<span style="color:#f92672">-&gt;</span>ByteSize()))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;pbBody SerializeToArray failed&#34;</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	imcore<span style="color:#f92672">::</span>IMLibCoreWrite(m_socketHandle, data.get(), length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其实就是序列化成protobuf要求的格式，然后调用imcore::IMLibCoreWrite(m_socketHandle, data.get(), length);发出去：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">IMLibCoreWrite</span>(<span style="color:#66d9ef">int</span> key, uchar_t<span style="color:#f92672">*</span> data, <span style="color:#66d9ef">uint32_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> nRet <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> nHandle <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>	CImConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> TcpSocketsManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>get_client_conn(nHandle);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pConn) {
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>Send((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)data, size);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		LOG__(NET,  _T(<span style="color:#e6db74">&#34;connection is invalied:%d&#34;</span>), key);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> nRet;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>先尝试着直接发送，如果目前tcp窗口太小发不出去，则暂且将数据放在发送缓冲区里面，并检测socket可写事件。这里就是和服务器一样的网络库的代码了，前面一系列的文章，我们已经介绍过了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> CImConn<span style="color:#f92672">::</span>Send(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> data, <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_busy)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		m_out_buf.Write(data, len);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> remain <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (remain <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> send_size <span style="color:#f92672">=</span> remain;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (send_size <span style="color:#f92672">&gt;</span> NETLIB_MAX_SOCKET_BUF_SIZE) {
</span></span><span style="display:flex;"><span>			send_size <span style="color:#f92672">=</span> NETLIB_MAX_SOCKET_BUF_SIZE;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> netlib_send(m_handle, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)data <span style="color:#f92672">+</span> offset, send_size);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">+=</span> ret;
</span></span><span style="display:flex;"><span>		remain <span style="color:#f92672">-=</span> ret;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (remain <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		m_out_buf.Write((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)data <span style="color:#f92672">+</span> offset, remain);
</span></span><span style="display:flex;"><span>		m_busy <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>		LOG__(NET,  _T(<span style="color:#e6db74">&#34;send busy, remain=%d&#34;</span>), m_out_buf.GetWriteOffset());
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>数据发出去以后，服务器应答登录包，网络线程会检测到socket可读事件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CBaseSocket<span style="color:#f92672">::</span>OnRead()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_state <span style="color:#f92672">==</span> SOCKET_STATE_LISTENING)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		_AcceptNewSocket();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		u_long avail <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( (ioctlsocket(m_socket, FIONREAD, <span style="color:#f92672">&amp;</span>avail) <span style="color:#f92672">==</span> SOCKET_ERROR) <span style="color:#f92672">||</span> (avail <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_CLOSE, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_callback(m_callback_data, NETLIB_MSG_READ, (net_handle_t)m_socket, NULL);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">imconn_callback</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> callback_data, <span style="color:#66d9ef">uint8_t</span> msg, <span style="color:#66d9ef">uint32_t</span> handle, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	NOTUSED_ARG(handle);
</span></span><span style="display:flex;"><span>	NOTUSED_ARG(pParam);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CImConn<span style="color:#f92672">*</span> pConn <span style="color:#f92672">=</span> TcpSocketsManager<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>get_client_conn(handle);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pConn)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//LOG__(NET, _T(&#34;connection is invalied:%d&#34;), handle);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	pConn<span style="color:#f92672">-&gt;</span>AddRef();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//	LOG__(NET,  &#34;msg=%d, handle=%d\n&#34;, msg, handle);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (msg)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_CONFIRM:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>onConnect();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_READ:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnRead();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_WRITE:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnWrite();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NETLIB_MSG_CLOSE:
</span></span><span style="display:flex;"><span>		pConn<span style="color:#f92672">-&gt;</span>OnClose();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		LOG__(NET,  _T(<span style="color:#e6db74">&#34;!!!imconn_callback error msg: %d&#34;</span>), msg);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pConn<span style="color:#f92672">-&gt;</span>ReleaseRef();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CImConn<span style="color:#f92672">::</span>OnRead()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (;;)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint32_t</span> free_buf_len <span style="color:#f92672">=</span> m_in_buf.GetAllocSize() <span style="color:#f92672">-</span> m_in_buf.GetWriteOffset();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (free_buf_len <span style="color:#f92672">&lt;</span> READ_BUF_SIZE)
</span></span><span style="display:flex;"><span>			m_in_buf.Extend(READ_BUF_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> netlib_recv(m_handle, m_in_buf.GetBuffer() <span style="color:#f92672">+</span> m_in_buf.GetWriteOffset(), READ_BUF_SIZE);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		m_in_buf.IncWriteOffset(ret);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (m_in_buf.GetWriteOffset() <span style="color:#f92672">&gt;=</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">uint32_t</span> len <span style="color:#f92672">=</span> m_in_buf.GetWriteOffset();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">uint32_t</span> length <span style="color:#f92672">=</span> CByteStream<span style="color:#f92672">::</span>ReadUint32(m_in_buf.GetBuffer());
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (length <span style="color:#f92672">&gt;</span> len)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				imcore<span style="color:#f92672">::</span>TTPBHeader pbHeader;
</span></span><span style="display:flex;"><span>				pbHeader.unSerialize((byte<span style="color:#f92672">*</span>)m_in_buf.GetBuffer(), imcore<span style="color:#f92672">::</span>HEADER_LENGTH);
</span></span><span style="display:flex;"><span>				LOG__(NET, _T(<span style="color:#e6db74">&#34;OnRead moduleId:0x%x,commandId:0x%x&#34;</span>), pbHeader.getModuleId(), pbHeader.getCommandId());
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (m_pTcpSocketCB)
</span></span><span style="display:flex;"><span>					m_pTcpSocketCB<span style="color:#f92672">-&gt;</span>onReceiveData((<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)m_in_buf.GetBuffer(), length);
</span></span><span style="display:flex;"><span>				LOGBIN_F__(SOCK, <span style="color:#e6db74">&#34;OnRead&#34;</span>, m_in_buf.GetBuffer(), length);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">catch</span> (std<span style="color:#f92672">::</span>exception<span style="color:#f92672">&amp;</span> ex)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				assert(FALSE);
</span></span><span style="display:flex;"><span>				LOGA__(NET, <span style="color:#e6db74">&#34;std::exception,info:%s&#34;</span>, ex.what());
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (m_pTcpSocketCB)
</span></span><span style="display:flex;"><span>					m_pTcpSocketCB<span style="color:#f92672">-&gt;</span>onReceiveError();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">catch</span> (...)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				assert(FALSE);
</span></span><span style="display:flex;"><span>				LOG__(NET, _T(<span style="color:#e6db74">&#34;unknown exception&#34;</span>));
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (m_pTcpSocketCB)
</span></span><span style="display:flex;"><span>					m_pTcpSocketCB<span style="color:#f92672">-&gt;</span>onReceiveError();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			m_in_buf.Read(NULL, length);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>收取数据，并解包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TcpClientModule_Impl<span style="color:#f92672">::</span>onReceiveData(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> data, <span style="color:#66d9ef">int32_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_pServerPingTimer)
</span></span><span style="display:flex;"><span>		m_pServerPingTimer<span style="color:#f92672">-&gt;</span>m_bHasReceivedPing <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	imcore<span style="color:#f92672">::</span>TTPBHeader header;
</span></span><span style="display:flex;"><span>	header.unSerialize((byte<span style="color:#f92672">*</span>)data, imcore<span style="color:#f92672">::</span>HEADER_LENGTH);	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_OTHER_HEARTBEAT <span style="color:#f92672">==</span> header.getCommandId() <span style="color:#f92672">&amp;&amp;</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>SID_OTHER <span style="color:#f92672">==</span> header.getModuleId())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//模块器端过来的心跳包，不跳到业务层派发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LOG__(NET, _T(<span style="color:#e6db74">&#34;receiveData message moduleId:0x%x,commandId:0x%x&#34;</span>)
</span></span><span style="display:flex;"><span>		, header.getModuleId(), header.getCommandId());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (g_seqNum <span style="color:#f92672">==</span> header.getSeqNumber())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		m_pImLoginResp<span style="color:#f92672">-&gt;</span>ParseFromArray(data <span style="color:#f92672">+</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH, size <span style="color:#f92672">-</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH);
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">::</span>SetEvent(m_eventReceived);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//将网络包包装成任务放到逻辑任务队列里面去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	_handlePacketOperation(data, size);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TcpClientModule_Impl<span style="color:#f92672">::</span>_handlePacketOperation(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> data, UInt32 size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string copyInBuffer(data, size);
</span></span><span style="display:flex;"><span>	imcore<span style="color:#f92672">::</span>IMLibCoreStartOperationWithLambda(
</span></span><span style="display:flex;"><span>		[<span style="color:#f92672">=</span>]()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		imcore<span style="color:#f92672">::</span>TTPBHeader header;
</span></span><span style="display:flex;"><span>		header.unSerialize((byte<span style="color:#f92672">*</span>)copyInBuffer.data(),imcore<span style="color:#f92672">::</span>HEADER_LENGTH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		module<span style="color:#f92672">::</span>IPduPacketParse<span style="color:#f92672">*</span> pModule
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">=</span> (module<span style="color:#f92672">::</span>IPduPacketParse<span style="color:#f92672">*</span>)__getModule(header.getModuleId());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pModule)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			assert(FALSE);
</span></span><span style="display:flex;"><span>			LOG__(ERR, _T(<span style="color:#e6db74">&#34;module is null, moduleId:%d,commandId:%d&#34;</span>)
</span></span><span style="display:flex;"><span>				, header.getModuleId(), header.getCommandId());
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>string pbBody(copyInBuffer.data() <span style="color:#f92672">+</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH, size <span style="color:#f92672">-</span> imcore<span style="color:#f92672">::</span>HEADER_LENGTH);
</span></span><span style="display:flex;"><span>		pModule<span style="color:#f92672">-&gt;</span>onPacket(header, pbBody);
</span></span><span style="display:flex;"><span>	});
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>根据不同的命令号来做相应的处理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> UserListModule_Impl<span style="color:#f92672">::</span>onPacket(imcore<span style="color:#f92672">::</span>TTPBHeader<span style="color:#f92672">&amp;</span> header, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> pbBody)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (header.getCommandId())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE:
</span></span><span style="display:flex;"><span>		_recentlistResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_STATUS_NOTIFY:
</span></span><span style="display:flex;"><span>		_userStatusNotify(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_USER_INFO_RESPONSE:
</span></span><span style="display:flex;"><span>		_usersInfoResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_REMOVE_SESSION_RES:
</span></span><span style="display:flex;"><span>		_removeSessionResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_ALL_USER_RESPONSE:
</span></span><span style="display:flex;"><span>		_allUserlistResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_USERS_STATUS_RESPONSE:
</span></span><span style="display:flex;"><span>		_usersLineStatusResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE:
</span></span><span style="display:flex;"><span>		_changeAvatarResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span>  IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY:
</span></span><span style="display:flex;"><span>		_removeSessionNotify(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>CID_BUDDY_LIST_DEPARTMENT_RESPONSE:
</span></span><span style="display:flex;"><span>		_departmentResponse(pbBody);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY:
</span></span><span style="display:flex;"><span>        _avatarChangeNotify(pbBody);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE:
</span></span><span style="display:flex;"><span>        _changeSignInfoResponse(pbBody);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> IM<span style="color:#f92672">::</span>BaseDefine<span style="color:#f92672">::</span>BuddyListCmdID<span style="color:#f92672">::</span>CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY:
</span></span><span style="display:flex;"><span>        _signInfoChangedNotify(pbBody);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		LOG__(ERR, _T(<span style="color:#e6db74">&#34;Unknow commandID:%d&#34;</span>), header.getCommandId());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>每一个处理分支，都最终会产生一个事件放入代理窗口的消息队列中。这前面已经介绍过了。这里我不得不说一点，teamtalk对于其它数据包的应答都是走的上面的介绍的流程，但是对于登录的应答却是使用了一些特殊处理。听我慢慢道来：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/41dff38d2ee45afa8c1f6f9f06d59153.png" alt=""  />
</p>
<p>上文中发送了登录数据包之后，在那里等一个事件10秒钟，如果10秒内这个事件有信号，则认为登录成功。那么什么情况该事件会有信号呢？</p>
<p>该事件在构造函数里面创建，默认无信号：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/4a2475945ee87aa93a25e3dd988ecc08.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>当网络线程收到数据以后（上文逻辑流中介绍过了）：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/2d68549dd1ea0ab658e52cd8455f7839.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>除了心跳包直接过滤以外，通过一个序列号（Seq，变量g_seqNum）唯一标识了登录数据包的应答，如果收到这个序列号的数据，则置信m_eventReceived。这样等待在那里的登录流程就可以返回了，同时也得到了登录应答，登录应答数据记录在成员变量m_pImLoginResp中。如果是其它的数据包，则走的流程是_handlePacketOperation(data, size);，处理逻辑上文也介绍了。</p>
<p>至此，整个客户端程序结构就介绍完了，我们总结一下，实际上程序有如下几类线程：</p>
<ol>
<li>
<p>网络事件检测线程，用于接收和发送网络数据；</p>
</li>
<li>
<p>http任务处理线程用于处理http操作；</p>
</li>
<li>
<p>普通的任务处理线程，用于处理一般性的任务，比如登录；</p>
</li>
<li>
<p>UI线程，界面逻辑处理，同时在UI线程里面有一个代理窗口的窗口过程函数，用于非UI线程与UI线程之间的数据流和逻辑中转，核心是利用PostMessage往代理线程投递事件，事件消息参数携带任务信息。</p>
</li>
</ol>
<p>至于，像聊天、查看用户信息这些业务性的内容，留给有兴趣的读者自己去研究吧。</p>
<h3 id="四程序中使用的一些比较有意思的技巧摘录">四、程序中使用的一些比较有意思的技巧摘录</h3>
<ol>
<li>唯一实例判断</li>
</ol>
<p>很多程序只能启动一个实例，当你再次启动某个程序的实例时，会激活前一个实例，其实实现起来很简单，就是新建一个命名的Mutex，因为Mutex可以跨进程，当再次启动程序实例时，创建同名的Mutex，会无法创建，错误信息是已经存在。这是windows上非常常用的技巧，如果你从事windows开发，请你务必掌握它。看teamtalk的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#ifdef _DEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#define  AppSingletonMutex _T(&#34;{7A666640-EDB3-44CC-954B-0C43F35A2E17}&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#define  AppSingletonMutex _T(&#34;{5676532A-6F70-460D-A1F0-81D6E68F046A}&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BOOL CteamtalkApp<span style="color:#f92672">::</span>_IsHaveInstance()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 单实例运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	HANDLE hMutex <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>CreateMutex(NULL, TRUE, AppSingletonMutex);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (hMutex <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> GetLastError() <span style="color:#f92672">==</span> ERROR_ALREADY_EXISTS)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		MessageBox(<span style="color:#ae81ff">0</span>, _T(<span style="color:#e6db74">&#34;上次程序运行还没完全退出，请稍后再启动！&#34;</span>), _T(<span style="color:#e6db74">&#34;TeamTalk&#34;</span>), MB_OK);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>socket函数connect()连接等待时长设定</li>
</ol>
<p>传统的做法是将socket设置为非阻塞的，调用完connect函数之后，调用select函数检测socket是否可写，在select函数里面设置超时时间。代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//为了调试方便，暂且注释掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>connect(m_hSocket, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>addrSrv, <span style="color:#66d9ef">sizeof</span>(addrSrv));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_bConnected <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> SOCKET_ERROR <span style="color:#f92672">&amp;&amp;</span> WSAGetLastError() <span style="color:#f92672">!=</span> WSAEWOULDBLOCK)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fd_set writeset;
</span></span><span style="display:flex;"><span>FD_ZERO(<span style="color:#f92672">&amp;</span>writeset);
</span></span><span style="display:flex;"><span>FD_SET(m_hSocket, <span style="color:#f92672">&amp;</span>writeset);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span> tv <span style="color:#f92672">=</span> { timeout, <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">::</span>select(m_hSocket <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, NULL, <span style="color:#f92672">&amp;</span>writeset, NULL, <span style="color:#f92672">&amp;</span>tv) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> TRUE;
</span></span></code></pre></div><p>我们看看teamtalk里面怎么做的：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/73b7110244d290d86c02d5a5e9363c27.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
​</p>
<p>红色箭头的地方调用connect函数连接服务器，然后绿色的箭头等待一个事件有信号（内部使用WaitForSingleObject函数），那事件什么时候有信号呢？</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/ff43ce85a46dee21749e84cc52fc9a7e.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>网络线程检测第一次到socket可写时，调用onConnectDone函数：</p>
<p><img loading="lazy" src="http://haokiu.seaxiang.com/haokiu/1359bd406bb758b5bbc29c98ca2fac5f.png" alt=""  />
<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>
<p>实际做的事情还是和上面介绍的差不多。其实对于登录流程做成同步的，也是和这个类似，上文中我们介绍过。我早些年刚做windows网络通信方面的项目时，开始总是找不到好的处理等待登录请求应答的方法。这里是一种很不错的设置超时等待的方法。</p>
<ol start="3">
<li>teamtalk的截图功能</li>
</ol>
<p>不知道，你在使用qq这样的截图工具时，QQ截图工具能自动检测出某个窗口的范围。这个功能在teamtalk中也有实现，实现代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL ScreenCapture<span style="color:#f92672">::</span>initCapture(__in HWND hWnd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//register hot key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>wstring screenCaptureHotkeyName <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;_SCREEN_CAPTURE_HOTKEY&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> iHotkeyId <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)GlobalAddAtom(screenCaptureHotkeyName.c_str());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>RegisterHotKey(hWnd, iHotkeyId, MOD_CONTROL <span style="color:#f92672">|</span> MOD_SHIFT, <span style="color:#ae81ff">0x51</span>)) <span style="color:#75715e">//ctrl + shift + Q
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        GlobalDeleteAtom(iHotkeyId);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_iHotkeyId <span style="color:#f92672">=</span> iHotkeyId;
</span></span><span style="display:flex;"><span>	m_hRegisterHotkeyWnd <span style="color:#f92672">=</span> hWnd;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">createMsgWindow</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>程序初始化时，注册截屏快捷键，这里是ctrl+shift+Q（QQ默认是ctrl+alt+A）。当点击截屏按钮之后，开始启动截图：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>HWND hDesktopWnd <span style="color:#f92672">=</span> GetDesktopWindow();
</span></span><span style="display:flex;"><span>HDC hScreenDC <span style="color:#f92672">=</span> GetDC(hDesktopWnd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RECT rc <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>GetWindowRect(hDesktopWnd, <span style="color:#f92672">&amp;</span>rc);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cx <span style="color:#f92672">=</span> rc.right <span style="color:#f92672">-</span> rc.left;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cy <span style="color:#f92672">=</span> rc.bottom <span style="color:#f92672">-</span> rc.top;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HBITMAP hBitmap <span style="color:#f92672">=</span> CreateCompatibleBitmap(hScreenDC, cx, cy);
</span></span><span style="display:flex;"><span>m_hMemDC <span style="color:#f92672">=</span> CreateCompatibleDC(hScreenDC);
</span></span><span style="display:flex;"><span>HGDIOBJ hOldBitmap <span style="color:#f92672">=</span> SelectObject(m_hMemDC, (HGDIOBJ)hBitmap);
</span></span><span style="display:flex;"><span>BitBlt(m_hMemDC, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, cx, cy, hScreenDC, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SRCCOPY);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>m_hBkgMemDC <span style="color:#f92672">=</span> CreateCompatibleDC(hScreenDC);
</span></span><span style="display:flex;"><span>HBITMAP hBkgBitmap <span style="color:#f92672">=</span> CreateCompatibleBitmap(hScreenDC, cx, cy);
</span></span><span style="display:flex;"><span>SelectObject(m_hBkgMemDC, (HGDIOBJ)hBkgBitmap);
</span></span><span style="display:flex;"><span>BitBlt(m_hBkgMemDC, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, cx, cy, hScreenDC, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SRCCOPY);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HDC hMaskDC <span style="color:#f92672">=</span> CreateCompatibleDC(hScreenDC);
</span></span><span style="display:flex;"><span>HBITMAP hMaskBitmap <span style="color:#f92672">=</span> CreateCompatibleBitmap(hScreenDC, cx, cy);
</span></span><span style="display:flex;"><span>SelectObject(hMaskDC, (HGDIOBJ)hMaskBitmap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BLENDFUNCTION ftn <span style="color:#f92672">=</span> { AC_SRC_OVER, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>AlphaBlend(m_hBkgMemDC, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, cx, cy, hMaskDC, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, cx, cy, ftn);
</span></span><span style="display:flex;"><span>DeleteObject(hMaskBitmap);
</span></span><span style="display:flex;"><span>DeleteDC(hMaskDC);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>m_hDrawMemDC <span style="color:#f92672">=</span> CreateCompatibleDC(hScreenDC);
</span></span><span style="display:flex;"><span>HBITMAP hDrawBitmap <span style="color:#f92672">=</span> CreateCompatibleBitmap(hScreenDC, cx, cy);
</span></span><span style="display:flex;"><span>SelectObject(m_hDrawMemDC, hDrawBitmap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReleaseDC(hDesktopWnd, hScreenDC);
</span></span></code></pre></div><p>实际上就是在桌面窗口上画图。再遍历当前所有有显示区域的窗口，并记录这些窗口的窗口句柄和矩形区域：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (HWND hWnd <span style="color:#f92672">=</span> GetTopWindow(NULL); NULL <span style="color:#f92672">!=</span> hWnd; hWnd <span style="color:#f92672">=</span> GetWindow(hWnd, GW_HWNDNEXT))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>IsWindow(hWnd)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">||</span> <span style="color:#f92672">!</span>IsWindowVisible(hWnd)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">||</span> IsIconic(hWnd))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	RECT rcWnd <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>	GetWindowRect(hWnd, <span style="color:#f92672">&amp;</span>rcWnd);
</span></span><span style="display:flex;"><span>	adjustRectInScreen(rcWnd);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ScreenCommon<span style="color:#f92672">::</span>isRectEmpty(rcWnd))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">wchar_t</span> szTxt[MAX_PATH] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>	GetWindowText(hWnd, szTxt, MAX_PATH);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (wcslen(szTxt) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//combine the rect with the screen rect
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	m_lsWndList.push_back(ScreenCaptureWndInfo(hWnd, rcWnd));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> m_lsWndList.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><p>然后显示一个截图工具：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL UIScreenCaptureMgr<span style="color:#f92672">::</span>createWindows()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_hBkgUI <span style="color:#f92672">=</span> BkgroundUI<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>createWindow();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">wchar_t</span> szImg[MAX_PATH] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>	GetModuleFileName(NULL, szImg, MAX_PATH);
</span></span><span style="display:flex;"><span>	PathRemoveFileSpec(szImg);
</span></span><span style="display:flex;"><span>	PathRemoveFileSpec(szImg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>wstring strBkgPic <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>wstring(szImg) <span style="color:#f92672">+</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">gui</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">ScreenCapture</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">sc_toolbar_normal.png&#34;</span>;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>wstring strHoverPic <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>wstring(szImg) <span style="color:#f92672">+</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">gui</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">ScreenCapture</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">sc_toolbar_hover.png&#34;</span>;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>wstring strSelPic <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>wstring(szImg) <span style="color:#f92672">+</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">gui</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">ScreenCapture</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">sc_toolbar_select.png&#34;</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	EditToolbarInfo toolBarInfo <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">193</span>, <span style="color:#ae81ff">37</span>,
</span></span><span style="display:flex;"><span>		strBkgPic,
</span></span><span style="display:flex;"><span>		strHoverPic,
</span></span><span style="display:flex;"><span>		strSelPic,
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			{ <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">31</span> },
</span></span><span style="display:flex;"><span>			{ <span style="color:#ae81ff">43</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">69</span>, <span style="color:#ae81ff">31</span> },
</span></span><span style="display:flex;"><span>			{ <span style="color:#ae81ff">85</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">112</span>, <span style="color:#ae81ff">31</span> },
</span></span><span style="display:flex;"><span>			{ <span style="color:#ae81ff">119</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">185</span>, <span style="color:#ae81ff">31</span> }
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m_hEditToolBarUI <span style="color:#f92672">=</span> EditToolbarUI<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>createWindow(toolBarInfo, m_hBkgUI);
</span></span><span style="display:flex;"><span>    SetWindowPos(m_hBkgUI, HWND_TOPMOST, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SWP_NOSIZE <span style="color:#f92672">|</span> SWP_NOMOVE);
</span></span><span style="display:flex;"><span>    forceForgroundWindow(m_hBkgUI);
</span></span><span style="display:flex;"><span>	ShowWindow(m_hBkgUI, SW_SHOW);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后安装一个消息钩子（hook）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL ScreenCapture<span style="color:#f92672">::</span>installMsgHook(BOOL bInstall)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	BOOL result <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (bInstall)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_hMouseHook)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			m_hMouseHook <span style="color:#f92672">=</span> SetWindowsHookEx(WH_MOUSE, MouseProc, NULL, GetCurrentThreadId());
</span></span><span style="display:flex;"><span>			result <span style="color:#f92672">=</span> (NULL <span style="color:#f92672">!=</span> m_hMouseHook);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		UnhookWindowsHookEx(m_hMouseHook);
</span></span><span style="display:flex;"><span>		m_hMouseHook <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		result <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LRESULT ScreenCapture<span style="color:#f92672">::</span>MouseProc(_In_ <span style="color:#66d9ef">int</span> nCode, _In_ WPARAM wParam, _In_ LPARAM lParam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	PMOUSEHOOKSTRUCT pHookInfo <span style="color:#f92672">=</span> (PMOUSEHOOKSTRUCT)lParam;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> xPos <span style="color:#f92672">=</span> pHookInfo<span style="color:#f92672">-&gt;</span>pt.x;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> yPos <span style="color:#f92672">=</span> pHookInfo<span style="color:#f92672">-&gt;</span>pt.y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LRESULT lResHandled <span style="color:#f92672">=</span> CallNextHookEx(ScreenCapture<span style="color:#f92672">::</span>getInstance()<span style="color:#f92672">-&gt;</span>getMouseHook(), nCode, wParam, lParam);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (WM_LBUTTONDBLCLK <span style="color:#f92672">==</span> wParam )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>        ScreenCommon<span style="color:#f92672">::</span>postNotifyMessage(WM_SNAPSHOT_FINISH_CAPTURE, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (WM_RBUTTONDBLCLK <span style="color:#f92672">==</span> wParam)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ScreenCommon<span style="color:#f92672">::</span>postNotifyMessage(WM_SNAPSHOT_CANCEL_CPATURE, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (WM_LBUTTONDOWN <span style="color:#f92672">==</span> wParam)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (CM_AUTO_SELECT <span style="color:#f92672">==</span> CaptureModeMgr<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>getMode())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            CaptureModeMgr<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>changeMode(CM_MANAL_SELECT);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CaptureModeMgr<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>handleMouseMsg(wParam, xPos, yPos);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> lResHandled;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在钩子函数中，如果出现鼠标双击事件，则表示取消截图；如果出现双击事件，则表示完成截图。如果鼠标按下则表示开始绘制截图区域，然后处理鼠标移动事件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CaptureModeMgr<span style="color:#f92672">::</span>handleMouseMsg(__in UINT uMsg, __in <span style="color:#66d9ef">int</span> xPos, __in <span style="color:#66d9ef">int</span> yPos)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	IModeMsgHandler <span style="color:#f92672">*</span>msgHandler <span style="color:#f92672">=</span> getModeHandler();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>msgHandler) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (WM_MOUSEMOVE <span style="color:#f92672">==</span> uMsg)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		msgHandler<span style="color:#f92672">-&gt;</span>onMouseMove(xPos, yPos);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (WM_LBUTTONDOWN <span style="color:#f92672">==</span> uMsg)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		msgHandler<span style="color:#f92672">-&gt;</span>onLButtonDown(xPos, yPos);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (WM_LBUTTONUP <span style="color:#f92672">==</span> uMsg)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		msgHandler<span style="color:#f92672">-&gt;</span>onLButtonUp(xPos, yPos);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (WM_LBUTTONDBLCLK <span style="color:#f92672">==</span> uMsg)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		msgHandler<span style="color:#f92672">-&gt;</span>onLButtonDBClick(xPos, yPos);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>选取区域结束时，将选择的区域保存为位图并存至某个路径下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> ScreenCapture<span style="color:#f92672">::</span>finishCapture()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	RECT rcSelect <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>	UIScreenCaptureMgr<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>sendBkgMessage(WM_SNAPSHOT_TEST_SELECT_RECT, (WPARAM)<span style="color:#f92672">&amp;</span>rcSelect, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    rcSelect.left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    rcSelect.top <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    rcSelect.right <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    rcSelect.bottom <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ScreenCommon<span style="color:#f92672">::</span>isRectEmpty(rcSelect))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		ScreenSnapshot<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>saveRect(rcSelect, m_strSavePath);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	cancelCapture();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_callBack) m_callBack<span style="color:#f92672">-&gt;</span>onScreenCaptureFinish(m_strSavePath);
</span></span><span style="display:flex;"><span>}	RECT rcSelect <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>	UIScreenCaptureMgr<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>sendBkgMessage(WM_SNAPSHOT_TEST_SELECT_RECT, (WPARAM)<span style="color:#f92672">&amp;</span>rcSelect, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    rcSelect.left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    rcSelect.top <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    rcSelect.right <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    rcSelect.bottom <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ScreenCommon<span style="color:#f92672">::</span>isRectEmpty(rcSelect))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		ScreenSnapshot<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>saveRect(rcSelect, m_strSavePath);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	cancelCapture();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (m_callBack) m_callBack<span style="color:#f92672">-&gt;</span>onScreenCaptureFinish(m_strSavePath);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL ScreenSnapshot<span style="color:#f92672">::</span>saveRect(__in RECT <span style="color:#f92672">&amp;</span>rc, __in std<span style="color:#f92672">::</span>wstring <span style="color:#f92672">&amp;</span>savePath)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	snapshotScreen();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CxImage img;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> cx <span style="color:#f92672">=</span> rc.right <span style="color:#f92672">-</span> rc.left;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> cy <span style="color:#f92672">=</span> rc.bottom <span style="color:#f92672">-</span> rc.top;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	HDC hSaveDC <span style="color:#f92672">=</span> CreateCompatibleDC(m_hMemDC);
</span></span><span style="display:flex;"><span>	HBITMAP hBitmap <span style="color:#f92672">=</span> CreateCompatibleBitmap(m_hMemDC, cx, cy);
</span></span><span style="display:flex;"><span>	HBITMAP hSaveBitmap <span style="color:#f92672">=</span> (HBITMAP)SelectObject(hSaveDC, (HGDIOBJ)hBitmap);
</span></span><span style="display:flex;"><span>	BitBlt(hSaveDC, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, cx, cy, m_hMemDC, rc.left, rc.top, SRCCOPY);
</span></span><span style="display:flex;"><span>	hBitmap <span style="color:#f92672">=</span> (HBITMAP)SelectObject(hSaveDC, (HBITMAP)hSaveBitmap);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	BOOL result <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>img.CreateFromHBITMAP(hBitmap))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>img.Save(savePath.c_str(), CXIMAGE_FORMAT_BMP))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		result <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> (FALSE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	DeleteObject((HGDIOBJ)hBitmap);
</span></span><span style="display:flex;"><span>	DeleteDC(hSaveDC);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意整个过程使用了一个神奇的windows API，你没看错，它叫mouse_event，很少有windows API长成这个样子。利用这个api可以用程序模拟鼠标很多事件，后面有时间我会专门介绍一下这个有用的API函数。当然，关于截图的描述，你可能有点迷糊。没关系，后面我会专门写一篇文章细致地探究下teamtalk的屏幕截图效果实现，因为这里面有价值的东西很多。</p>
<ol start="4">
<li>线程的创建</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>IMCoreErrorCode OperationManager<span style="color:#f92672">::</span>startup()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	m_operationThread <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>([<span style="color:#f92672">&amp;</span>]
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>unique_lock <span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lck(m_cvMutex);
</span></span><span style="display:flex;"><span>		Operation<span style="color:#f92672">*</span> pOperation <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (m_bContinue)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_bContinue)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (m_vecRealtimeOperations.empty())
</span></span><span style="display:flex;"><span>				m_CV.wait(lck);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_bContinue)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(m_mutexOperation);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (m_vecRealtimeOperations.empty())
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>				pOperation <span style="color:#f92672">=</span> m_vecRealtimeOperations.front();
</span></span><span style="display:flex;"><span>				m_vecRealtimeOperations.pop_front();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_bContinue)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (pOperation)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				pOperation<span style="color:#f92672">-&gt;</span>process();
</span></span><span style="display:flex;"><span>				pOperation<span style="color:#f92672">-&gt;</span>release();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> IMCORE_OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这是利用lamda表达式创建一个线程典型的语法，其中m_operationThread是一个成员变量，类型是std::thread，std::thread([&amp;]中括号中的&amp;符号表示该lamda表达式以引用的方式捕获了所有外部的自动变量，这是在一个成员函数里面，也就是说在线程函数里面可以以引用的方式使用该类的所有成员变量。这个语法值得大家学习。</p>
<ol start="5">
<li>teamtalk的httpclient工程可以直接拿来使用，作者主页：http://xiangwangfeng.com，github链接：https://github.com/xiangwangfeng/httpclient。</li>
</ol>
<p>另外teamtalk pc端大量使用C++11的语法和一些替代原来平常的写法，这个就不专门列出来了，后面我将会专门写一篇文章来介绍C++11中那些好用的工程级技巧。</p>
<p>好了，这篇文章就到此为止了。限于作者水平有限，文中难免有错漏和不足，欢迎批评指正。<img loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"  />
</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://haokiu.com/601f5e2b4c0a4303a540259d9d394d0b/">
    <span class="title">« Prev</span>
    <br>
    <span>10 开放一个TeamTalk测试服务器地址和几个测试账号</span>
  </a>
  <a class="next" href="https://haokiu.com/8d180ec3ae3e409bac6e8a67811f54bc/">
    <span class="title">Next »</span>
    <br>
    <span>11 一种高性能网络游戏服务器架构设计</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
