<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.119.0"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>haokiu</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://haokiu.com/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://haokiu.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://haokiu.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://haokiu.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://haokiu.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://haokiu.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://haokiu.com/index.xml">
<link rel="alternate" type="application/json" href="https://haokiu.com/index.json">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="haokiu" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://haokiu.com/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="haokiu"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "haokiu",
  "url": "https://haokiu.com/",
  "description": "",
  "thumbnailUrl": "https://haokiu.com/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://haokiu.com/" accesskey="h" title="haokiu (Alt + H)">haokiu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://haokiu.com/" title="haokiu">
                    <span class="active">Home</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/1/" title="1s">
                    <span>后端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/2/" title="2s">
                    <span>前端</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/3/" title="3s">
                    <span>区块链</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/4/" title="4s">
                    <span>大数据</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/5/" title="5s">
                    <span>linux</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/6/" title="6s">
                    <span>其他</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/tags/" title="Tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://haokiu.com/categories/" title="Categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2>腾讯后台开发实习生技能要求
    </h2>
  </header>
  <div class="entry-content">
    <p>腾讯后台开发实习生技能要求 如题，应届生除了要良好地掌握算法和数据结构以外，以下一些技能点列表希望对大家有帮助，有兴趣的朋友可以参考这个针对性地补缺补差。文章列出的技能点有的要求熟悉，有的了解即可，注意技能点前面的修饰词。如果没有明确给出“熟悉”“了解”等字眼，要求均为熟悉。
一、操作系统方面 多线程相关与线程之间同步技术 熟练使用（但不局限于）以下linux API
linux下的线程创建、等待、获取线程id
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); int pthread_join(pthread_t thread, void **retval); pthread_t pthread_self(void); 常见线程之间的同步技术（何时该用那种技术）
互斥体
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr); int pthread_mutex_destroy(pthread_mutex_t *mutex); int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); 信号量
int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_destroy(sem_t *sem); int sem_wait(sem_t *sem); int sem_post(sem_t *sem); int sem_getvalue(sem_t *sem, int *valp); 条件变量
int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); 读写/自旋锁...</p>
  </div>
  <footer class="entry-footer"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span></footer>
  <a class="entry-link" aria-label="post link to 腾讯后台开发实习生技能要求" href="https://haokiu.com/5f118ee0e1be49a8a754072ecb9b441a/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>详解 C&#43;&#43; 11 中的智能指针
    </h2>
  </header>
  <div class="entry-content">
    <p>详解 C&#43;&#43; 11 中的智能指针 C/C&#43;&#43; 语言最为人所诟病的特性之一就是存在内存泄露问题，因此后来的大多数语言都提供了内置内存分配与释放功能，有的甚至干脆对语言的使用者屏蔽了内存指针这一概念。这里不置贬褒，手动分配内存与手动释放内存有利也有弊，自动分配内存和自动释放内存亦如此，这是两种不同的设计哲学。有人认为，内存如此重要的东西怎么能放心交给用户去管理呢？而另外一些人则认为，内存如此重要的东西怎么能放心交给系统去管理呢？在 C/C&#43;&#43; 语言中，内存泄露的问题一直困扰着广大的开发者，因此各类库和工具的一直在努力尝试各种方法去检测和避免内存泄露，如 boost，智能指针技术应运而生。
C&#43;&#43; 98/03 的尝试——std::auto_ptr 在 2019 年讨论 std::auto_ptr 不免有点让人怀疑是不是有点过时了，确实如此，随着 C&#43;&#43;11 标准的出现（最新标准是 C&#43;&#43;20），std::auto_ptr 已经被彻底废弃了，取而代之是 std::unique_ptr。然而，我之所以还向你介绍一下 std::auto_ptr 的用法以及它的设计不足之处是想让你了解 C&#43;&#43; 语言中智能指针的发展过程，一项技术如果我们了解它过去的样子和发展的轨迹，我们就能更好地掌握它，不是吗？
std::auto_ptr 的基本用法如下代码所示：
#include &lt;memory&gt; int main() { //初始化方式1 std::auto_ptr&lt;int&gt; sp1(new int(8)); //初始化方式2 std::auto_ptr&lt;int&gt; sp2; sp2.reset(new int(8)); return 0; } 智能指针对象 sp1 和 sp2 均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在 sp1 和 sp2 释放时得到释放。这是 std::auto_ptr 的基本用法。
sp 是 smart pointer（智能指针）的简写。
std::auto_ptr 真正让人容易误用的地方是其不常用的复制语义，即当复制一个 std::auto_ptr 对象时（拷贝复制或 operator = 复制），原对象所持有的堆内存对象也会转移给复制出来的对象。示例代码如下：
#include &lt;iostream&gt; #include &lt;memory&gt; int main() { //测试拷贝构造 std::auto_ptr&lt;int&gt; sp1(new int(8)); std::auto_ptr&lt;int&gt; sp2(sp1); if (sp1.get() != NULL) { std::cout &lt;&lt; &#34;sp1 is not empty.&#34; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &#34;sp1 is empty....</p>
  </div>
  <footer class="entry-footer"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span></footer>
  <a class="entry-link" aria-label="post link to 详解 C&#43;&#43; 11 中的智能指针" href="https://haokiu.com/913fb3f31d024baf871726b2f22cdfde/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>谈一谈年终奖
    </h2>
  </header>
  <div class="entry-content">
    <p>谈一谈年终奖 转眼 2019 年就快过完了，对于广大程序员读者来说，重要的事情除了关心能不能买到回老家的车票以外，剩下的事情应该就属年终奖了。
对于 IT 行业来说，所谓年终奖其实就是公司在当年的月底基于你工资的数额发一定的比例的奖金，这也是很多企业的 HR 和猎头向求职者“许诺”的待遇之一。关于年终奖，一般是求职者在应聘时和 HR 谈好，再结合所在的公司的规定在年终兑现给求职者。但是，城市的套路太深了，本文就和大家讨论一下关于年终奖的那些坑，希望对读者朋友有一定启发意义。
年终奖的计算套路 先来说通用规则吧。IT 行业默认的不成文的规定，大多数公司，对于普通员工的年终奖一般是月底多发一个月工资，也就是所谓的 13 薪，这个基本上是保底的。对于从事开发的小伙伴来说，这个规则适用于初中高级，对于技术专家或者开发经理及以上级别一般保底工资会大于 13 薪，常见的是 14 ~ 16 薪不等，总结起来，就是所谓 12 &#43; n，n 的可能取值是 1 ~ 5，它们就是所谓的年终奖，这是大多数公司的通用做法。但是在这些规定的基础之上不同的公司也有一些特殊的规定，常见的有如下几种形式：
年终奖的数量是 n 个月的月薪，但是要根据员工在当年在公司实际工作的天数来定，也就是说员工实际拿到的年终奖数目是 年终奖数目 = 月薪 * n * （员工当年实际工作的天数 / 365）
举个例子，员工小明在某公司当年工作半年，其月薪是 20k， 当时和 HR 谈好是 2 个月年终奖（n = 2），那么小明当年拿到的年终奖是数额是：20000 * 2 * 0.5 = 20000。
ok，有读者看到这里可能美滋滋，他可能会想，今年 12 月 1 日入职现在的公司，按这个规则年终奖是 2 个月，那么我今年的年终奖可以拿到 20000 * 2 * （1 / 12） = 3333，3333 元也不少啦，过年回家给长辈或者小朋友包个红包，或者给女朋友买几件衣服也是戳戳有余的啦。我只能说，这位读者想多了。因为某些公司还有第 2 条规定。
计算年终奖系数时虽然按员工当年实际工作的天数 / 365，但是如果员工当年实际工作的天数小于某个数值（例如 2 个月），则系数为 0。也就是说，很多 12 月份入职该公司的小伙伴在当年大概率是没有年终奖的。
除了上述两个规定外，企业对于年终奖还有一个比较常见的规定，就是年终奖绩效正态分布制。啥意思呢？举个例子，我在求职某大型旅游互联网公司时，HR 告诉我待遇是 16 薪，于是我就相信了。等到当年年底的时候发现，果然是 16 薪啊，但是每个员工都需要进行绩效考评，绩效分为 ABCD 四个等级，A 最优，D 最差，且 ABCD 四个等级的比例是 20%、30%、30%、20%，也就是说一个部门 10 个人，实际上只有 2 个人能拿到 16 薪，剩下的依次是 15 薪、14 薪和 13 薪。到此时，我也只能无奈的接受现实。...</p>
  </div>
  <footer class="entry-footer"><span title='2021-01-11 09:20:42 +0000 UTC'>January 11, 2021</span></footer>
  <a class="entry-link" aria-label="post link to 谈一谈年终奖" href="https://haokiu.com/0f72f7a83bbb4b4fb76a05dc63f5480c/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>golang 数组与切片的区别
    </h2>
  </header>
  <div class="entry-content">
    <p>golang 的数组与切片有两大区别：
初始化：数组需要明确指定大小，切片不需要 函数传递：数组是值传递，切片是地址传递 初始化 数组 a := [...]int{1,2,3} a := [3]int{1,2,3} 切片 a:= []int{1,2,3} a := make([]int, 5) a := make([]int, 5, 10) slice的数据结构： go源码slice的数据结构定义：
type slice struct { array unsafe.Pointer len int cap int } slice 有三个字段：
指向真实 array 地址的指针 ptr slice 的长度 len 容量 cap 特性 通过例子说明 slice 和 array 的一些特性。
函数传递 数组需要明确指定大小，切片不需要。数组是值传递，切片是地址传递
a := [...]int{1, 2, 3, 4, 5, 6} fmt.Println(&#34;star deal array, orginal data is:&#34;) fmt.Println(a) aMaxIndex := len(a) - 1 fmt.Printf(&#34;aMaxIndex:%d\r&#34;, aMaxIndex) for i, e := range a { if i == aMaxIndex { a[0] &#43;= e fmt.Printf(&#34;index is 0, val is :%d\r&#34;, a[0]) } else { a[i&#43;1] &#43;= e fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2020-11-19 17:09:23 +0000 UTC'>November 19, 2020</span></footer>
  <a class="entry-link" aria-label="post link to golang 数组与切片的区别" href="https://haokiu.com/gnNp9N/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>go 匿名结构体 数组 示例
    </h2>
  </header>
  <div class="entry-content">
    <p>在用 vscode 生成测试用例的时候，生成了测试的匿名数组，没怎么用过，这里展示了 go 匿名结构体数组示例
import &#34;testing&#34; func TestGetRandomString(t *testing.T) { type args struct { lens int } tests := []struct { name string args args want string }{ { name: &#34;test&#34;, args: args{ lens: 6, }, want: &#34;hi&#34;, }, { name: &#34;test&#34;, args: args{ lens: 6, }, want: &#34;hi&#34;, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := GetRandomString(tt.args.lens); got != tt.want { t.Logf(&#34;GetRandomString() = %v, want %v&#34;, got, tt.want) } }) } } 需要注意的是各个结构体后面有个逗号。</p>
  </div>
  <footer class="entry-footer"><span title='2020-11-09 10:54:29 +0000 UTC'>November 9, 2020</span></footer>
  <a class="entry-link" aria-label="post link to go 匿名结构体 数组 示例" href="https://haokiu.com/XVVOUE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>curl https 地址报异常
    </h2>
  </header>
  <div class="entry-content">
    <p>用 acme.sh 生产了 Let’s Encrypt 的https 证书，在浏览器访问没有问题，但在服务器访问出现下面的异常：
curl: (60) SSL certificate problem: unable to get local issuer certificate More details here: https://curl.haxx.se/docs/sslcerts.html curl failed to verify the legitimacy of the server and therefore could not establish a secure connection to it. To learn more about this situation and how to fix it, please visit the web page mentioned above. 网站用了beego，用 acme.sh 生成的证书。配置：
EnableHTTPS = true HTTPSPort = 443 HTTPSCertFile = &#34;/home/blog/cert/cert.pem&#34; HTTPSKeyFile = &#34;/home/blog/cert/key.pem&#34; 要将 cert.pem 替换为：fullchain.pem
EnableHTTPS = true HTTPSPort = 443 HTTPSCertFile = &#34;/home/blog/cert/fullchain.pem&#34; HTTPSKeyFile = &#34;/home/blog/cert/key.pem&#34; </p>
  </div>
  <footer class="entry-footer"><span title='2020-10-23 15:03:17 +0000 UTC'>October 23, 2020</span></footer>
  <a class="entry-link" aria-label="post link to curl https 地址报异常" href="https://haokiu.com/KsbUyb/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>beego 让http请求跳转到 https
    </h2>
  </header>
  <div class="entry-content">
    <p>如果beego配置了https，那么可以让 让http请求跳转到 https，怎样配置 beego 的https，可以参考beego 通过acms.sh 使用 https
//siteUrl 是网站地址，比如:https://haokiu.com if &#34;HTTP/1.1&#34; == self.Ctx.Request.Proto &amp;&amp; siteUrl != &#34;&#34; &amp;&amp; strings.HasPrefix(siteUrl, &#34;https&#34;) { //如果支持https，则所有http请求跳转到https self.redirect(siteUrl &#43; self.Ctx.Request.URL.Path) } </p>
  </div>
  <footer class="entry-footer"><span title='2020-10-13 16:33:55 +0000 UTC'>October 13, 2020</span></footer>
  <a class="entry-link" aria-label="post link to beego 让http请求跳转到 https" href="https://haokiu.com/ZSf4yF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>beego 通过acme.sh 使用 https
    </h2>
  </header>
  <div class="entry-content">
    <p>beego 通过 acme.sh 使用 https
安装acms.sh curl https://get.acme.sh | sh 生成证书 如果使用的是 beego 框架，需添加可访问的静态文件目录：
//acme.sh 自动验证网站目录，不使用https可以忽略 beego.SetStaticPath(&#34;/.well-known&#34;, &#34;.well-known&#34;) acme.sh --issue -d haokiu.com -d www.haokiu.com --webroot /usr/local/pixiublog/ 设置pixiublog开机启动 1. 编写开机启动脚本 vim /usr/lib/systemd/system/pixiublog.service
[Unit] Description=The pixiublog Process Manager After=syslog.target network.target [Service] Type=forking ExecStart=sh /usr/local/pixiublog/start.sh ExecReload=/bin/kill -USR2 $MAINPID ExecStop=/bin/kill -SIGINT $MAINPID [Install] WantedBy=multi-user.target 2. 设置开机启动 systemctl enable pixiublog 安装证书 acme.sh --install-cert -d haokiu.com \ --cert-file /home/blog/cert/cert.pem \ --key-file /home/blog/cert/key.pem \ --fullchain-file /home/blog/cert/fullchain.pem \ --reloadcmd &#34;systemctl restart pixiublog&#34; beego app.conf 配置 EnableHTTPS = true HTTPSPort = 443 HTTPSCertFile = &#34;/home/blog/cert/fullchain.pem&#34; HTTPSKeyFile = &#34;/home/blog/cert/key.pem&#34; 参考 acme.sh 使用</p>
  </div>
  <footer class="entry-footer"><span title='2020-10-13 15:20:09 +0000 UTC'>October 13, 2020</span></footer>
  <a class="entry-link" aria-label="post link to beego 通过acme.sh 使用 https" href="https://haokiu.com/qP3u4V/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>acme.sh 方便管理 letsencrypt 
    </h2>
  </header>
  <div class="entry-content">
    <p>acme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书。这个脚本可以非常方便的管理 letsencrypt 的证书，省去很多繁琐操作。有了这个脚本就可以方便地给网站使用 https 了
主要步骤:
安装 acme.sh 生成证书 copy 证书到 nginx/apache 或者其他服务 更新证书 更新 acme.sh 出错怎么办, 如何调试 下面详细介绍.
1. 安装 acme.sh 安装很简单, 一个命令:
curl https://get.acme.sh | sh 普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:
把 acme.sh 安装到你的 home 目录下: ~/.acme.sh/ 并创建 一个 bash 的 alias, 方便你的使用: alias acme.sh=~/.acme.sh/acme.sh
2). 自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书.
更高级的安装选项请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-install
安装过程不会污染已有的系统任何功能和文件, 所有的修改都限制在安装目录中: ~/.acme.sh/
2. 生成证书 acme.sh 实现了 acme 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证.
1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了. acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/ 只需要指定域名, 并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.
如果你用的 apache服务器, acme....</p>
  </div>
  <footer class="entry-footer"><span title='2020-10-12 18:01:57 +0000 UTC'>October 12, 2020</span></footer>
  <a class="entry-link" aria-label="post link to acme.sh 方便管理 letsencrypt " href="https://haokiu.com/6D0DBH/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>go ... 作用
    </h2>
  </header>
  <div class="entry-content">
    <p>… 是go的一种语法糖。
作用 用于函数有多个不定参数的情况，可以接受多个不确定数量的参数 打散slice进行传递 例子 一、接受多个不确定数量的参数 func println(args ...string) { //可以接受任意个string参数 for _, v:= range args{ fmt.Println(v) } } func main(){ var strss= []string{ &#34;qwr&#34;, &#34;234&#34;, &#34;yui&#34;, &#34;cvbc&#34;, } println(strss...) //切片被打散传入 } 结果：
qwr 234 yui cvbc 二、打散slice进行传递 var strss= []string{ &#34;qwr&#34;, &#34;234&#34;, &#34;yui&#34;, } var strss2= []string{ &#34;qqq&#34;, &#34;aaa&#34;, &#34;zzz&#34;, &#34;zzz&#34;, } strss=append(strss,strss2...) //strss2的元素被打散一个个append进strss fmt.Println(strss) 结果：
[qwr 234 yui qqq aaa zzz zzz] 最后 如果没有’…’，面对上面的情况，无疑会增加代码量。</p>
  </div>
  <footer class="entry-footer"><span title='2020-10-12 17:12:09 +0000 UTC'>October 12, 2020</span></footer>
  <a class="entry-link" aria-label="post link to go ... 作用" href="https://haokiu.com/hiUuGO/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://haokiu.com/index/18/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://haokiu.com/index/20/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
